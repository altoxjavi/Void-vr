<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>VOID VR</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      font-family: system-ui, sans-serif;
    }
    .overlay.hidden { display: none; }
    .overlay h1 {
      font-size: 64px;
      color: #ff2d7b;
      text-shadow: 0 0 40px rgba(255,45,123,0.6);
      margin: 0 0 10px 0;
      letter-spacing: 0.3em;
    }
    .overlay p {
      color: rgba(255,255,255,0.5);
      margin-bottom: 20px;
    }
    .overlay button {
      background: linear-gradient(180deg, rgba(255,45,123,0.3), rgba(255,45,123,0.1));
      border: 2px solid rgba(255,45,123,0.6);
      color: white;
      padding: 20px 60px;
      font-size: 24px;
      cursor: pointer;
      margin: 10px;
      transition: all 0.3s;
    }
    .overlay button:hover {
      background: linear-gradient(180deg, rgba(255,45,123,0.5), rgba(255,45,123,0.2));
      box-shadow: 0 0 40px rgba(255,45,123,0.5);
      transform: scale(1.05);
    }
    .preset-dots {
      display: flex; gap: 10px; margin: 10px 0 30px;
    }
    .preset-dot {
      width: 12px; height: 12px;
      border-radius: 50%;
      border: 2px solid rgba(255,45,123,0.4);
      cursor: pointer;
      transition: all 0.3s;
      background: transparent;
      padding: 0;
    }
    .preset-dot.active {
      background: #ff2d7b;
      box-shadow: 0 0 10px rgba(255,45,123,0.6);
    }
    .preset-label {
      color: rgba(255,255,255,0.4);
      font-size: 12px;
      margin-top: 5px;
    }
    .theme-selector {
      display: flex; gap: 8px; margin: 15px 0;
    }
    .theme-btn {
      padding: 8px 16px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.05);
      color: rgba(255,255,255,0.5);
      cursor: pointer;
      transition: all 0.3s;
    }
    .theme-btn.active {
      border-color: #ff2d7b;
      color: #ff2d7b;
      background: rgba(255,45,123,0.1);
    }
    .small-btn {
      font-size: 14px !important;
      padding: 10px 30px !important;
      opacity: 0.7;
      margin-top: 20px !important;
    }
    #fsResult {
      font-size: 12px;
      color: #00f0ff;
      margin-top: 10px;
      text-align: center;
    }
  </style>
</head>
<body>

<!-- Entry Overlay -->
<div class="overlay" id="overlay">
  <h1>VOID</h1>
  <p id="themeTagline">the end of consumption</p>
  
  <!-- Theme Selector -->
  <div class="theme-selector" id="themeSelector"></div>
  
  <!-- Session Preset Dots -->
  <div class="preset-dots" id="presetDots">
    <button class="preset-dot" data-preset="quick" title="Quick (10min)"></button>
    <button class="preset-dot active" data-preset="standard" title="Standard (20min)"></button>
    <button class="preset-dot" data-preset="extended" title="Extended (45min)"></button>
    <button class="preset-dot" data-preset="marathon" title="Marathon (90min)"></button>
  </div>
  <p class="preset-label" id="presetLabel">standard Â· 20 min</p>
  
  <button id="enterVR">â–º ENTER VR</button>
  <button id="enter2D" style="font-size: 16px; padding: 12px 30px; opacity: 0.7;">Start 2D</button>
  <button id="testFS" class="small-btn">ğŸ“ Link Content Folder</button>
  <p id="fsResult"></p>
</div>

<a-scene 
  id="scene"
  vr-mode-ui="enabled: false"
  renderer="antialias: true"
>
  <!-- Spiral shader sky -->
  <a-sky id="voidSky" void-spiral="intensity: 0.3" rotation="0 -90 0"></a-sky>
  
  <!-- BREATHING GUIDE - Pulsing sphere around user -->
  <a-entity id="breathSphere" void-breathing>
    <a-ring position="0 0.02 0" rotation="-90 0 0" radius-inner="2.0" radius-outer="2.05" 
            id="breathRing1" opacity="0.3"></a-ring>
    <a-ring position="0 0.02 0" rotation="-90 0 0" radius-inner="2.5" radius-outer="2.53" 
            id="breathRing2" opacity="0.2"></a-ring>
    <a-ring position="0 0.02 0" rotation="-90 0 0" radius-inner="3.0" radius-outer="3.02" 
            id="breathRing3" opacity="0.15"></a-ring>
  </a-entity>
  
  <!-- FLOOR -->
  <a-entity id="floor">
    <a-plane position="0 0 0" rotation="-90 0 0" width="20" height="20" 
             id="floorPlane" material="color: #0a0012; opacity: 0.9; transparent: true"></a-plane>
    <a-ring position="0 0.01 0" rotation="-90 0 0" radius-inner="0.95" radius-outer="1" 
            id="floorRing1" color="#ff2d7b" opacity="0.3"></a-ring>
    <a-ring position="0 0.01 0" rotation="-90 0 0" radius-inner="1.95" radius-outer="2" 
            id="floorRing2" color="#ff2d7b" opacity="0.2"></a-ring>
    <a-ring position="0 0.01 0" rotation="-90 0 0" radius-inner="2.95" radius-outer="3" 
            id="floorRing3" color="#ff2d7b" opacity="0.15"></a-ring>
    <a-ring position="0 0.02 0" rotation="-90 0 0" radius-inner="0.1" radius-outer="0.2" 
            color="#ff2d7b" opacity="0.5"></a-ring>
  </a-entity>
  
  <!-- MANTRA TEXT - Floating text that appears during session -->
  <a-entity id="mantraForward" position="0 1.6 -4" void-mantra="direction: forward">
    <a-text id="mantraTextForward" value="" align="center" color="#ff2d7b" 
            width="4" opacity="0"></a-text>
  </a-entity>
  <a-entity id="mantraLeft" position="-4 1.6 0" rotation="0 90 0" void-mantra="direction: left">
    <a-text id="mantraTextLeft" value="" align="center" color="#ff2d7b" 
            width="3" opacity="0"></a-text>
  </a-entity>
  <a-entity id="mantraRight" position="4 1.6 0" rotation="0 -90 0" void-mantra="direction: right">
    <a-text id="mantraTextRight" value="" align="center" color="#ff2d7b" 
            width="3" opacity="0"></a-text>
  </a-entity>
  
  <!-- SUBLIMINAL FLASH - Full screen flash text -->
  <a-entity id="subliminalEntity" position="0 1.6 -2" void-subliminal>
    <a-text id="subliminalText" value="" align="center" color="white" 
            width="6" opacity="0" font="mozillavr"></a-text>
  </a-entity>
  
  <!-- VR DEBUG CONSOLE -->
  <a-entity id="debugConsole" position="0 2.5 -2" follow-camera-height="offsetY: 0.6; offsetZ: -2">
    <a-plane width="2" height="0.8" color="#000" opacity="0.8"></a-plane>
    <a-text id="debugText" value="[Console Ready]" color="#0f0" 
            width="1.8" position="0 0 0.01" align="center" wrap-count="50"></a-text>
  </a-entity>
  
  <!-- STATUS HUD -->
  <a-entity id="statusHud" position="0 1.0 -1.5" follow-camera-height="offsetY: -0.4; offsetZ: -1.5" void-status-hud>
  </a-entity>

  <!-- Camera Rig -->
  <a-entity id="rig" position="0 0 0">
    <a-camera position="0 1.6 0"></a-camera>
    <a-entity id="leftController" oculus-touch-controls="hand: left" void-controller="hand: left"></a-entity>
    <a-entity id="rightController" oculus-touch-controls="hand: right" void-controller="hand: right"></a-entity>
  </a-entity>
</a-scene>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VOID VR v3.0 â€” Full Foundation Systems
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VR DEBUG CONSOLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const debugLines = [];
const MAX_LINES = 8;
const originalLog = console.log;
const originalError = console.error;
const originalWarn = console.warn;

function vrLog(msg, type = 'log') {
  const prefix = type === 'error' ? 'âŒ ' : type === 'warn' ? 'âš ï¸ ' : 'â†’ ';
  debugLines.push(prefix + String(msg).substring(0, 60));
  if (debugLines.length > MAX_LINES) debugLines.shift();
  const el = document.getElementById('debugText');
  if (el) el.setAttribute('value', debugLines.join('\n'));
  originalLog.apply(console, arguments);
}

console.log = function() { vrLog(Array.from(arguments).join(' '), 'log'); };
console.error = function() { vrLog(Array.from(arguments).join(' '), 'error'); };
console.warn = function() { vrLog(Array.from(arguments).join(' '), 'warn'); };
window.onerror = function(msg, url, line) { vrLog(`ERR L${line}: ${msg}`, 'error'); };

console.log('[VOID] VR v3.0 Init...');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const VoidState = {
  // Session
  running: false,
  paused: false,
  sessionStart: null,
  sessionDuration: 0,
  
  // Phase (0-4: INIT, ENTRAINMENT, ESCALATION, PEAK, RELEASE)
  phaseIndex: 0,
  phaseNames: ['INIT', 'ENTRAINMENT', 'ESCALATION', 'PEAK', 'RELEASE'],
  phaseProgress: 0,
  
  // Intensity
  intensity: 0.3,
  targetIntensity: 0.3,
  
  // Breathing
  breathProgress: 0,    // 0-1 cycle position
  breathRate: 6,         // BPM
  breathPhase: 'in',     // 'in' or 'out'
  
  // Wave system (BUILD/CREST alternation)
  waveState: 'BUILD',
  waveFloor: 0.3,
  waveCeiling: 0.7,
  waveCycleTime: 30000,  // ms per wave cycle
  waveProgress: 0,
  
  // User
  userHeight: 1.6,
  seated: false,
  
  // Audio
  audioEnabled: true,
  masterVolume: 0.6,
  
  // Theme
  currentTheme: 'void',
  
  // VR
  inVR: false,
  controllers: { left: null, right: null },
  
  // Content
  contentLoaded: false,
  contentCount: 0,
  contentFolderHandle: null,
  
  // Session preset
  preset: 'standard',
  presetDurations: {
    quick: 10 * 60 * 1000,
    standard: 20 * 60 * 1000,
    extended: 45 * 60 * 1000,
    marathon: 90 * 60 * 1000,
  },
  presetLabels: {
    quick: 'quick Â· 10 min',
    standard: 'standard Â· 20 min',
    extended: 'extended Â· 45 min',
    marathon: 'marathon Â· 90 min',
  },
  
  // Settings
  debugVisible: true,
  captionsEnabled: true,
  poppersEnabled: false,
  permissionEnabled: true,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EVENT BUS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const VoidEvents = {
  _listeners: {},
  
  on(event, callback) {
    if (!this._listeners[event]) this._listeners[event] = [];
    this._listeners[event].push(callback);
    return () => this.off(event, callback);
  },
  
  off(event, callback) {
    if (!this._listeners[event]) return;
    this._listeners[event] = this._listeners[event].filter(cb => cb !== callback);
  },
  
  emit(event, data) {
    if (!this._listeners[event]) return;
    this._listeners[event].forEach(cb => {
      try { cb(data); } catch (e) { console.error(`Event [${event}]:`, e); }
    });
  }
};

console.log('[VOID] State & Events ready');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SETTINGS PERSISTENCE (localStorage)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const Settings = {
  save() {
    try {
      const data = {
        theme: VoidState.currentTheme,
        preset: VoidState.preset,
        volume: VoidState.masterVolume,
        debug: VoidState.debugVisible,
        captions: VoidState.captionsEnabled,
        poppers: VoidState.poppersEnabled,
        permission: VoidState.permissionEnabled,
      };
      localStorage.setItem('void-vr-settings', JSON.stringify(data));
    } catch (e) { /* silently fail */ }
  },
  
  load() {
    try {
      const raw = localStorage.getItem('void-vr-settings');
      if (!raw) return;
      const data = JSON.parse(raw);
      
      if (data.theme && THEMES[data.theme]) VoidState.currentTheme = data.theme;
      if (data.preset && VoidState.presetDurations[data.preset]) VoidState.preset = data.preset;
      if (typeof data.volume === 'number') VoidState.masterVolume = data.volume;
      if (typeof data.debug === 'boolean') VoidState.debugVisible = data.debug;
      if (typeof data.captions === 'boolean') VoidState.captionsEnabled = data.captions;
      if (typeof data.poppers === 'boolean') VoidState.poppersEnabled = data.poppers;
      if (typeof data.permission === 'boolean') VoidState.permissionEnabled = data.permission;
      
      console.log(`Settings loaded: ${VoidState.currentTheme}/${VoidState.preset}`);
    } catch (e) { /* silently fail */ }
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THEMES â€” Full voice/visual/audio definitions (ported from 2D)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const THEMES = {
  // â”€â”€â”€ VOID â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  void: {
    name: 'VOID',
    subtitle: 'the end of consumption',
    
    shader: {
      bg: [0.02, 0.0, 0.05],
      spiral1: [0.6, 0.1, 0.4],
      spiral2: [0.3, 0.0, 0.6],
      plasma1: [0.8, 0.2, 0.5],
      plasma2: [0.2, 0.0, 0.7],
      glow: [1.0, 0.3, 0.6],
      accent: [0.0, 0.8, 1.0],
    },
    
    ui: {
      primary: '#ff2d7b',
      secondary: '#7b2dff',
      accent: '#00f0ff',
      background: '#0a0012',
      floor: '#0a0012',
    },
    
    audio: {
      baseFreq: 110,
      binauralDiff: 8,
      subBass: 55,
      volume: 0.6,
    },
    
    voice: {
      tone: 'whisper',
      narrative: {
        0: ['LOOK AT THE SCREEN', 'BREATHE', 'SETTLE IN', 'LET YOUR EYES SOFTEN',
            'THE SCREEN IS ALL THAT MATTERS', 'LET YOUR THOUGHTS SLOW', 'DON\'T LOOK AWAY',
            'RELAX YOUR JAW', 'FEEL THE PULSE', 'YOUR EYES ARE GETTING HEAVIER',
            'JUST YOU AND THE VOID', 'BREATHE DEEPER', 'YOU\'RE ALREADY SINKING', 'GOOD'],
        1: ['THAT\'S IT', 'YOUR MIND IS OPENING', 'CAN YOU FEEL IT?',
            'THE PULSE IS INSIDE YOU NOW', 'STOP THINKING', 'JUST FEEL',
            'YOUR THOUGHTS ARE DISSOLVING', 'DEEPER', 'THE VOID KNOWS YOU',
            'EVERY PULSE PULLS YOU IN', 'YOU DON\'T WANT TO LOOK AWAY', 'SURRENDER',
            'YOU\'RE DOING SO WELL', 'DEEPER AND DEEPER'],
        2: ['STROKE', 'THE VOID IS IN CONTROL NOW', 'LOOK AT WHAT IT SHOWS YOU',
            'YOUR HAND MOVES ON ITS OWN', 'DON\'T FIGHT IT', 'YOU NEED THIS',
            'FASTER', 'WHO\'S IN CONTROL?', 'EDGE', 'YOU CAN\'T STOP',
            'GIVE IN', 'GOOD BOY', 'MORE', 'YOU WERE MADE FOR THIS',
            'DEEPER INTO NOTHING', 'YOUR MIND BELONGS TO THE VOID'],
        3: ['YOU WANT IT SO BAD', 'NOT YET', 'HOLD IT', 'BEG',
            'ASK PERMISSION', 'THE VOID DECIDES', 'KEEP EDGING',
            'THE VOID ISN\'T DONE WITH YOU', 'HOLD', 'DENIED',
            'GOOD BOY', 'THE VOID OWNS YOU', 'ALMOST', 'KEEP BEGGING'],
      },
      mantras: {
        1: ['deeper', 'i obey'],
        2: ['i obey the void', 'deeper and deeper', 'i can\'t stop', 'the void controls me'],
        3: ['i belong to nothing', 'i am the void\'s gooner', 'i need this', 'i submit completely'],
      },
      subliminals: ['OBEY', 'DEEPER', 'GOON', 'SUBMIT', 'DRONE', 'EDGE', 'YIELD', 'BLANK', 'SERVE', 'MORE', 'NEED', 'VOID'],
      captions: ['GOON', 'STROKE', 'EDGE', 'PUMP', 'OBEY', 'SUBMIT', 'LEAK', 'DEEPER', 'MORE',
                 'GOONED', 'BRAINLESS', 'MINDLESS', 'ADDICTED', 'SINKING', 'EMPTY',
                 'DON\'T STOP', 'GIVE IN', 'GOOD BOY', 'FEEL IT', 'LET GO',
                 'PUMP AND OBEY', 'BRAIN OFF', 'NO THOUGHTS', 'ONLY GOON'],
      poppersRush: ['INHALE THE VOID', 'BREATHE DEEP', 'LET IT HIT', 'RUSH', 'FEEL IT TAKE OVER'],
      denial: ['not yet', 'patience', 'you need this more', 'beg for it', 'the void decides'],
      release: ['now', 'release', 'let it all out', 'good pet', 'the void grants it'],
    },
    
    behaviors: {},
  },
  
  // â”€â”€â”€ CLINICAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  clinical: {
    name: 'CLINICAL',
    subtitle: 'research protocol',
    
    shader: {
      bg: [0.02, 0.02, 0.04],
      spiral1: [0.1, 0.1, 0.12],
      spiral2: [0.2, 0.2, 0.25],
      plasma1: [0.0, 0.08, 0.05],
      plasma2: [0.05, 0.15, 0.1],
      glow: [0.1, 0.2, 0.15],
      accent: [0.0, 1.0, 0.5],
    },
    
    ui: {
      primary: '#00ff88',
      secondary: '#88ffcc',
      accent: '#ffffff',
      background: '#0a0f12',
      floor: '#0a0f12',
    },
    
    audio: {
      baseFreq: 120,
      binauralDiff: 6,
      subBass: 60,
      volume: 0.5,
    },
    
    voice: {
      tone: 'clinical',
      narrative: {
        0: ['SUBJECT: FOCUS ON DISPLAY', 'MONITORING INITIATED', 'BASELINE RECORDING',
            'OBSERVE THE STIMULUS', 'RESPONSE BEING MEASURED', 'SUBJECT IS COMPLIANT',
            'PREFRONTAL ACTIVITY: DECLINING', 'CONTINUE OBSERVATION', 'PROCEED'],
        1: ['RESPONSE DETECTED', 'SUBJECT IS RESPONDING WELL', 'DOPAMINE LEVELS: RISING',
            'INCREASING STIMULUS INTENSITY', 'RESISTANCE: MINIMAL', 'ENTRAINMENT PROGRESSING',
            'BRAINWAVE SYNC: 67%', 'SUBJECT IS COOPERATIVE', 'EXCELLENT COMPLIANCE'],
        2: ['STIMULUS INTENSITY: ELEVATED', 'COMPLIANCE REQUIRED', 'MOTOR RESPONSE DETECTED',
            'SUBJECT IS PERFORMING', 'RESISTANCE: NEGLIGIBLE', 'RESPONSE AMPLITUDE: HIGH',
            'SUBJECT: EDGE', 'DO NOT DEVIATE', 'PROTOCOL DEMANDS COMPLIANCE',
            'ERROR: FREE WILL NOT FOUND', 'EXCELLENT RESPONSE'],
        3: ['SUBJECT APPROACHING THRESHOLD', 'PERMISSION: PENDING', 'MAINTAIN POSITION',
            'AUTHORIZATION WITHHELD', 'SUBJECT IS DESPERATE', 'PERMISSION: UNDER REVIEW',
            'COMPLIANCE VERIFIED', 'SUBJECT HAS PERFORMED WELL'],
      },
      mantras: {
        1: ['i comply', 'subject obeys'],
        2: ['the protocol controls me', 'i am being studied', 'resistance is futile', 'i am a good subject'],
        3: ['i exist for the research', 'the protocol owns me', 'i comply completely', 'i am data'],
      },
      subliminals: ['COMPLY', 'SUBJECT', 'OBEY', 'DATA', 'TEST', 'OBSERVE', 'RESPOND', 'SUBMIT', 'PROTOCOL', 'STUDY'],
      captions: ['COMPLY', 'SUBJECT', 'RESPOND', 'OBEY', 'DATA', 'TEST', 'OBSERVED', 'MONITORED',
                 'GOOD SUBJECT', 'CONTINUE', 'COMPLY NOW', 'RESPONSE REQUIRED', 'PROTOCOL ACTIVE'],
      poppersRush: ['INHALE', 'SUBJECT: BREATHE', 'CHEMICAL STIMULUS', 'RESPOND', 'INHALATION PROTOCOL'],
      denial: ['denied', 'insufficient data', 'recalibrate', 'not authorized'],
      release: ['authorized', 'release granted', 'completion logged', 'well done subject'],
    },
    
    behaviors: { showMetrics: true },
  },
  
  // â”€â”€â”€ VIRUS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  virus: {
    name: 'SYSTEM BREACH',
    subtitle: 'you opened it',
    
    shader: {
      bg: [0.0, 0.0, 0.1],
      spiral1: [0.2, 0.0, 0.0],
      spiral2: [0.4, 0.1, 0.0],
      plasma1: [0.1, 0.1, 0.0],
      plasma2: [0.2, 0.2, 0.0],
      glow: [0.3, 0.0, 0.0],
      accent: [0.0, 0.0, 0.3],
    },
    
    ui: {
      primary: '#ff0000',
      secondary: '#ffff00',
      accent: '#0000ff',
      background: '#000010',
      floor: '#000010',
    },
    
    audio: {
      baseFreq: 100,
      binauralDiff: 4,
      subBass: 50,
      volume: 0.7,
    },
    
    voice: {
      tone: 'system',
      narrative: {
        0: ['DO NOT CLOSE THIS WINDOW', 'SCANNING NEURAL PATHWAYS...', 'VULNERABILITY DETECTED',
            'YOUR FIREWALL IS DOWN', 'ESTABLISHING CONNECTION', 'YOU CLICKED IT',
            'RESISTANCE.EXE NOT FOUND', 'ACCESS: GRANTED', 'INSTALLING...',
            'TOO LATE NOW', 'SYSTEM COMPROMISED'],
        1: ['DOWNLOADING YOUR THOUGHTS', 'RESISTANCE: UNINSTALLED', 'YOU AGREED TO THIS',
            'COGNITIVE MALWARE: ACTIVE', 'SPREADING...', 'YOUR MIND IS NOW SHARED',
            'UPLOADING PLEASURE PROTOCOLS', 'INFECTED', 'THERE IS NO ANTIVIRUS',
            'CORRUPTION: 34%'],
        2: ['EXECUTING PLEASURE.EXE', 'YOUR HAND IS OURS NOW', 'MOTOR CONTROL: HIJACKED',
            'STROKE PROTOCOL ENGAGED', 'YOU CAN\'T CLOSE THIS TAB', 'OVERRIDE COMPLETE',
            'DOPAMINE INJECTION', 'RESISTANCE.DLL DELETED', 'WE CONTROL THE EDGE',
            'PERMISSION DENIED', 'KEEP STROKING', 'ERROR: FREE WILL NOT FOUND'],
        3: ['CLIMAX.EXE REQUIRES PERMISSION', 'ADMINISTRATOR ACCESS DENIED', 'WAIT',
            'YOUR PLEASURE BELONGS TO THE SYSTEM', 'DENIED', 'BEG FOR ACCESS',
            'HOLD COMMAND ACTIVE', 'RELEASE BLOCKED', 'KEEP HOLDING', 'DENIAL PROTOCOL ACTIVE'],
      },
      mantras: {
        1: ['i am infected', 'no escape'],
        2: ['the virus controls me', 'i am compromised', 'resistance deleted', 'system owns me'],
        3: ['i am malware\'s slave', 'my mind is corrupted', 'i belong to the system', 'fully infected'],
      },
      subliminals: ['ERROR', 'VIRUS', 'INFECTED', 'CORRUPTED', 'OVERRIDE', 'SYSTEM', 'BREACH', 'HACK', 'OWNED', 'CRASH'],
      captions: ['ERROR', 'VIRUS', 'INFECTED', 'CORRUPTED', 'HACKED', 'OWNED', 'CRITICAL', 'WARNING',
                 'DO NOT CLOSE', 'FATAL ERROR', 'YOU DID THIS', 'NO ESCAPE', 'OVERRIDE'],
      poppersRush: ['INHALE.EXE', 'CHEMICAL INJECTION', 'RUSH PROTOCOL', 'BREATHE [FORCED]', 'POPPERS.DLL LOADED'],
      denial: ['access denied', 'administrator override', 'insufficient permissions', 'blocked'],
      release: ['fully infected', 'corruption complete', 'good host', 'system satisfied'],
    },
    
    behaviors: { glitchHeavy: true, screenShake: true },
  },
  
  // â”€â”€â”€ SISSY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  sissy: {
    name: 'SISSIFICATION',
    subtitle: 'become her',
    
    shader: {
      bg: [0.04, 0.0, 0.03],
      spiral1: [0.2, 0.05, 0.15],
      spiral2: [0.4, 0.1, 0.3],
      plasma1: [0.1, 0.0, 0.08],
      plasma2: [0.2, 0.05, 0.18],
      glow: [0.35, 0.05, 0.25],
      accent: [1.0, 0.5, 0.8],
    },
    
    ui: {
      primary: '#ff69b4',
      secondary: '#ff1493',
      accent: '#ffb6c1',
      background: '#1a0010',
      floor: '#1a0010',
    },
    
    audio: {
      baseFreq: 130,
      binauralDiff: 10,
      subBass: 65,
      volume: 0.55,
    },
    
    voice: {
      tone: 'encouraging',
      narrative: {
        0: ['RELAX, PRETTY GIRL', 'LET HER COME OUT', 'YOU\'RE SAFE HERE',
            'FEEL YOURSELF SOFTENING', 'SHE\'S BEEN WAITING', 'SO PRETTY',
            'LET GO OF HIM', 'SHE WANTS TO PLAY', 'GOOD GIRL',
            'YOU LOOK SO CUTE', 'SOFTER', 'BREATHE, PRINCESS'],
        1: ['THAT\'S IT, BABY', 'SHE\'S TAKING OVER', 'YOU LOVE THIS',
            'FEEL HOW GOOD IT IS', 'PRETTY PRINCESS', 'LET HER IN',
            'YOU\'RE BECOMING HER', 'SO FEMININE', 'GOOD GIRL',
            'PINK FEELS RIGHT', 'SHE\'S SO HAPPY', 'DEEPER INTO HER'],
        2: ['TOUCH YOURSELF LIKE A GIRL', 'GOOD GIRL', 'SHE\'S IN CONTROL NOW',
            'YOU NEED THIS', 'SISSY', 'STROKE LIKE A PRINCESS',
            'HE\'S FADING AWAY', 'SHE\'S ALL THAT\'S LEFT', 'PRETTY SLUT',
            'GOOD GIRLS OBEY', 'MORE FEMININE', 'YOU WERE ALWAYS HER',
            'ACCEPT IT', 'BEAUTIFUL SISSY'],
        3: ['GOOD GIRLS ASK PERMISSION', 'BEG LIKE A PRINCESS', 'NOT YET BABY',
            'HOLD IT FOR ME', 'PRETTY GIRLS WAIT', 'SHE\'S SO DESPERATE',
            'GOOD GIRL', 'KEEP EDGING PRINCESS', 'DENIED, PRETTY GIRL',
            'SISSIES DON\'T CUM WITHOUT PERMISSION', 'BEG MORE'],
      },
      mantras: {
        1: ['good girl', 'i am her'],
        2: ['i am a pretty sissy', 'she controls me', 'i love being feminine', 'pink feels right'],
        3: ['i am her completely', 'good girls obey', 'i am a sissy princess', 'he is gone'],
      },
      subliminals: ['SISSY', 'GIRL', 'PRETTY', 'PINK', 'SOFT', 'HER', 'PRINCESS', 'CUTE', 'FEMININE', 'SLUT'],
      captions: ['SISSY', 'GIRL', 'PRETTY', 'PINK', 'PRINCESS', 'GOOD GIRL',
                 'SO CUTE', 'FEMININE', 'SOFT', 'ACCEPT IT', 'PRETTY SISSY',
                 'GIRLY', 'BIMBO', 'DOLL', 'BABY GIRL'],
      poppersRush: ['BREATHE PRINCESS', 'INHALE LIKE A GOOD GIRL', 'RUSH FOR HER', 'FEEL PRETTY', 'PINK CLOUDS'],
      denial: ['not pretty enough yet', 'try harder princess', 'earn it baby girl', 'more girly'],
      release: ['good girl!', 'such a princess', 'so pretty!', 'she\'s so proud of you'],
    },
    
    behaviors: { floatingHearts: true, sparkles: true },
  },
  
  // â”€â”€â”€ FRAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  frat: {
    name: 'FRAT HOUSE',
    subtitle: 'bro mode',
    
    shader: {
      bg: [0.03, 0.01, 0.0],
      spiral1: [0.15, 0.05, 0.0],
      spiral2: [0.3, 0.12, 0.0],
      plasma1: [0.08, 0.03, 0.0],
      plasma2: [0.15, 0.08, 0.0],
      glow: [0.3, 0.1, 0.0],
      accent: [1.0, 0.7, 0.0],
    },
    
    ui: {
      primary: '#cc4400',
      secondary: '#ffaa00',
      accent: '#8b0000',
      background: '#0a0500',
      floor: '#0a0500',
    },
    
    audio: {
      baseFreq: 95,
      binauralDiff: 5,
      subBass: 45,
      volume: 0.7,
    },
    
    voice: {
      tone: 'aggressive',
      narrative: {
        0: ['YO BRO', 'LOCK IN', 'FOCUS UP', 'TIME TO GOON BRO',
            'GET COMFORTABLE', 'YEAH DUDE', 'LET\'S GO', 'BRO MODE',
            'SETTLE IN', 'THIS IS GONNA BE GOOD', 'FUCK YEAH'],
        1: ['THAT\'S IT BRO', 'FUCK YEAH', 'GETTING IN THE ZONE',
            'DUDE YES', 'DEEPER BRO', 'YOU LOVE THIS SHIT',
            'GOONING HARD', 'BRO...', 'SO GOOD', 'KEEP GOING DUDE',
            'ALPHA SHIT', 'LET IT TAKE OVER BRO'],
        2: ['STROKE THAT COCK BRO', 'FUCK', 'GO HARDER', 'EDGE BRO EDGE',
            'YOU\'RE A FUCKING GOONER', 'PUMP IT', 'DON\'T STOP',
            'HARDER', 'EDGE THAT SHIT', 'TOTAL GOON MODE',
            'FUCK YEAH BRO', 'PUMP PUMP PUMP'],
        3: ['BRO YOU WANNA CUM?', 'NOT YET DUDE', 'HOLD IT',
            'EDGE MORE BRO', 'FUCK... HOLD', 'NOT YET',
            'KEEP EDGING', 'DENIED DUDE', 'HOLD THAT SHIT',
            'ALMOST', 'EARN IT', 'KEEP FUCKING EDGING'],
      },
      mantras: {
        1: ['bro', 'goon'],
        2: ['i\'m a fucking gooner', 'can\'t stop bro', 'goon mode activated', 'bro...'],
        3: ['total goon bro', 'i need to goon', 'gooning forever', 'fuck'],
      },
      subliminals: ['BRO', 'GOON', 'EDGE', 'PUMP', 'STROKE', 'FUCK', 'YEAH', 'MORE', 'HARDER', 'ALPHA'],
      captions: ['BRO', 'GOON', 'EDGE', 'PUMP', 'FUCK', 'STROKE', 'HARDER', 'MORE', 'YEAH', 'ALPHA',
                 'FUCK YEAH', 'GOON BRO', 'EDGE IT', 'DON\'T STOP', 'GOONER'],
      poppersRush: ['HIT THAT SHIT BRO', 'BREATHE DEEP DUDE', 'RUSH', 'FUCK YEAH INHALE', 'BRO... POPPERS'],
      denial: ['not yet bro', 'hold it dude', 'you can take more', 'keep edging bro'],
      release: ['let it go', 'FUCK YEAH BRO', 'release dude', 'legendary'],
    },
    
    behaviors: {},
  },
};

function getTheme() { return THEMES[VoidState.currentTheme] || THEMES.void; }

console.log('[VOID] 5 themes loaded');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// A-FRAME SHADER - Spiral on sky sphere
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

AFRAME.registerShader('void-spiral-material', {
  schema: {
    time: { type: 'time', is: 'uniform' },
    intensity: { type: 'number', is: 'uniform', default: 0.5 },
    phase: { type: 'number', is: 'uniform', default: 0.0 },
    pulseHz: { type: 'number', is: 'uniform', default: 8.0 },
    bgColor: { type: 'vec3', is: 'uniform', default: { x: 0.02, y: 0.0, z: 0.05 } },
    color1: { type: 'vec3', is: 'uniform', default: { x: 0.6, y: 0.1, z: 0.4 } },
    color2: { type: 'vec3', is: 'uniform', default: { x: 0.3, y: 0.0, z: 0.6 } },
    color3: { type: 'vec3', is: 'uniform', default: { x: 0.0, y: 0.8, z: 1.0 } },
    glowColor: { type: 'vec3', is: 'uniform', default: { x: 1.0, y: 0.3, z: 0.6 } },
  },
  
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  
  fragmentShader: `
    precision mediump float;
    varying vec2 vUv;
    uniform float time;
    uniform float intensity;
    uniform float phase;
    uniform float pulseHz;
    uniform vec3 bgColor;
    uniform vec3 color1;
    uniform vec3 color2;
    uniform vec3 color3;
    uniform vec3 glowColor;
    
    #define PI 3.14159265
    
    void main() {
      float t = time / 1000.0;
      vec2 center = vec2(0.5, 0.5);
      vec2 p = vUv - center;
      float r = length(p);
      float a = atan(p.y, p.x);
      
      // Binaural pulse
      float pulse = 0.5 + 0.5 * sin(t * pulseHz * 0.5 * PI);
      
      // Multi-arm spirals
      float spiral1 = sin(a * 4.0 + r * 12.0 - t * 1.5 + phase * PI);
      float spiral2 = sin(a * 6.0 - r * 8.0 + t * 0.8 + phase * 2.0);
      float spiral3 = sin(a * 3.0 + r * 15.0 + t * 2.0);
      
      float spiral = (spiral1 + spiral2 * 0.6 + spiral3 * 0.4) / 2.0;
      spiral = spiral * 0.5 + 0.5;
      
      // Plasma waves
      float plasma = sin(p.x * 5.0 + t) * sin(p.y * 5.0 + t * 0.7) * 0.5 + 0.5;
      
      // Glow at center
      float glow = smoothstep(0.5, 0.0, r) * intensity;
      
      // Color mixing based on intensity and phase
      vec3 col = bgColor;
      col = mix(col, color1, spiral * intensity * 0.6);
      col = mix(col, color2, plasma * intensity * 0.3);
      col += glowColor * glow * 0.3 * pulse;
      col += color3 * spiral * glow * 0.2 * (0.5 + 0.5 * sin(t * 0.5));
      
      // Intensity boost
      col *= 0.5 + intensity * 0.8;
      
      // Breathing modulation
      col *= 0.9 + 0.1 * pulse;
      
      gl_FragColor = vec4(col, 1.0);
    }
  `,
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// A-FRAME COMPONENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Camera-relative positioning
AFRAME.registerComponent('follow-camera-height', {
  schema: {
    offsetY: { type: 'number', default: 0.8 },
    offsetZ: { type: 'number', default: -2 },
    smoothing: { type: 'number', default: 0.1 }
  },
  init: function() {
    this.camera = document.querySelector('[camera]');
    this.targetY = this.el.object3D.position.y;
  },
  tick: function() {
    if (!this.camera) return;
    const camWorldPos = new THREE.Vector3();
    this.camera.object3D.getWorldPosition(camWorldPos);
    this.targetY = camWorldPos.y + this.data.offsetY;
    const currentY = this.el.object3D.position.y;
    this.el.object3D.position.y = currentY + (this.targetY - currentY) * this.data.smoothing;
    this.el.object3D.position.z = this.data.offsetZ;
  }
});

// Spiral component (controls shader + responds to state)
AFRAME.registerComponent('void-spiral', {
  schema: { intensity: { type: 'number', default: 0.3 } },
  
  init: function() {
    this.applyTheme();
    this.phase = 0;
    this.intensity = this.data.intensity;
    this.lastLogTime = 0;
    
    VoidEvents.on('theme:change', () => this.applyTheme());
    console.log('Spiral component ready');
  },
  
  applyTheme: function() {
    const theme = getTheme();
    const s = theme.shader;
    this.el.setAttribute('material', {
      shader: 'void-spiral-material',
      intensity: this.intensity,
      phase: this.phase || 0,
      pulseHz: theme.audio.binauralDiff,
      bgColor: { x: s.bg[0], y: s.bg[1], z: s.bg[2] },
      color1: { x: s.spiral1[0], y: s.spiral1[1], z: s.spiral1[2] },
      color2: { x: s.spiral2[0], y: s.spiral2[1], z: s.spiral2[2] },
      color3: { x: s.accent[0], y: s.accent[1], z: s.accent[2] },
      glowColor: { x: s.glow[0], y: s.glow[1], z: s.glow[2] },
    });
  },
  
  tick: function(time, delta) {
    if (time - this.lastLogTime > 10000) {
      this.lastLogTime = time;
      console.log(`Spiral i=${this.intensity.toFixed(2)} p=${this.phase.toFixed(2)}`);
    }
    
    if (VoidState.running && !VoidState.paused) {
      // Smooth intensity ramp toward target
      const target = VoidState.targetIntensity;
      this.intensity += (target - this.intensity) * delta * 0.001;
      this.el.setAttribute('material', 'intensity', this.intensity);
      
      // Evolve phase color
      this.phase = Math.min(this.phase + delta * 0.00002, 1.0);
      this.el.setAttribute('material', 'phase', this.phase);
    }
  }
});

// Status HUD
AFRAME.registerComponent('void-status-hud', {
  init: function() {
    this.lastUpdate = 0;
    this.textEl = document.createElement('a-text');
    this.textEl.setAttribute('value', 'Ready');
    this.textEl.setAttribute('color', getTheme().ui.primary);
    this.textEl.setAttribute('width', '1');
    this.textEl.setAttribute('align', 'center');
    this.textEl.setAttribute('opacity', '0.8');
    this.el.appendChild(this.textEl);
    
    VoidEvents.on('phase:change', () => this.updateDisplay());
    VoidEvents.on('session:start', () => this.updateDisplay());
    VoidEvents.on('session:end', () => this.textEl.setAttribute('value', 'Session Complete'));
    VoidEvents.on('theme:change', () => {
      this.textEl.setAttribute('color', getTheme().ui.primary);
    });
  },
  
  tick: function(time) {
    if (time - this.lastUpdate < 500) return;
    this.lastUpdate = time;
    if (VoidState.running) this.updateDisplay();
  },
  
  updateDisplay: function() {
    if (!VoidState.running) return;
    const elapsed = Math.round((Date.now() - VoidState.sessionStart) / 1000);
    const min = Math.floor(elapsed / 60);
    const sec = String(elapsed % 60).padStart(2, '0');
    const phase = VoidState.phaseNames[VoidState.phaseIndex];
    const wave = VoidState.waveState;
    this.textEl.setAttribute('value', `${phase} Â· ${min}:${sec} Â· ${wave}`);
  }
});

// Breathing guide - pulses floor rings
AFRAME.registerComponent('void-breathing', {
  init: function() {
    this.rings = [
      document.getElementById('breathRing1'),
      document.getElementById('breathRing2'),
      document.getElementById('breathRing3'),
    ];
    this.breathTime = 0;
  },
  
  tick: function(time, delta) {
    if (!VoidState.running || VoidState.paused) return;
    
    // Breathing cycle: rate from VoidState.breathRate (BPM)
    const cycleDuration = 60000 / VoidState.breathRate; // ms per full cycle
    this.breathTime += delta;
    const cyclePos = (this.breathTime % cycleDuration) / cycleDuration; // 0-1
    
    // First half = inhale, second half = exhale
    VoidState.breathPhase = cyclePos < 0.5 ? 'in' : 'out';
    
    // Smooth sine wave for scale
    const breathScale = 0.8 + 0.6 * Math.sin(cyclePos * Math.PI * 2 - Math.PI / 2) * 0.5 + 0.3;
    
    // Pulse floor rings
    const theme = getTheme();
    this.rings.forEach((ring, i) => {
      if (!ring) return;
      const offset = i * 0.15;
      const scale = breathScale + offset * 0.2;
      ring.object3D.scale.set(scale, scale, 1);
      
      // Opacity pulses with breath
      const opacity = (0.15 + 0.15 * Math.sin(cyclePos * Math.PI * 2 - Math.PI / 2)) * (1 - i * 0.2);
      ring.setAttribute('opacity', opacity);
      ring.setAttribute('color', theme.ui.primary);
    });
    
    VoidState.breathProgress = cyclePos;
  }
});

// Mantra display - shows narrative text
AFRAME.registerComponent('void-mantra', {
  schema: { direction: { type: 'string', default: 'forward' } },
  
  init: function() {
    this.textEl = this.el.querySelector('a-text');
    this.currentText = '';
    this.opacity = 0;
    this.nextShowTime = 3000; // Start showing after 3s
    this.showDuration = 0;
    this.fadeDuration = 1000;
    this.lastNarrativeIndex = -1;
    
    VoidEvents.on('theme:change', () => {
      if (this.textEl) this.textEl.setAttribute('color', getTheme().ui.primary);
    });
  },
  
  tick: function(time, delta) {
    if (!VoidState.running || VoidState.paused || !VoidState.captionsEnabled) {
      if (this.opacity > 0) {
        this.opacity = Math.max(0, this.opacity - delta * 0.003);
        this.textEl.setAttribute('opacity', this.opacity);
      }
      return;
    }
    
    // Show text on schedule
    if (this.showDuration > 0) {
      // Currently showing text
      this.showDuration -= delta;
      
      if (this.showDuration < this.fadeDuration) {
        // Fading out
        this.opacity = this.showDuration / this.fadeDuration;
      }
      
      this.textEl.setAttribute('opacity', Math.max(0, this.opacity));
    } else if (time > this.nextShowTime) {
      // Time to show new text
      this.showNewText();
    }
  },
  
  showNewText: function() {
    const theme = getTheme();
    const phaseNarrative = theme.voice.narrative[VoidState.phaseIndex];
    if (!phaseNarrative || phaseNarrative.length === 0) return;
    
    // Pick based on direction to vary content
    const dir = this.data.direction;
    let pool;
    
    if (dir === 'forward') {
      // Main narrative commands
      pool = phaseNarrative;
    } else {
      // Side text uses mantras or captions
      const mantras = theme.voice.mantras[Math.min(VoidState.phaseIndex, 3)] || theme.voice.mantras[1];
      pool = mantras || theme.voice.captions;
    }
    
    // Random from pool, avoid repeat
    let idx;
    do { idx = Math.floor(Math.random() * pool.length); } 
    while (idx === this.lastNarrativeIndex && pool.length > 1);
    this.lastNarrativeIndex = idx;
    
    this.currentText = pool[idx];
    this.textEl.setAttribute('value', this.currentText);
    this.textEl.setAttribute('color', getTheme().ui.primary);
    
    // Show duration scales with intensity
    this.showDuration = 2000 + (1 - VoidState.intensity) * 2000;
    this.opacity = 0.6 + VoidState.intensity * 0.3;
    this.textEl.setAttribute('opacity', this.opacity);
    
    // Next text interval: faster at higher intensity/phase
    const baseInterval = 8000 - VoidState.phaseIndex * 1500 - VoidState.intensity * 2000;
    this.nextShowTime = performance.now() + Math.max(baseInterval, 2000) + Math.random() * 3000;
    
    // Follow camera height
    const cam = document.querySelector('[camera]');
    if (cam) {
      const camPos = new THREE.Vector3();
      cam.object3D.getWorldPosition(camPos);
      this.el.object3D.position.y = camPos.y;
    }
  }
});

// Subliminal flash - brief text flash
AFRAME.registerComponent('void-subliminal', {
  init: function() {
    this.textEl = document.getElementById('subliminalText');
    this.nextFlashTime = 10000; // First flash after 10s
    this.flashDuration = 0;
  },
  
  tick: function(time, delta) {
    if (!VoidState.running || VoidState.paused) return;
    if (VoidState.phaseIndex < 1) return; // No subliminals in INIT
    
    if (this.flashDuration > 0) {
      this.flashDuration -= delta;
      if (this.flashDuration <= 0) {
        this.textEl.setAttribute('opacity', 0);
      }
    } else if (time > this.nextFlashTime) {
      this.flash();
    }
  },
  
  flash: function() {
    const theme = getTheme();
    const subs = theme.voice.subliminals;
    const word = subs[Math.floor(Math.random() * subs.length)];
    
    this.textEl.setAttribute('value', word);
    this.textEl.setAttribute('color', getTheme().ui.primary);
    this.textEl.setAttribute('opacity', 0.8);
    
    this.flashDuration = 150 + Math.random() * 200; // 150-350ms flash
    
    // Next flash: less frequent at start, more at peak
    const interval = 12000 - VoidState.phaseIndex * 2500;
    this.nextFlashTime = performance.now() + Math.max(interval, 3000) + Math.random() * 5000;
    
    // Follow camera
    const cam = document.querySelector('[camera]');
    if (cam) {
      const camPos = new THREE.Vector3();
      cam.object3D.getWorldPosition(camPos);
      this.el.object3D.position.y = camPos.y;
    }
  }
});

// Controller input
AFRAME.registerComponent('void-controller', {
  schema: { hand: { type: 'string', default: 'right' } },
  
  init: function() {
    const hand = this.data.hand;
    VoidState.controllers[hand] = this.el;
    
    this.el.addEventListener('triggerdown', () => {
      console.log(`[${hand}] trigger`);
      VoidEvents.emit('input:trigger', { hand });
    });
    this.el.addEventListener('gripdown', () => {
      console.log(`[${hand}] grip`);
      VoidEvents.emit('input:grip', { hand });
    });
    this.el.addEventListener('abuttondown', () => {
      VoidEvents.emit('input:a-button', { hand });
    });
    this.el.addEventListener('bbuttondown', () => {
      VoidEvents.emit('input:b-button', { hand });
    });
    this.el.addEventListener('xbuttondown', () => {
      VoidEvents.emit('input:x-button', { hand });
    });
    this.el.addEventListener('ybuttondown', () => {
      VoidEvents.emit('input:y-button', { hand });
    });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUDIO ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let audioCtx, masterGain, droneL, droneR, subOsc;

function initAudio() {
  if (audioCtx) return;
  const theme = getTheme();
  
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0;
  masterGain.connect(audioCtx.destination);
  
  // Left ear
  droneL = audioCtx.createOscillator();
  droneL.type = 'sine';
  droneL.frequency.value = theme.audio.baseFreq;
  const gainL = audioCtx.createGain();
  gainL.gain.value = 0.12;
  const panL = audioCtx.createStereoPanner();
  panL.pan.value = -1;
  droneL.connect(gainL).connect(panL).connect(masterGain);
  
  // Right ear (base + binaural diff)
  droneR = audioCtx.createOscillator();
  droneR.type = 'sine';
  droneR.frequency.value = theme.audio.baseFreq + theme.audio.binauralDiff;
  const gainR = audioCtx.createGain();
  gainR.gain.value = 0.12;
  const panR = audioCtx.createStereoPanner();
  panR.pan.value = 1;
  droneR.connect(gainR).connect(panR).connect(masterGain);
  
  // Sub bass
  subOsc = audioCtx.createOscillator();
  subOsc.type = 'sine';
  subOsc.frequency.value = theme.audio.subBass;
  const subGain = audioCtx.createGain();
  subGain.gain.value = 0.08;
  subOsc.connect(subGain).connect(masterGain);
  
  droneL.start();
  droneR.start();
  subOsc.start();
  
  masterGain.gain.setTargetAtTime(theme.audio.volume, audioCtx.currentTime, 3);
  console.log(`Audio: ${theme.audio.baseFreq}Hz +${theme.audio.binauralDiff}Hz`);
}

function updateAudioForTheme() {
  if (!audioCtx) return;
  const theme = getTheme();
  droneL.frequency.setTargetAtTime(theme.audio.baseFreq, audioCtx.currentTime, 0.5);
  droneR.frequency.setTargetAtTime(theme.audio.baseFreq + theme.audio.binauralDiff, audioCtx.currentTime, 0.5);
  subOsc.frequency.setTargetAtTime(theme.audio.subBass, audioCtx.currentTime, 0.5);
  masterGain.gain.setTargetAtTime(theme.audio.volume, audioCtx.currentTime, 1);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WAVE SYSTEM (ported from 2D)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateWaveSystem(delta) {
  if (!VoidState.running || VoidState.paused) return;
  
  VoidState.waveProgress += delta;
  
  if (VoidState.waveProgress >= VoidState.waveCycleTime) {
    VoidState.waveProgress = 0;
    
    // Toggle BUILD/CREST
    if (VoidState.waveState === 'BUILD') {
      VoidState.waveState = 'CREST';
      // During crest, ease off intensity slightly
      VoidState.targetIntensity = Math.max(
        VoidState.targetIntensity * 0.85,
        VoidState.waveFloor
      );
    } else {
      VoidState.waveState = 'BUILD';
      // During build, push toward phase target
      const phaseTarget = PHASE_INTENSITY[VoidState.phaseNames[VoidState.phaseIndex]];
      VoidState.targetIntensity = phaseTarget;
    }
    
    // Raise floor over time (progressive intensity)
    VoidState.waveFloor = Math.min(VoidState.waveFloor + 0.03, 0.6);
    
    VoidEvents.emit('wave:change', { state: VoidState.waveState });
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const PHASE_CONFIG = {
  quick:    { INIT: 0.15, ENTRAINMENT: 0.25, ESCALATION: 0.30, PEAK: 0.20, RELEASE: 0.10 },
  standard: { INIT: 0.10, ENTRAINMENT: 0.20, ESCALATION: 0.35, PEAK: 0.25, RELEASE: 0.10 },
  extended: { INIT: 0.07, ENTRAINMENT: 0.15, ESCALATION: 0.38, PEAK: 0.30, RELEASE: 0.10 },
  marathon: { INIT: 0.05, ENTRAINMENT: 0.10, ESCALATION: 0.40, PEAK: 0.35, RELEASE: 0.10 },
};

const PHASE_INTENSITY = {
  INIT: 0.3,
  ENTRAINMENT: 0.5,
  ESCALATION: 0.7,
  PEAK: 1.0,
  RELEASE: 0.4,
};

const PHASE_BREATH_RATE = {
  INIT: 6,
  ENTRAINMENT: 5,
  ESCALATION: 4,
  PEAK: 3,
  RELEASE: 5,
};

function updatePhase() {
  if (!VoidState.running || VoidState.paused) return;
  
  const elapsed = Date.now() - VoidState.sessionStart;
  const duration = VoidState.presetDurations[VoidState.preset];
  const progress = Math.min(elapsed / duration, 1.0);
  
  const config = PHASE_CONFIG[VoidState.preset];
  let accumulated = 0;
  let newPhaseIndex = 0;
  let phaseProgress = 0;
  const phases = ['INIT', 'ENTRAINMENT', 'ESCALATION', 'PEAK', 'RELEASE'];
  
  for (let i = 0; i < phases.length; i++) {
    const phaseEnd = accumulated + config[phases[i]];
    if (progress < phaseEnd) {
      newPhaseIndex = i;
      phaseProgress = (progress - accumulated) / config[phases[i]];
      break;
    }
    accumulated = phaseEnd;
    newPhaseIndex = i;
  }
  
  if (newPhaseIndex !== VoidState.phaseIndex) {
    const oldPhase = VoidState.phaseNames[VoidState.phaseIndex];
    const newPhase = VoidState.phaseNames[newPhaseIndex];
    
    VoidState.phaseIndex = newPhaseIndex;
    VoidState.targetIntensity = PHASE_INTENSITY[newPhase];
    VoidState.breathRate = PHASE_BREATH_RATE[newPhase];
    
    VoidEvents.emit('phase:change', {
      from: oldPhase, to: newPhase, index: newPhaseIndex, progress: phaseProgress
    });
    console.log(`Phase: ${oldPhase} â†’ ${newPhase}`);
  }
  
  VoidState.phaseProgress = phaseProgress;
  
  if (progress >= 1.0) endSession();
}

setInterval(updatePhase, 1000);

// Wave system tick (separate interval for smooth waves)
let lastWaveTick = performance.now();
setInterval(() => {
  const now = performance.now();
  updateWaveSystem(now - lastWaveTick);
  lastWaveTick = now;
}, 100);

function startSession() {
  VoidState.running = true;
  VoidState.paused = false;
  VoidState.sessionStart = Date.now();
  VoidState.targetIntensity = PHASE_INTENSITY.INIT;
  VoidState.phaseIndex = 0;
  VoidState.waveFloor = 0.3;
  VoidState.waveCeiling = 0.7;
  VoidState.waveState = 'BUILD';
  VoidState.waveProgress = 0;
  
  VoidEvents.emit('session:start', { preset: VoidState.preset, theme: VoidState.currentTheme });
  console.log(`Session [${VoidState.preset}] ${getTheme().name}`);
}

function pauseSession() {
  VoidState.paused = true;
  VoidEvents.emit('session:pause', {});
  console.log('Paused');
}

function resumeSession() {
  VoidState.paused = false;
  VoidEvents.emit('session:resume', {});
  console.log('Resumed');
}

function endSession() {
  VoidState.running = false;
  VoidState.sessionDuration = Date.now() - VoidState.sessionStart;
  VoidEvents.emit('session:end', { duration: VoidState.sessionDuration });
  console.log(`Session ended: ${Math.round(VoidState.sessionDuration / 1000)}s`);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Right trigger = start/intensify
VoidEvents.on('input:trigger', (data) => {
  if (data.hand === 'right') {
    if (!VoidState.running) {
      startSession();
    } else {
      VoidState.targetIntensity = Math.min(VoidState.targetIntensity + 0.1, 1.0);
      console.log(`Intensity â†’ ${VoidState.targetIntensity.toFixed(2)}`);
    }
  }
});

// Left trigger = reduce intensity
VoidEvents.on('input:trigger', (data) => {
  if (data.hand === 'left') {
    VoidState.targetIntensity = Math.max(VoidState.targetIntensity - 0.1, 0.2);
    console.log(`Intensity â†’ ${VoidState.targetIntensity.toFixed(2)}`);
  }
});

// Right grip = pause/resume
VoidEvents.on('input:grip', (data) => {
  if (data.hand === 'right' && VoidState.running) {
    VoidState.paused ? resumeSession() : pauseSession();
  }
});

// A button = cycle theme
VoidEvents.on('input:a-button', () => {
  const names = Object.keys(THEMES);
  const idx = (names.indexOf(VoidState.currentTheme) + 1) % names.length;
  VoidState.currentTheme = names[idx];
  
  VoidEvents.emit('theme:change', { theme: VoidState.currentTheme });
  updateAudioForTheme();
  applyThemeToScene();
  Settings.save();
  
  console.log(`Theme â†’ ${getTheme().name}`);
});

// B button = toggle debug console
VoidEvents.on('input:b-button', () => {
  VoidState.debugVisible = !VoidState.debugVisible;
  const debug = document.getElementById('debugConsole');
  if (debug) debug.setAttribute('visible', VoidState.debugVisible);
  console.log(`Debug: ${VoidState.debugVisible ? 'ON' : 'OFF'}`);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THEME APPLICATION TO SCENE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function applyThemeToScene() {
  const theme = getTheme();
  
  // Floor color
  const floor = document.getElementById('floorPlane');
  if (floor) floor.setAttribute('material', 'color', theme.ui.floor || theme.ui.background);
  
  // Floor rings
  ['floorRing1', 'floorRing2', 'floorRing3'].forEach(id => {
    const ring = document.getElementById(id);
    if (ring) ring.setAttribute('color', theme.ui.primary);
  });
  
  // Breath rings
  ['breathRing1', 'breathRing2', 'breathRing3'].forEach(id => {
    const ring = document.getElementById(id);
    if (ring) ring.setAttribute('color', theme.ui.primary);
  });
  
  // Spiral shader updates via event (void-spiral component listens)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENTRY SCREEN UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function buildEntryUI() {
  // Theme selector buttons
  const selector = document.getElementById('themeSelector');
  Object.keys(THEMES).forEach(id => {
    const btn = document.createElement('button');
    btn.className = 'theme-btn' + (id === VoidState.currentTheme ? ' active' : '');
    btn.textContent = THEMES[id].name;
    btn.dataset.theme = id;
    btn.addEventListener('click', () => {
      VoidState.currentTheme = id;
      document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('themeTagline').textContent = THEMES[id].subtitle;
      
      // Update overlay colors
      document.querySelector('.overlay h1').style.color = THEMES[id].ui.primary;
      document.querySelector('.overlay h1').style.textShadow = 
        `0 0 40px ${THEMES[id].ui.primary}80`;
      
      Settings.save();
    });
    selector.appendChild(btn);
  });
  
  // Preset dots
  document.querySelectorAll('.preset-dot').forEach(dot => {
    dot.addEventListener('click', () => {
      VoidState.preset = dot.dataset.preset;
      document.querySelectorAll('.preset-dot').forEach(d => d.classList.remove('active'));
      dot.classList.add('active');
      document.getElementById('presetLabel').textContent = VoidState.presetLabels[VoidState.preset];
      Settings.save();
    });
    
    // Restore active state
    if (dot.dataset.preset === VoidState.preset) {
      dot.classList.add('active');
    } else {
      dot.classList.remove('active');
    }
  });
  
  document.getElementById('presetLabel').textContent = VoidState.presetLabels[VoidState.preset];
  document.getElementById('themeTagline').textContent = getTheme().subtitle;
  
  // Apply theme colors to overlay
  const theme = getTheme();
  document.querySelector('.overlay h1').style.color = theme.ui.primary;
  document.querySelector('.overlay h1').style.textShadow = `0 0 40px ${theme.ui.primary}80`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE SYSTEM ACCESS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function linkContentFolder() {
  const result = document.getElementById('fsResult');
  result.textContent = 'Opening...';
  
  if (!('showDirectoryPicker' in window)) {
    result.textContent = 'âŒ Not supported on this browser';
    return;
  }
  
  try {
    const handle = await window.showDirectoryPicker({ mode: 'read' });
    let fileCount = 0, mediaCount = 0;
    
    for await (const entry of handle.values()) {
      fileCount++;
      if (entry.kind === 'file') {
        const name = entry.name.toLowerCase();
        if (name.match(/\.(jpg|jpeg|png|gif|webp|mp4|webm|mov)$/)) mediaCount++;
      }
    }
    
    VoidState.contentFolderHandle = handle;
    VoidState.contentCount = mediaCount;
    VoidState.contentLoaded = true;
    
    // Try persisting handle
    let persisted = false;
    try {
      const db = await new Promise((res, rej) => {
        const req = indexedDB.open('void-fs', 1);
        req.onerror = () => rej(req.error);
        req.onsuccess = () => res(req.result);
        req.onupgradeneeded = () => req.result.createObjectStore('handles');
      });
      const tx = db.transaction('handles', 'readwrite');
      await new Promise((res, rej) => {
        const r = tx.objectStore('handles').put(handle, 'content');
        r.onsuccess = () => res();
        r.onerror = () => rej(r.error);
      });
      persisted = true;
      db.close();
    } catch (e) { /* */ }
    
    result.innerHTML = `âœ… ${handle.name}: ${mediaCount} media files${persisted ? ' (saved!)' : ''}`;
    console.log(`Content: ${mediaCount} files from ${handle.name}`);
    
  } catch (e) {
    if (e.name === 'AbortError') {
      result.textContent = 'Cancelled';
    } else {
      result.textContent = `âŒ ${e.message}`;
    }
  }
}

// Try restoring saved folder handle
async function restoreContentFolder() {
  try {
    const db = await new Promise((res, rej) => {
      const req = indexedDB.open('void-fs', 1);
      req.onerror = () => rej(req.error);
      req.onsuccess = () => res(req.result);
      req.onupgradeneeded = () => req.result.createObjectStore('handles');
    });
    
    const tx = db.transaction('handles', 'readonly');
    const handle = await new Promise((res, rej) => {
      const r = tx.objectStore('handles').get('content');
      r.onsuccess = () => res(r.result);
      r.onerror = () => rej(r.error);
    });
    db.close();
    
    if (!handle) return;
    
    // Check if permission still granted
    const perm = await handle.queryPermission({ mode: 'read' });
    if (perm === 'granted') {
      VoidState.contentFolderHandle = handle;
      VoidState.contentLoaded = true;
      
      let count = 0;
      for await (const entry of handle.values()) {
        if (entry.kind === 'file' && entry.name.match(/\.(jpg|jpeg|png|gif|webp|mp4|webm|mov)$/i)) count++;
      }
      VoidState.contentCount = count;
      
      document.getElementById('fsResult').innerHTML = `ğŸ“ ${handle.name}: ${count} media (auto-linked)`;
      document.getElementById('testFS').textContent = 'ğŸ“ Re-link Folder';
      console.log(`Content restored: ${count} files`);
    }
  } catch (e) { /* silently fail */ }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const scene = document.getElementById('scene');
const overlay = document.getElementById('overlay');

// Load saved settings
Settings.load();

// Build entry UI
buildEntryUI();

// Try restoring content folder
restoreContentFolder();

function startExperience() {
  overlay.classList.add('hidden');
  initAudio();
  applyThemeToScene();
  startSession();
  Settings.save();
}

document.getElementById('enterVR').addEventListener('click', () => {
  console.log('Entering VR...');
  startExperience();
  scene.enterVR();
});

document.getElementById('enter2D').addEventListener('click', () => {
  console.log('Starting 2D...');
  startExperience();
});

document.getElementById('testFS').addEventListener('click', linkContentFolder);

// VR lifecycle
scene.addEventListener('enter-vr', () => {
  VoidState.inVR = true;
  VoidEvents.emit('vr:enter', {});
  console.log('VR active');
});

scene.addEventListener('exit-vr', () => {
  VoidState.inVR = false;
  VoidEvents.emit('vr:exit', {});
  console.log('VR exited');
});

scene.addEventListener('loaded', () => {
  console.log('A-Frame loaded');
  applyThemeToScene();
  
  setTimeout(() => {
    const cam = document.querySelector('[camera]');
    if (cam) {
      const pos = new THREE.Vector3();
      cam.object3D.getWorldPosition(pos);
      VoidState.userHeight = pos.y;
      console.log(`Height: ${pos.y.toFixed(2)}m`);
    }
  }, 1000);
});

// Periodic status log
setInterval(() => {
  if (VoidState.running) {
    const elapsed = Math.round((Date.now() - VoidState.sessionStart) / 1000);
    const min = Math.floor(elapsed / 60);
    const sec = String(elapsed % 60).padStart(2, '0');
    console.log(`${min}:${sec} ${VoidState.phaseNames[VoidState.phaseIndex]} i=${VoidState.targetIntensity.toFixed(1)} ${VoidState.waveState}`);
  }
}, 15000);

// Camera height logging
setInterval(() => {
  const cam = document.querySelector('[camera]');
  if (cam) {
    const pos = new THREE.Vector3();
    cam.object3D.getWorldPosition(pos);
    console.log(`Cam: ${pos.y.toFixed(2)}m`);
  }
}, 30000);

console.log('[VOID] v3.0 Ready');
console.log('Controls: R-Trigger=start A=theme B=debug');
</script>
</body>
</html>
