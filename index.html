<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>VOID</title>

<!-- PWA: makes it open like a real app from the home screen -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="SPIRAL">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#030304">

<!-- Home screen icon (inline PNG) -->
<link rel="apple-touch-icon" sizes="180x180" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAYAAAA9zQYyAAAYiElEQVR4nO2dva/sxnnGn5UU38iWJeUDjoKkWAQuLmR3hsvbKAFSsLpH7gKoSBUgZQo3LFlE/4QLI0ACJLo3zQJJ4+YA+Qti4RYpWARJDESxZMuWLV1rUxzO3tnZ93M4wyV5+AAHS868M8Nd/vjw5XAPd/fyy68csWnTSvTStTdg06aS2oDetCptQG9alTagN61KG9CbVqUN6E2r0gb0plVpA3rTqrQBvWlVeuXaG7AWPX/7+7uxfbzy4fvbXduR2m23vu0qAW2uNtht2oAW5AS4BOzmfbEBTmsDOpIB4Ks5NBTYN8DvdO+BViCerUNLsfcZ7nsJtADxYh2aq79vcN8roBmQSzn01JL220XdfQH7XgDtBDkX4qlTDku7ewf2qoEmQC4B8TVcu0RufVa+VrBXCbQRZCuYpeMkWffFmLhVg70qoAuBnFtfE+isC0KlfpVgrwLoAiB76uaQcrguCJW6VYG9eKATmEuAnAvwNVMOFVRP/JKhXizQBlf2pgbagWGpqyUrnN6URTwwlgj2IoFWXNkDsgXiJTg0Ve5xbRbspUG9KKAVV84BeQl3DHMvCI9CvfuAWArYiwE6w5W9IM8tzeCUmxtbwV60Wy8CaAFmq8N6Qb7G3cKSdwk9YLvceu5QzxrojBTDCnKtfLkG0CXz6njdO1OyiBRktkCPTDE8IFsgvOZctGcOWoqxgL34FGSWQDtTjFxX9lz4TTHTkePE3gvG4m49N6hnB/QImEuAPMe56LFz0FRdCbeeJdSzArowzDkgX3MuulSunAv2KqCeDdAOmKn1nPnpuG7O03glp+modhTkVkc/W54D1LMAOhPmMa6cA3LOxaNHuRd7XLkG9li3niXUVwe6EsxekHMgnsKlve5MlXvAXjzUVwV6BMy589NjpvHmcLcwx6HTddd8My5TkFlDfTWgC8HsAdQ7/ceVSZryTqH3DmG87JpvxoKgvgrQFWAe48qlbrZY23GyAprTroRbLwLqyYG+Iswlb7RY4kvIcsPDE5/j1ouC+ppPH60JsyfH9oDshd4jaqfvkvqdEAuinlpP66j+0jhLf1K7yTSpQ0fuXAPmkq7smTGpKe/MhNQ2x62LOfVULj0Z0EyqMRXMXpDHQJwDeok56DHzzVI/Y6GeNPWYBOgJYLamGDkgS4DWdGnvHPTY+eZ4fbFQT51DW0/xuTB7cue4rOQ0XimHTvtJc1WujOvTkxdTfefk1FT7qqru0M68uRTMlhTDcqaQygBgt7vt3gXwDMDD4TVHD4fXZ8dH7Y+HZWsKQZWNmW+Ol3Nir5pPVwXamWpwr1wbC8xjQCYh3t123xsWL+AdYHQ79O62ezspOh0cQ59jL/y8U3PxsudiUoO6euoxFdDevHlKmFWQOYiPj9oPiTFGiwA8jMfBnTODwcVRy9b+zfn04oA2pBqWvLk0zK4cewD5BLHRgYvPckSAP8SLtMQDaFivAbX1InGS1KMK0BmpRk2Y3a5MgMw58aSzHEawc9y6FtSTpx61gS6VN3vjuHZq/O62+1ZYYUCe3KHT+gywS0DNwavFTZp6FAd6RKphzZtrwDwG5BoubboINIBdA+qx+XTV1GMKoGulGrkXjmfrcXrhAFmCuLRDqxeB8UWkAnW67p3F0NpkpR6zBdrhzpaUI6yXhJnMlZmLPXX2QykfI5NDp+sB7IwUpAbUrlSlFNS1f7zemxJwbbm47AvH3W33bdAwU31w40jbbv3T2lPl5Ho4w+xuu3eH9+dN+6h6rkzbb1J8tYvpYkAz7kyJ25FSmTU14dbJfHkAwLujJbhZSHe33V9S5Yb2VrABnN7TMwAPh/dpOlsJ65bPXiqz8FDsd9RrOrTliLSmGt5+yLF3t933Epi58azO6HFoqVxqz21Dup2n+ghqGKHWzMgKq6efKi5dBOgC7pzGUOvah6HCjCHFIGDmts8CVVxueX/ett5tOkEdpSAeqNOxtbhi+7yES9dy6DHubK2L18U44eJPWra4oxVwj0NzdSaQ02Uj1FyfUlxOHbudpTQa6Ex31k61VDnVjtupY2GW+tfgLunQVLkJ5HjZALXl4E3jpHiq3SQuXcOhPUegVO850rm4HWSYrXBw61M7NLfOAWmB2tI/VW7Zd5b6oi49CmjH0eR1Z8sHHpeRsEZ3/7yuZHHpdDtqOnTudp7FDFCnsx/aZ0ONRcWXcGkA41x61I2VzLuCUqwU49p5wzwsNZuh9UttP1WXlj2NKw777h0inlTTtz8C8Dgpzvk2nbR8BBBuvoRb5f/OxUXLnu9uWG62VL17WPNfsLz5k9UdpIPmbuFF3pwLsxXsE8QpwE3fvgmj4rYR3PE4YefukmWpLl3eATgeH7Uf7m47aHHR2Fy/aX26PZTiGKqv0cp2aOdt7jHubIk9LTMXgZaUQ1uO158CFyC+KbSTdPb5H/bdx1Gfb3Bx0J0zXr4oY26Te7+QVNKli9wOLwm0JT3gYj3gSTG73W33rQown4EM3ME8AmJO8b54Eg4YAeyaUFtSD8sBoEHPxuYAPcV3OaRUQmqntaFSDeoiMI3nykwwH/bdOxHMO1weZHE77U9qcxMOmMO++yRzm9O+z5RcJKZxrs/eIE8Kmq2sHNox90xJclytnfohO/JmKxgB5D8FTqmF9YDRlLZJc1dEUH88rL8BPV+Ol7WyZ0RbbjstjpnG5uTKOwDH529/f+d16VIOrQHj6cPSTnJnapusZRrMb+CyjxoOfbF9Td++2fTtjw777pPBsUe5cygb4dI5sVq70c5d+0EzFzluRtuwzLZlZjW4bdDKwvIJ5iiHdYFz2HevEjFnjtP07a+Ics7lbgao30nKuWWtLCjHpT3Om46d49omXfvpo2NzsaD0GRlSvxaXDjD/GdOGBPuw774aBzV9+xkx1kmHfffgsO8eRPG/HhalabozqIeDzTKtRpXt8GIq72Z32yGam86BL24Tv4/J5J7lKHgzRaqXTutnr8Y5Z49Ln2Bu+vZ1ps3Z+mHffS0UNH37S+TpOMB9bPr2c+jTdE+Gi9M3mHqt7OzVOOMxZgrPOn13EevJo0vPckgwj+lT6svjzmlMWiY5M3kwBpibvv1lArM3h941fft507efH/bdVwa4pfGDU3+ivCdOZ5+T8tAcar/mqgYjJ9WetoulubO7r/BEI8fOsNTdABdzvxdgHfbda4d991oCMgertG1p/K7p2y8C2NTY0TIHtfW9Xgbx3/OwioO/GLSSpgRak5QWcBrjzmnMUwA3h333syHVoLbhBDMANH37i6icg8jizlQfuwHq36K2IVIKdRpXyqWpdtZxJpMLaEP+XEPimNHTOt1to7KQavwc/NnjBHPTt79IYE77s7g0m3rEy03ffiFAbU0zXPtNmcKbfJ97vn1X0qGr5kYXg714gGLOWFKq8fpl+Anmr0cgp+05OC0OLZ2eOajjWE/qwUk6sEqrGitTpRzcjh/zZrhnMXv7Prkzk2pw7aXcNtehNahfYbZrzMGcnvHGPFGV6jt3O7M0pxwa0MEv0TfV142wHQBO7vwp0Ze0wzwOnba5KG/69vkANdVuTC5t1dVAtWpuQGs62zmRm+R8oGe5s5JqxPPRnENq6QfVt9YHNQ6G9IPcVmHdotBG+q+WWWtpQAMAhp+BIKuYV0k30EFC07c/T8uIOA5SyaEtbncqa/r2ubCdnEtz/XGfU+5Pa1xdiwQa/g88O2cf3Dlto+WxuQ5t6X+Hu7uKLyv9U/2Y3netXyaYQmagjV/op/K/uZ6uQrrxadO3Xx/KyG0d3BlCjOSw/0H8WduSZU3f/oaJ2Q31Fpe+lqQLR/agtk7dTe3QEvCWC6OTlPlnq9KLwXj8eDsk0DggKXi5OjXloeqSC8Qg7j15lX6llNoGabu5uKpaUsqhHQjFzwiHffd607c/E7aB2j6ABzkVB7U6HuHSudI+v7mfac+0JKC9sgI/ZkdRfVphpuK98FDfQtOAtI6xyAvDNQPtVQnH98Kc0860nU3fvjkyj36oh8xPG9CyrDlijTGXcnE9K21Al1OuO2e3b/r2y8O+q7UPt5Rj07yUfKf7Xuia/1NYXcLPQADAPx8ftZNtyxgd9t0fN337n0w1+e9Ju9vuPanP46P2B8qwp98bX5JWDfSw07hc9CmAH0LOTRebtx4ftT+E8n+Ea9SWcsxch333R1caenHuDGxAqzrsO2se+s2RQ3Htj0K6UVPbtN3a1PTtx3iRdkx1+tb+tf+kw75D07erTR9ytAH9QiVAzXVpT7upDqwt5ZiZTDu+6duvHvad+HCYw7570zgG4Ic6jj/r77Dv/hB+ULX3veoLwyUBTT7pJy2Hb0c90QKavv0ptw3M9gF2qCmY0/H/i6tjpL6nROznJzwMfbaaGmjq8U/cY6tqf5CPwwLh0mdjN33708O++52kvfS4LeAOVg7stO6ij8GdU53GVPLnUl8hpeR51BcVV1VmoKPni2nPTVviqc2zrZo7p/XfJP4sbY+KO2vPspurrM+4y3q+3ZJSjpMyvtwvHWTaKTq49P9FLq25s8WVOIfDYd+9JfQv9fskickyl91tV9Phq2qRQAdFeXSQdwemacdnUtsB6t9lxgzL1Dr1R7Y57Ls/GMb6b2YMHPbdselbsg62dEP7nJ4V+o+gybU0oLkdkHOqTV362PTtqwPU7HhN3340QG0BWRv/rE0CM3kWOOw7rt8PuG12iPtcl5DKAJgf0DUvDLm+HqeBzHgXUDNgp200hwbuQH1r6JuFObw63blkuqFdEF5dUwGtger+QIRTYm7fqUuLeXLTtx8BwGHf/R4RY3bow777xuDMRyHNOA5jfcnUp+6sjUu9lpB0wVd6LFIlv213xPDMiGF9F5XV0BG4y6OH50h4xoq3dYc7l34a6gaof9X07atJ/Nly07f/C2A3QB3KPkq3kdJh330jLDd9+z/Ue6P6aPo2fY+h/oYo8wAUYp8l8881RAFfZDwX0K98+P5xeD5CCkRNpWONAZdqm0J9gxeO+JkGNe4OgBPEh333+8QYF//K1fTtT4Rtvlg+7LsvI5hjCJ7E2wwaDJMrD+lGesu7pqNzOhvL85MUpX9jRXp4iOW5G9bY02t4dgTxnDvrdsavwaVPjwdLnJrrh1v3iLwgO+y73wBA07cvEXEh1XictiNepbr4bPdjQ6zUpyeWc+hsoKe8KNTy6Jy+cnJGqS6A8SSUNX3724d999lh31E/v0btMEv+LMWf1gvAnI7F1Y2JldpOmj8D5YGukRuJfQVHEb7bwfXJlZFQA3duTWwTtR6XSX9UPIaxLDBTeTP1nihduLMxtsT+TPsqBrsbaOUW+Fjl9JnrOFIZBfWDpm8fRFBTY5dwaBz23fOmb18aYE7rY5i970vcroyLweoMeH8a2Z1DA0Uf3Cjmx0wcGevIpbWyePnp8HoTlx/23a8B7Jq+fYBzZefQh30XHpOLpm/Dk0VTKMOtbQ1mKPWkOyu/URiW1f6IOC2G7dMLdO1/kj1i/AxFWIbQVju1pmNLZfFymPmIZxJOIA9gA7hz8GQ7LO/zGIG8Y0AO6wFmKmfmllWXDjMbBnfmYLao5ln9TKUcmlv2zHZQMaVdWiuTlmO3voD1sO8+p8qbvv3KUP8F1W/Tt7GpUPuCSjHS2GywK7izNdZ0hpkk5QBGpR3UsiXt0GKxu+2+DSB9YHcNqAEG7LRdDHLTt+lPSUif/QfRci2YOXfOTSGoWK7f4ukGUB/osFxjTpqKkVzauq3aMnAJNhWTozi1CH1zIHmXz8oSmKk4j+OmZZ6DoyjQJaftxuRX1tyKcoq43VGYxjuLI8q05Xj9Mc5nQp7gzlG57ZN0HNp+gPOLvsfKNox1aQnmdPss+8UaS7XjxnYr26GBrLRDivWmBuLYznxaWtbqQpn3f/lSBaeXDliq3g02kzdfxBGvljJLbJV0A6g7y3HEi5kEQD4lxzFHIjYuS+uPRLvTh0F8eYnri2ov1aX1j4nyFwW33XvD47lScTuuNNhemC1jpu08Z9gijpyqVMqRs5GWWGlnizuc+XqpJeWw1mnbkf5J5Vqfnu2SYL4ByM/Gm2qM2XdS7GjIRwHtOC1YjkwtRnOHizIin5baeIDhgLO4VCqprTa2pS6GWcubx3z+GvzmzyY33QDqfDlJO0VxsVyd1SXID9wAteZu0npNh7aMzy1bYbb2T5Vb9p2lfrQrxxoNNPHdDk5el07LqXaiK4VlBWptmVqf2qE9Ln22rMBsOVtxcVI81c4E+Rh3Bup9fdRyBFpOb1Yn0eJyoLbs5Kkd2gW2EWZpDCkup86yDaNUBOhMl5ZiqHXLzpDizqAW5qm9YMflpR06Z5sCzG/DBrPVPLi4Yvt8rDsDdb/gP8alLa4r9aNCDVzcfJG2l4NI2p5ch+b619zzVJ9MzVFx6bLHVS3bcxV3BkbeWEk18nY4t2y94ZL2K/Yd/+wv890Pbp0r89TH8p6xqLKzFANwwRyWPWdG1TiYftm+SrgzUB9objnny0hcXC7UAH1HUeqXUonvcKSyOuVp3TCTkQNzvOw9AFzwzxJoQHXptHyM6+ZCfdE2/ZF2xbG5MksdJ2kfiA7tdGWqrgbMaZwYXwpmYJp/ktXyRC3eEse1MZ360jtnxEyI1j9XZ/2T+qDK4+30pBjp52F1cXJ8Z5wUX0zFHRpwuzQX582nLeOo8YpbU21SlXboi/r4gMtMMcbEe+Mmc2egPtBA/dRDWub60/JjC9hUu5JKIT57CIwR5HQ9F+awXDTVABYCNOC6QAzLNaGm2lrbwAi31I8mch8IEHNtLGmYtc1YmNW+S8MMVAQacKUeYbnkLIZ0Medx61NZCnaQArhL1PMxnCCn65xbcnHUsrV/7YA6vdaAGZgOaKBcPh3WS0JtWb8o5wBnZP7tbOPXO6lyi4tSsSVglsarnmoEVQUaMKUe8bprDtkZm8oKNld2Ue4E/CTlu9uW8lyQ0/UcmNNYtU0tmIEJgAaK5dPpshartY3LrBBb8uMasxxcjFSWk2PHy7ngT543x6r9oJlUR9A7PC4Pb3jH1O2SdmmstW0cHyT1rcVzMbmS+vGCnJZ7Lx5zYObaV9UkDg248+mwXGpqzpsfm1KMETGpch06Ls/Jsy0Xj7kwT5Y3x5oMaMCdT4flUlBb1i3jaOUl5XVbqW3OTMhYmE/LU8AMTAw0UB1qKt4zFiUL3NZ6Sdp+sEDM1XtTDKnNbGEGps+hY2m5cYm8mGuT1sXr1HaGeqpvbuwS0lzWG29xZS4uLLtgnlqTOzTA5tPpMlU31Xxzbq5c2qFLzX6o+S0TOxrmKd0ZuBLQQBWoqfW4zHoAaGWSaqYclngroN6DYBEwA1f84c3kzXo+LO+0EbUTqbxRKuN2zPsA/gHA3wP4kyj2r4ayv4nK/nYo++ukX6l/6r14tz1eBxGXlnk/49nADFz5l2RHQm1tm7axgi2Vp3U7AO8R446VNKYVbu3A0VKMxcAMzOCnkUdALcVLO08C2+PQafuHAL5LxFllcW3Pdlr7itfT5UXBDMwAaKC4U2tunba1nL658YL+DcBzAH+By8/U4vYSBB4oqb65Prk+FunMQbMAGnBD7dkB2o7Ndee4/CcA/hXAWwD+nBlLEwV5rktr7zdel/rlxrlYngPMwIyABlxQc/UW56GkgWSB5Z8AfArgXQBfI9pJY1kdOtfprWeynM98NjADMwMaGA21xWW8YFtd8lPcPYX/NQDfYfqXlDN2CZC1MxxVNkuYgRkCDahQcy6VxkunSq4vqt7jpv+Cu/QjvetpcemS28F9TtR67uc7O5iBmQINkFDXcOs0lpMGVFh/DuDvhH4A4BGAf4z+fqCMkQM+Vc69l7ic6pPsZ44wA1e8U+iR464iV17ji/yWcT3K3Q8aiGmZ5txU+exBDloE0IAINbWulXkhnuKrolZpLs2VecG/WJ87zMCCgAYuoAbyv7c89ov8UwKu7R/NYa0gp+VnMUuAGVgY0EEZbs2Vl/wifwnIrfvCDaSj3dn6UkAOWiTQgOrW1LqnfG7phzXNsALLlS/SlWMtFuggxa25Mk/8Ehza48Zq/BJBDlo80IDJrbmynLo5OLQXVqlu8a4caxVABxUAe0x9TYfOvTCU6lcFctCqgA4qBHatOEljLwotcasEOWiVQAcZwZbKx8aWkmcfmVx+bSAHrRroIAJsoHzqMKVDW9tdlK8V5KB7AXSQE2yt7tpyXfytHeSgewV0EAM2MK87hKmyLgzvC8hB9xLoWALcwPS5dYlc+d5BHOveAx1LgRuYsUPfZ4hjbUALMgAea1KH3gCmtQHtkBPwotoAtmkDupBKwL5BO14b0JtWpdn+T+GmTTnagN60Km1Ab1qVNqA3rUob0JtWpQ3oTavSBvSmVWkDetOq9P8PEKoP+VKAqAAAAABJRU5ErkJggg==">
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&family=Bebas+Neue&family=Space+Mono:wght@400;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --neon-pink: #ff2d7b;
    --neon-cyan: #00f0ff;
    --neon-purple: #b44dff;
    --deep-black: #030304;
    --text-glow: rgba(255, 45, 123, 0.6);
    --cyan-glow: rgba(0, 240, 255, 0.4);
    --purple-glow: rgba(180, 77, 255, 0.4);
    --aftercare-warm: rgba(255, 180, 100, 0.4);
  }

  /* ═══ SETTINGS PANEL ═══ */
  .settings-panel {
    cursor: default;
    position:fixed;top:0;left:0;width:100%;height:100%;z-index:215;
    background:rgba(3,3,4,0.98);display:none;
    overflow-y:auto;-webkit-overflow-scrolling:touch;
  }
  .settings-panel.visible { display:flex;flex-direction:column;align-items:center;padding:30px 20px 60px; }
  .settings-header {
    font-family:'Bebas Neue',sans-serif;font-size:clamp(1.5rem,4vw,2.5rem);
    letter-spacing:0.3em;color:var(--neon-pink);margin-bottom:8px;
  }
  .settings-sub { font-size:10px;letter-spacing:0.2em;color:rgba(255,255,255,0.2);margin-bottom:24px; }
  .settings-section {
    width:100%;max-width:500px;margin-bottom:20px;
  }
  .settings-section-title {
    font-family:'Bebas Neue',sans-serif;font-size:16px;letter-spacing:0.2em;
    color:var(--neon-cyan);margin-bottom:10px;border-bottom:1px solid rgba(0,240,255,0.1);
    padding-bottom:6px;
  }
  .settings-row {
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 0;border-bottom:1px solid rgba(255,255,255,0.03);
  }
  .settings-label {
    font-size:12px;letter-spacing:0.1em;color:rgba(255,255,255,0.5);
  }
  .settings-label small { display:block;font-size:9px;color:rgba(255,255,255,0.2);margin-top:2px; }
  /* Toggle switch */
  .toggle-switch {
    position:relative;width:44px;height:24px;cursor:pointer;flex-shrink:0;
  }
  .toggle-switch input { display:none; }
  .toggle-track {
    width:100%;height:100%;border-radius:12px;
    background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);
    transition:all 0.3s;
  }
  .toggle-switch input:checked + .toggle-track {
    background:rgba(0,240,255,0.15);border-color:var(--neon-cyan);
  }
  .toggle-thumb {
    position:absolute;top:3px;left:3px;width:18px;height:18px;
    border-radius:50%;background:rgba(255,255,255,0.4);transition:all 0.3s;
  }
  .toggle-switch input:checked ~ .toggle-thumb {
    left:23px;background:var(--neon-cyan);box-shadow:0 0 8px var(--neon-cyan);
  }
  /* Frequency control */
  .freq-control {
    display:flex;align-items:center;gap:8px;
  }
  .freq-btn {
    width:28px;height:28px;border:1px solid rgba(255,255,255,0.15);
    background:transparent;color:rgba(255,255,255,0.5);border-radius:4px;
    font-family:'JetBrains Mono',monospace;font-size:14px;cursor:pointer;
    display:flex;align-items:center;justify-content:center;transition:all 0.2s;
  }
  .freq-btn:hover { border-color:var(--neon-cyan);color:var(--neon-cyan); }
  .freq-value {
    font-family:'Space Mono',monospace;font-size:12px;
    color:var(--neon-cyan);min-width:60px;text-align:center;letter-spacing:0.1em;
  }

  /* Theme grid */
  .theme-grid {
    display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px;
    width:100%;
  }
  .theme-card {
    padding:14px 12px;border:1px solid rgba(255,255,255,0.08);border-radius:6px;
    background:rgba(255,255,255,0.02);cursor:pointer;transition:all 0.3s;text-align:center;
  }
  .theme-card:hover { border-color:rgba(255,255,255,0.2);background:rgba(255,255,255,0.04); }
  .theme-card.active { border-color:var(--neon-cyan);background:rgba(0,240,255,0.05); }
  .theme-card-swatch {
    width:100%;height:24px;border-radius:3px;margin-bottom:8px;
  }
  .theme-card-name {
    font-family:'Bebas Neue',sans-serif;font-size:14px;letter-spacing:0.15em;
    color:rgba(255,255,255,0.7);
  }
  .theme-card-desc {
    font-size:8px;letter-spacing:0.1em;color:rgba(255,255,255,0.2);margin-top:2px;
  }

  .settings-close {
    font-family:'JetBrains Mono',monospace;font-size:11px;letter-spacing:0.3em;
    color:var(--neon-pink);background:transparent;border:1px solid rgba(255,45,123,0.3);
    padding:10px 36px;cursor:pointer;margin-top:16px;transition:all 0.3s;text-transform:uppercase;
  }
  .settings-close:hover { background:rgba(255,45,123,0.1);box-shadow:0 0 15px rgba(255,45,123,0.2); }

  /* ═══ BRAIN UPLOAD ═══ */
  .brain-upload-row {
    display:flex;gap:10px;margin-top:8px;
  }
  .brain-btn {
    flex:1;font-family:'JetBrains Mono',monospace;font-size:10px;letter-spacing:0.08em;
    padding:10px 16px;border-radius:6px;cursor:pointer;transition:all 0.2s;
    display:flex;align-items:center;justify-content:center;gap:8px;
  }
  .brain-btn-export {
    background:rgba(100,200,255,0.08);border:1px solid rgba(100,200,255,0.25);
    color:rgba(100,200,255,0.6);
  }
  .brain-btn-export:hover {
    background:rgba(100,200,255,0.12);border-color:rgba(100,200,255,0.4);
    color:rgba(100,200,255,0.8);
  }
  .brain-btn-import {
    background:rgba(255,170,100,0.08);border:1px solid rgba(255,170,100,0.25);
    color:rgba(255,170,100,0.6);
  }
  .brain-btn-import:hover {
    background:rgba(255,170,100,0.12);border-color:rgba(255,170,100,0.4);
    color:rgba(255,170,100,0.8);
  }
  .brain-btn .icon { font-size:14px; }

  /* Brain Import Modal */
  .brain-modal {
    position:fixed;top:0;left:0;width:100%;height:100%;z-index:500;
    background:rgba(0,0,0,0.9);display:none;align-items:center;justify-content:center;
    backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);
  }
  .brain-modal.visible { display:flex; }
  .brain-modal-content {
    background:rgba(15,15,18,0.98);border:1px solid rgba(255,255,255,0.08);
    border-radius:12px;padding:24px;max-width:450px;width:90%;max-height:85vh;
    overflow-y:auto;
  }
  .brain-modal-title {
    font-family:'Space Mono',monospace;font-size:16px;letter-spacing:0.12em;
    color:rgba(255,255,255,0.7);margin-bottom:8px;
  }
  .brain-modal-sub {
    font-family:'JetBrains Mono',monospace;font-size:10px;
    color:rgba(255,255,255,0.25);margin-bottom:20px;
  }
  
  .brain-preview-section {
    background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.06);
    border-radius:8px;padding:14px;margin-bottom:16px;
  }
  .brain-preview-title {
    font-family:'Space Mono',monospace;font-size:11px;letter-spacing:0.1em;
    color:rgba(255,255,255,0.35);margin-bottom:10px;
  }
  .brain-preview-grid {
    display:grid;grid-template-columns:1fr 1fr;gap:8px 16px;
  }
  .brain-preview-item {
    display:flex;justify-content:space-between;align-items:center;
  }
  .brain-preview-label {
    font-family:'JetBrains Mono',monospace;font-size:10px;color:rgba(255,255,255,0.25);
  }
  .brain-preview-value {
    font-family:'JetBrains Mono',monospace;font-size:11px;color:rgba(255,170,0,0.6);
  }
  .brain-preview-value.highlight {
    color:rgba(100,255,150,0.7);
  }

  .brain-merge-section {
    margin-bottom:16px;
  }
  .brain-merge-title {
    font-family:'Space Mono',monospace;font-size:11px;letter-spacing:0.1em;
    color:rgba(255,255,255,0.35);margin-bottom:10px;
  }
  .brain-merge-option {
    display:flex;align-items:center;gap:10px;padding:8px 12px;
    background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.06);
    border-radius:6px;margin-bottom:6px;cursor:pointer;transition:all 0.15s;
  }
  .brain-merge-option:hover {
    background:rgba(255,255,255,0.04);border-color:rgba(255,255,255,0.1);
  }
  .brain-merge-option.selected {
    background:rgba(255,170,0,0.08);border-color:rgba(255,170,0,0.25);
  }
  .brain-merge-radio {
    width:14px;height:14px;border:2px solid rgba(255,255,255,0.15);
    border-radius:50%;display:flex;align-items:center;justify-content:center;
  }
  .brain-merge-option.selected .brain-merge-radio {
    border-color:rgba(255,170,0,0.5);
  }
  .brain-merge-option.selected .brain-merge-radio::after {
    content:'';width:6px;height:6px;background:rgba(255,170,0,0.7);border-radius:50%;
  }
  .brain-merge-text {
    font-family:'JetBrains Mono',monospace;font-size:10px;color:rgba(255,255,255,0.4);
  }
  .brain-merge-option.selected .brain-merge-text { color:rgba(255,255,255,0.6); }

  .brain-modal-actions {
    display:flex;gap:10px;margin-top:20px;
  }
  .brain-modal-btn {
    flex:1;font-family:'JetBrains Mono',monospace;font-size:11px;letter-spacing:0.08em;
    padding:12px;border-radius:6px;cursor:pointer;transition:all 0.2s;
  }
  .brain-modal-cancel {
    background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);
    color:rgba(255,255,255,0.4);
  }
  .brain-modal-cancel:hover { background:rgba(255,255,255,0.06);color:rgba(255,255,255,0.6); }
  .brain-modal-confirm {
    background:rgba(100,255,150,0.1);border:1px solid rgba(100,255,150,0.3);
    color:rgba(100,255,150,0.7);
  }
  .brain-modal-confirm:hover {
    background:rgba(100,255,150,0.15);color:rgba(100,255,150,0.9);
  }
  .brain-modal-confirm:disabled {
    opacity:0.4;cursor:not-allowed;
  }

  .brain-error {
    background:rgba(255,80,80,0.1);border:1px solid rgba(255,80,80,0.3);
    border-radius:6px;padding:12px;margin-bottom:16px;
    font-family:'JetBrains Mono',monospace;font-size:10px;color:rgba(255,80,80,0.8);
  }
  .brain-success {
    background:rgba(100,255,150,0.1);border:1px solid rgba(100,255,150,0.3);
    border-radius:6px;padding:12px;margin-bottom:16px;
    font-family:'JetBrains Mono',monospace;font-size:10px;color:rgba(100,255,150,0.8);
  }

  /* ═══ IN-GAME POPPERS HUD ═══ */
  .poppers-hud {
    position:fixed;bottom:20px;right:20px;z-index:20;
    display:none;flex-direction:column;align-items:flex-end;gap:6px;
    opacity:0.35;transition:opacity 0.3s;
  }
  .poppers-hud:hover { opacity:0.7; }
  .poppers-hud.visible { display:flex; }
  .poppers-hud-btn {
    font-family:'JetBrains Mono',monospace;font-size:8px;letter-spacing:0.15em;
    color:rgba(255,255,255,0.4);background:rgba(255,255,255,0.03);
    border:1px solid rgba(255,255,255,0.08);border-radius:3px;
    padding:5px 10px;cursor:pointer;transition:all 0.2s;text-transform:uppercase;
  }
  .poppers-hud-btn:hover { border-color:rgba(180,77,255,0.3);color:rgba(180,77,255,0.6); }
  .poppers-hud-btn.paused { border-color:rgba(255,100,0,0.3);color:rgba(255,100,0,0.5); }
  .poppers-hud-freq {
    display:flex;align-items:center;gap:4px;
  }
  .poppers-hud-freq button {
    width:20px;height:20px;border:1px solid rgba(255,255,255,0.08);
    background:transparent;color:rgba(255,255,255,0.3);border-radius:2px;
    font-size:10px;cursor:pointer;display:flex;align-items:center;justify-content:center;
  }
  .poppers-hud-freq button:hover { border-color:rgba(180,77,255,0.3);color:rgba(180,77,255,0.5); }
  .poppers-hud-freq span {
    font-family:'JetBrains Mono',monospace;font-size:7px;letter-spacing:0.1em;
    color:rgba(255,255,255,0.25);min-width:30px;text-align:center;
  }

  body {
    background: var(--deep-black);
    overflow: hidden;
    cursor: none;
    font-family: 'JetBrains Mono', monospace;
    color: white;
    user-select: none;
    -webkit-user-select: none;
  }

  .cursor-dot {
    display: none; /* Cursor disabled for immersion */
    position: fixed; width: 8px; height: 8px;
    background: var(--neon-pink); border-radius: 50%;
    pointer-events: none; z-index: 10000;
    mix-blend-mode: screen;
    box-shadow: 0 0 10px var(--neon-pink), 0 0 20px var(--neon-pink);
  }
  .cursor-ring {
    position: fixed; width: 32px; height: 32px;
    border: 1px solid rgba(255, 45, 123, 0.4);
    border-radius: 50%; pointer-events: none; z-index: 10000;
    transition: transform 0.15s ease, width 0.2s, height 0.2s;
  }

  #bgCanvas {
    position: fixed; top: 0; left: 0;
    width: 100vw; height: 100vh; z-index: 1;
  }

  /* Scanlines */
  .scanlines {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 5;
    pointer-events: none;
    background: repeating-linear-gradient(0deg,
      rgba(0,0,0,0) 0px, rgba(0,0,0,0) 1px,
      rgba(0,0,0,0.04) 1px, rgba(0,0,0,0.04) 2px);
  }
  .scanlines::after {
    content: ''; position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.4) 100%);
  }

  /* Noise */
  .noise {
    position: fixed; top: -50%; left: -50%;
    width: 200%; height: 200%; z-index: 4;
    pointer-events: none; opacity: 0.015;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    animation: noiseShift 0.5s steps(3) infinite;
  }
  @keyframes noiseShift {
    0% { transform: translate(0,0); }
    33% { transform: translate(-5%,-5%); }
    66% { transform: translate(5%,2%); }
    100% { transform: translate(0,0); }
  }

  /* Glitch layers */
  .glitch-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 6;
    pointer-events: none; opacity: 0; mix-blend-mode: screen;
  }
  .glitch-overlay.active { animation: glitchFlash 0.15s steps(2) forwards; }
  @keyframes glitchFlash {
    0% { opacity: 0.8; transform: translate(-2px, 1px); }
    25% { opacity: 0.6; transform: translate(3px, -2px); }
    50% { opacity: 0.9; transform: translate(-1px, 3px); }
    75% { opacity: 0.5; transform: translate(2px, -1px); }
    100% { opacity: 0; transform: translate(0); }
  }

  .screen-tear {
    position: fixed; left: 0; width: 100%; height: 3px;
    background: var(--neon-cyan); z-index: 7;
    pointer-events: none; opacity: 0;
    box-shadow: 0 0 10px var(--neon-cyan), 0 -2px 20px var(--neon-cyan);
  }
  .screen-tear.active { opacity: 0.7; animation: tearDrop 0.3s linear forwards; }
  @keyframes tearDrop { 0% { top: -3px; opacity: 0.7; } 100% { top: 100vh; opacity: 0; } }

  .rgb-split {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 4;
    pointer-events: none; opacity: 0;
  }
  .rgb-split.active { animation: rgbSplit 0.2s ease-out forwards; }
  @keyframes rgbSplit {
    0% { opacity: 1; box-shadow: -3px 0 0 rgba(255,0,0,0.3), 3px 0 0 rgba(0,255,255,0.3); }
    100% { opacity: 0; box-shadow: 0 0 0 transparent; }
  }

  /* ═══ BLACKOUT ═══ */
  .blackout-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 50;
    background: var(--deep-black);
    pointer-events: none; opacity: 0;
    transition: opacity 0.8s ease;
    display: flex; align-items: center; justify-content: center;
  }
  .blackout-overlay.active { opacity: 1; }
  .blackout-text {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(1.5rem, 4vw, 3rem);
    letter-spacing: 0.3em; color: rgba(255,255,255,0);
    transition: color 1.2s ease; text-transform: uppercase;
  }
  .blackout-overlay.active .blackout-text {
    color: rgba(255,255,255,0.7);
    text-shadow: 0 0 30px var(--text-glow);
  }

  /* ═══ LOCKOUT ═══ */
  .lockout-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 55;
    background: rgba(3,3,4,0.97);
    pointer-events: none; opacity: 0; transition: opacity 0.5s ease;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center; gap: 30px;
  }
  .lockout-overlay.active { opacity: 1; }
  .lockout-label {
    font-family: 'Space Mono', monospace;
    font-size: 11px; letter-spacing: 0.4em;
    color: rgba(255,45,123,0.5); text-transform: uppercase;
  }
  .lockout-timer {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(4rem, 12vw, 10rem); letter-spacing: 0.2em;
    color: var(--neon-pink);
    text-shadow: 0 0 40px var(--text-glow), 0 0 80px var(--text-glow);
  }
  .lockout-subtext {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px; letter-spacing: 0.2em; color: rgba(255,255,255,0.15);
  }

  /* ═══ TEXT SYSTEM ═══ */
  .text-layer {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 25;
    pointer-events: none;
    display: flex; align-items: center; justify-content: center;
  }
  .command-text {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(2rem, 6vw, 5rem);
    letter-spacing: 0.15em; text-transform: uppercase; color: white;
    text-shadow: 0 0 10px var(--text-glow), 0 0 30px var(--text-glow), 0 0 60px var(--text-glow);
    opacity: 0; transform: scale(0.95);
    transition: opacity 0.4s ease, transform 0.4s ease;
  }
  .command-text.visible { opacity: 1; transform: scale(1); }
  .command-text.fade-out { opacity: 0; transform: scale(1.05); }

  .mantra-layer {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 25;
    pointer-events: none;
    display: flex; align-items: center; justify-content: center;
    padding-top: 25vh;
  }
  .mantra-text {
    font-family: 'Space Mono', monospace;
    font-size: clamp(1rem, 2.5vw, 1.8rem);
    letter-spacing: 0.25em; text-transform: lowercase;
    color: rgba(180, 77, 255, 0); text-align: center;
    transition: color 0.8s ease;
  }
  .mantra-text.visible { animation: mantraPulse 4s ease-in-out infinite; }
  @keyframes mantraPulse {
    0%, 100% { color: rgba(180, 77, 255, 0.15); }
    50% { color: rgba(180, 77, 255, 0.6); text-shadow: 0 0 20px var(--purple-glow); }
  }

  .subliminal {
    position: fixed; z-index: 25; pointer-events: none;
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(4rem, 12vw, 10rem);
    letter-spacing: 0.3em; color: white;
    opacity: 0; mix-blend-mode: difference;
  }
  .subliminal.flash { animation: subliminalFlash 0.08s steps(1) forwards; }
  @keyframes subliminalFlash { 0% { opacity: 0.9; } 50% { opacity: 0.7; } 100% { opacity: 0; } }

  .ticker {
    position: fixed; bottom: 40px; left: 0;
    width: 100%; z-index: 20; pointer-events: none;
    overflow: hidden; height: 20px; opacity: 0; transition: opacity 0.5s;
  }
  .ticker.visible { opacity: 0.5; }
  .ticker-text {
    font-family: 'Space Mono', monospace;
    font-size: 11px; color: var(--neon-cyan);
    white-space: nowrap; letter-spacing: 0.2em; text-transform: uppercase;
    animation: tickerScroll 40s linear infinite;
  }
  @keyframes tickerScroll { 0% { transform: translateX(100vw); } 100% { transform: translateX(-300%); } }

  /* ═══ BREATHING RING ═══ */
  .breath-container {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    z-index: 2; pointer-events: none;
    width: 200px; height: 200px;
    display: flex; align-items: center; justify-content: center;
    opacity: 0; transition: opacity 1s ease;
  }
  .breath-ring-outer {
    position: absolute; width: 100%; height: 100%;
    border: 1px solid rgba(0,240,255,0.08); border-radius: 50%;
    transition: transform 3s ease-in-out, border-color 2s ease;
  }
  .breath-ring-mid {
    position: absolute; width: 70%; height: 70%;
    border: 1px solid rgba(255,45,123,0.12); border-radius: 50%;
    transition: transform 3s ease-in-out, border-color 2s ease;
  }
  .breath-ring-inner {
    position: absolute; width: 40%; height: 40%;
    border: 1px solid rgba(180,77,255,0.15); border-radius: 50%;
    transition: transform 3s ease-in-out, border-color 2s ease;
  }
  .breath-ring-core {
    position: absolute; width: 8px; height: 8px;
    background: rgba(255,45,123,0.3); border-radius: 50%;
    box-shadow: 0 0 20px rgba(255,45,123,0.2);
    transition: transform 3s ease-in-out, box-shadow 2s ease;
  }
  .breath-text {
    position: absolute; bottom: -30px;
    font-family: 'Space Mono', monospace;
    font-size: 9px; letter-spacing: 0.3em;
    color: rgba(255,255,255,0); text-transform: uppercase;
    transition: color 0.8s ease; white-space: nowrap;
  }

  /* ═══ TERMINAL ═══ */
  .terminal {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 100;
    background: var(--deep-black);
    display: flex; flex-direction: column;
    justify-content: center; padding: 10vw;
    transition: opacity 0.8s ease;
  }
  .terminal.hidden { opacity: 0; pointer-events: none; }
  .terminal-line {
    font-family: 'JetBrains Mono', monospace;
    font-size: clamp(10px, 1.4vw, 14px);
    color: var(--neon-cyan); margin-bottom: 4px;
    opacity: 0; transform: translateY(5px);
    white-space: nowrap; overflow: hidden;
  }
  .terminal-line.visible { opacity: 1; transform: translateY(0); transition: opacity 0.2s, transform 0.2s; }
  .terminal-line.error { color: var(--neon-pink); }
  .terminal-line.success { color: #00ff88; }
  .terminal-line.highlight { color: var(--neon-purple); font-weight: 700; }
  .cursor-blink {
    display: inline-block; width: 8px; height: 14px;
    background: var(--neon-cyan);
    animation: blink 0.6s steps(1) infinite;
    vertical-align: text-bottom; margin-left: 2px;
  }
  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

  /* ═══ ENTRY SCREEN ═══ */
  .entry-prompt {
    cursor: default;
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 200;
    background: var(--deep-black);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    padding: 40px 20px;
    overflow-y: auto;
  }
  .entry-prompt.hidden { display: none; }
  
  /* ═══ TITLE SECTION ═══ */
  .entry-header {
    text-align: center;
    margin-bottom: 40px;
  }
  .entry-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(4rem, 15vw, 9rem);
    letter-spacing: 0.35em;
    color: rgba(255,255,255,0.95);
    text-shadow: 
      0 0 40px rgba(255,255,255,0.1),
      0 0 80px rgba(180,77,255,0.15),
      0 0 120px rgba(180,77,255,0.1);
    animation: titleBreath 4s ease-in-out infinite;
    line-height: 1;
    margin: 0;
    padding-right: 0.35em; /* compensate for letter-spacing */
  }
  @keyframes titleBreath {
    0%, 100% { opacity: 0.85; text-shadow: 0 0 40px rgba(255,255,255,0.1), 0 0 80px rgba(180,77,255,0.15); }
    50% { opacity: 1; text-shadow: 0 0 60px rgba(255,255,255,0.15), 0 0 120px rgba(180,77,255,0.25); }
  }
  .entry-tagline {
    font-family: 'JetBrains Mono', monospace;
    font-size: clamp(9px, 1.5vw, 12px);
    color: rgba(255,255,255,0.2);
    letter-spacing: 0.25em;
    margin-top: 12px;
    font-weight: 300;
  }
  
  /* ═══ PLAYER CARD ═══ */
  .player-card {
    background: linear-gradient(180deg, rgba(255,255,255,0.02) 0%, rgba(255,255,255,0.005) 100%);
    border: 1px solid rgba(255,255,255,0.05);
    border-radius: 8px;
    padding: 28px 44px;
    text-align: center;
    margin-bottom: 40px;
    min-width: 280px;
    max-width: 340px;
    position: relative;
    cursor: pointer;
    transition: all 0.4s ease;
    animation: cardFadeIn 0.8s ease-out;
  }
  @keyframes cardFadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .player-card:hover {
    border-color: rgba(255,255,255,0.1);
    background: linear-gradient(180deg, rgba(255,255,255,0.035) 0%, rgba(255,255,255,0.01) 100%);
    transform: translateY(-2px);
    box-shadow: 0 8px 30px rgba(0,0,0,0.3);
  }
  .player-card::before {
    content: '';
    position: absolute;
    top: -1px; left: 15%; right: 15%; height: 1px;
    background: linear-gradient(90deg, transparent, rgba(255,170,0,0.4), transparent);
  }
  .player-card::after {
    content: '';
    position: absolute;
    bottom: -1px; left: 25%; right: 25%; height: 1px;
    background: linear-gradient(90deg, transparent, rgba(255,45,123,0.2), transparent);
  }
  .player-rank {
    font-family: 'Space Mono', monospace;
    font-size: 15px;
    font-weight: 700;
    letter-spacing: 0.25em;
    margin-bottom: 6px;
    text-transform: uppercase;
  }
  .player-level {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: rgba(255,255,255,0.3);
    letter-spacing: 0.12em;
    margin-bottom: 14px;
  }
  .player-xp-bar {
    width: 100%;
    height: 4px;
    background: rgba(255,255,255,0.04);
    border-radius: 2px;
    overflow: hidden;
    margin-bottom: 14px;
    position: relative;
  }
  .player-xp-fill {
    height: 100%;
    border-radius: 2px;
    background: linear-gradient(90deg, rgba(255,170,0,0.7), rgba(255,45,123,0.7));
    transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 0 8px rgba(255,170,0,0.3);
  }
  .player-corruption {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    color: rgba(255,45,123,0.4);
    letter-spacing: 0.15em;
    margin-bottom: 10px;
    text-transform: lowercase;
  }
  .player-stats {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    color: rgba(255,255,255,0.18);
    letter-spacing: 0.08em;
  }
  .player-stats span { color: rgba(255,170,0,0.5); font-weight: 600; }
  
  /* ═══ MAIN ACTION ═══ */
  .entry-main-action {
    margin-bottom: 20px;
    animation: buttonFadeIn 1s ease-out 0.3s both;
  }
  @keyframes buttonFadeIn {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
  }
  .entry-button-primary {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 20px;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: rgba(255,255,255,0.9);
    background: linear-gradient(180deg, rgba(255,45,123,0.12) 0%, rgba(255,45,123,0.03) 100%);
    border: 1px solid rgba(255,45,123,0.35);
    padding: 22px 70px;
    cursor: pointer;
    transition: all 0.35s ease;
    position: relative;
    overflow: hidden;
  }
  .entry-button-primary::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: linear-gradient(180deg, rgba(255,45,123,0.1) 0%, transparent 100%);
    opacity: 0;
    transition: opacity 0.3s;
  }
  .entry-button-primary:hover {
    background: linear-gradient(180deg, rgba(255,45,123,0.25) 0%, rgba(255,45,123,0.1) 100%);
    border-color: rgba(255,45,123,0.6);
    box-shadow: 
      0 0 30px rgba(255,45,123,0.2),
      inset 0 0 30px rgba(255,45,123,0.05);
    transform: translateY(-1px);
  }
  .entry-button-primary:hover::before { opacity: 1; }
  .entry-button-primary:disabled {
    opacity: 0.25;
    pointer-events: none;
    border-color: rgba(255,255,255,0.1);
    background: rgba(255,255,255,0.02);
    color: rgba(255,255,255,0.3);
  }
  .entry-button-primary:active {
    transform: translateY(1px);
  }
  
  /* ═══ VR BUTTON ═══ */
  .entry-button-vr {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 16px;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: rgba(0,240,255,0.9);
    background: linear-gradient(180deg, rgba(0,240,255,0.12) 0%, rgba(0,240,255,0.03) 100%);
    border: 1px solid rgba(0,240,255,0.35);
    padding: 14px 40px;
    margin-left: 15px;
    cursor: pointer;
    transition: all 0.35s ease;
    position: relative;
    overflow: hidden;
  }
  .entry-button-vr:hover {
    background: linear-gradient(180deg, rgba(0,240,255,0.25) 0%, rgba(0,240,255,0.1) 100%);
    border-color: rgba(0,240,255,0.6);
    box-shadow: 
      0 0 30px rgba(0,240,255,0.3),
      inset 0 0 30px rgba(0,240,255,0.05);
    transform: translateY(-1px);
  }
  .entry-button-vr:disabled {
    opacity: 0.25;
    pointer-events: none;
  }
  .entry-button-vr .vr-icon {
    font-size: 18px;
    margin-right: 8px;
    animation: vrPulse 2s ease-in-out infinite;
  }
  @keyframes vrPulse {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; text-shadow: 0 0 10px rgba(0,240,255,0.8); }
  }
  
  /* Open for VR Button (blob URL launcher) */
  .entry-button-vr-open {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    letter-spacing: 0.1em;
    color: rgba(0,255,136,0.9);
    background: linear-gradient(180deg, rgba(0,255,136,0.12) 0%, rgba(0,255,136,0.03) 100%);
    border: 1px solid rgba(0,255,136,0.35);
    padding: 14px 25px;
    margin-left: 10px;
    cursor: pointer;
    transition: all 0.35s ease;
  }
  .entry-button-vr-open:hover {
    background: linear-gradient(180deg, rgba(0,255,136,0.25) 0%, rgba(0,255,136,0.1) 100%);
    border-color: rgba(0,255,136,0.6);
    box-shadow: 0 0 20px rgba(0,255,136,0.2);
  }
  
  /* VR Mode HUD */
  .vr-hud {
    display: none;
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    border: 1px solid rgba(0,240,255,0.4);
    padding: 15px 30px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: rgba(0,240,255,0.9);
    z-index: 10001;
    border-radius: 8px;
  }
  .vr-hud.visible { display: block; }
  
  /* ═══ SESSION SELECTOR (compact) ═══ */
  .session-selector {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    margin-bottom: 50px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: rgba(255,255,255,0.2);
    letter-spacing: 0.1em;
    animation: navFadeIn 1s ease-out 0.5s both;
  }
  @keyframes navFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  .session-duration {
    color: rgba(255,255,255,0.35);
    cursor: pointer;
    padding: 8px 14px;
    border-radius: 4px;
    transition: all 0.25s ease;
    border: 1px solid transparent;
  }
  .session-duration:hover {
    background: rgba(255,255,255,0.03);
    color: rgba(255,255,255,0.6);
    border-color: rgba(255,255,255,0.05);
  }
  .session-dots {
    display: flex;
    gap: 8px;
  }
  .session-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: rgba(255,255,255,0.08);
    cursor: pointer;
    transition: all 0.25s ease;
    border: 1px solid transparent;
  }
  .session-dot:hover { 
    background: rgba(255,255,255,0.15); 
    transform: scale(1.2);
  }
  .session-dot.active { 
    background: rgba(255,45,123,0.6); 
    box-shadow: 0 0 8px rgba(255,45,123,0.4);
  }
  
  /* ═══ SECONDARY NAV ═══ */
  .entry-nav {
    display: flex;
    gap: 50px;
    margin-bottom: 30px;
    animation: navFadeIn 1s ease-out 0.6s both;
  }
  .entry-nav-link {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    letter-spacing: 0.18em;
    color: rgba(255,255,255,0.18);
    text-transform: lowercase;
    cursor: pointer;
    padding: 10px 4px;
    border: none;
    background: none;
    transition: all 0.25s ease;
    position: relative;
  }
  .entry-nav-link::after {
    content: '';
    position: absolute;
    bottom: 6px;
    left: 0; right: 0;
    height: 1px;
    background: rgba(255,255,255,0.15);
    transform: scaleX(0);
    transition: transform 0.25s ease;
  }
  .entry-nav-link:hover {
    color: rgba(255,255,255,0.5);
  }
  .entry-nav-link:hover::after {
    transform: scaleX(1);
  }
  
  /* ═══ CONTENT STATUS ═══ */
  .content-status {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    letter-spacing: 0.1em;
    color: rgba(255,255,255,0.15);
    margin-bottom: 20px;
  }
  .content-status.ready { color: rgba(0,255,136,0.4); }
  .content-status.empty { color: rgba(255,170,0,0.4); }
  
  /* ═══ FOOTER WARNING ═══ */
  .entry-footer {
    position: absolute;
    bottom: 20px;
    left: 20px; right: 20px;
    text-align: center;
  }
  .entry-warning {
    font-family: 'JetBrains Mono', monospace;
    font-size: 8px;
    color: rgba(255,255,255,0.08);
    letter-spacing: 0.1em;
    line-height: 1.8;
    max-width: 500px;
    margin: 0 auto;
  }
  
  /* Legacy compatibility - hide old elements */
  .entry-subtitle { display: none; }
  .entry-greeting { display: none; }
  .entry-level-block { display: none !important; }
  .entry-profile { display: none; }
  .entry-streak { display: none; }
  .content-counter { display: none; }
  .preset-selector { display: none; }
  .entry-button.secondary { display: none; }
  #skipBtn { display: none !important; }

  /* ═══ CONTENT UPLOAD PANEL ═══ */
  .upload-panel {
    cursor: default;
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 210;
    background: rgba(3,3,4,0.98);
    display: none; flex-direction: column;
    align-items: center; justify-content: center; gap: 30px;
    padding: 40px;
  }
  .upload-panel.visible { display: flex; }
  .upload-panel-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(1.5rem, 4vw, 3rem);
    letter-spacing: 0.3em; color: var(--neon-pink);
  }
  .upload-panel-subtitle {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px; color: rgba(255,255,255,0.25);
    letter-spacing: 0.15em; text-align: center;
    max-width: 500px; line-height: 1.8;
  }

  .drop-zone {
    width: min(500px, 80vw); height: 180px;
    border: 1px dashed rgba(255,45,123,0.25);
    border-radius: 4px;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center; gap: 12px;
    transition: all 0.3s ease; cursor: pointer;
    position: relative;
  }
  .drop-zone:hover, .drop-zone.drag-over {
    border-color: var(--neon-pink);
    background: rgba(255,45,123,0.03);
    box-shadow: 0 0 30px rgba(255,45,123,0.1);
  }
  .drop-zone-text {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px; color: rgba(255,255,255,0.3);
    letter-spacing: 0.15em; text-transform: uppercase;
  }
  .drop-zone-hint {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px; color: rgba(255,255,255,0.12);
    letter-spacing: 0.1em;
  }

  .upload-buttons {
    display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;
  }
  .upload-btn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px; letter-spacing: 0.2em; text-transform: uppercase;
    color: rgba(255,255,255,0.4); background: transparent;
    border: 1px solid rgba(255,255,255,0.1);
    padding: 10px 24px; cursor: pointer;
    transition: all 0.3s ease;
  }
  .upload-btn:hover {
    color: var(--neon-cyan); border-color: rgba(0,240,255,0.3);
    background: rgba(0,240,255,0.03);
  }

  .upload-stats {
    font-family: 'Space Mono', monospace;
    font-size: 10px; color: rgba(255,255,255,0.2);
    letter-spacing: 0.15em; text-align: center;
    line-height: 2;
  }
  .upload-stats .stat-val { color: var(--neon-cyan); }

  .upload-close {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px; letter-spacing: 0.3em; text-transform: uppercase;
    color: rgba(255,255,255,0.3); background: transparent;
    border: 1px solid rgba(255,255,255,0.1);
    padding: 12px 40px; cursor: pointer;
    transition: all 0.3s ease;
  }
  .upload-close:hover {
    color: var(--neon-pink); border-color: var(--neon-pink);
    background: rgba(255,45,123,0.05);
  }

  /* Loading progress bar during file processing */
  .upload-loading {
    display: none; width: 100%;
  }
  .upload-loading.active { display: block; }
  .upload-progress-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px; color: var(--neon-cyan);
    letter-spacing: 0.15em; margin-bottom: 6px;
    text-align: center;
  }
  .upload-progress-track {
    width: 100%; height: 4px;
    background: rgba(255,255,255,0.06);
    border-radius: 2px; overflow: hidden;
  }
  .upload-progress-fill {
    height: 100%; width: 0%;
    background: linear-gradient(90deg, var(--neon-cyan), var(--neon-pink));
    border-radius: 2px;
    transition: width 0.15s ease;
  }
  @keyframes loadBlink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

  /* ═══ LIBRARY MANAGEMENT PANEL ═══ */
  .library-panel {
    position:fixed;top:0;left:0;width:100%;height:100%;
    background:rgba(0,0,0,0.97);z-index:250;
    display:none;flex-direction:column;overflow:hidden;
  }
  .library-panel.visible { display:flex; }
  .lib-header {
    padding:18px 20px 12px;flex-shrink:0;
    border-bottom:1px solid rgba(255,255,255,0.05);
  }
  .lib-header-row {
    display:flex;align-items:center;justify-content:space-between;gap:16px;
  }
  .lib-title {
    font-family:'Space Mono',monospace;font-size:16px;
    color:rgba(255,255,255,0.7);letter-spacing:0.15em;font-weight:700;
  }
  .lib-count {
    font-family:'JetBrains Mono',monospace;font-size:12px;
    color:rgba(255,255,255,0.2);letter-spacing:0.08em;
  }
  .lib-sel-count {
    font-family:'JetBrains Mono',monospace;font-size:12px;
    color:rgba(255,170,0,0.6);letter-spacing:0.08em;
  }
  .lib-close {
    background:none;border:1px solid rgba(255,255,255,0.15);
    color:rgba(255,255,255,0.4);font-family:'Space Mono',monospace;
    font-size:12px;padding:8px 18px;border-radius:4px;cursor:pointer;
    letter-spacing:0.1em;transition:all 0.2s;
  }
  .lib-close:hover { border-color:rgba(255,255,255,0.3);color:rgba(255,255,255,0.6); }

  /* Filter bar (now in controls row) */
  .lib-filter-chip {
    background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);
    color:rgba(255,255,255,0.25);font-family:'JetBrains Mono',monospace;
    font-size:11px;padding:6px 12px;border-radius:14px;cursor:pointer;
    white-space:nowrap;transition:all 0.2s;flex-shrink:0;
  }
  .lib-filter-chip:hover { border-color:rgba(255,255,255,0.2);color:rgba(255,255,255,0.4); }
  .lib-filter-chip.active {
    background:rgba(255,170,0,0.1);border-color:rgba(255,170,0,0.3);
    color:rgba(255,170,0,0.7);
  }
  .chip-count { opacity:0.4;margin-left:4px;font-size:10px; }

  /* Toolbar */
  .lib-toolbar {
    display:flex;gap:8px;padding:10px 20px 12px;flex-shrink:0;
    flex-wrap:wrap;align-items:center;
    border-bottom:1px solid rgba(255,255,255,0.04);
  }
  .lib-tool-btn {
    background:none;border:1px solid rgba(255,255,255,0.08);
    color:rgba(255,255,255,0.3);font-family:'JetBrains Mono',monospace;
    font-size:11px;padding:6px 12px;border-radius:4px;cursor:pointer;
    transition:all 0.2s;letter-spacing:0.05em;
  }
  .lib-tool-btn:hover { border-color:rgba(255,255,255,0.2);color:rgba(255,255,255,0.5); }
  .lib-tool-sep { width:1px;height:20px;background:rgba(255,255,255,0.05);margin:0 6px; }
  .lib-tag-input {
    background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);
    color:rgba(255,255,255,0.6);font-family:'JetBrains Mono',monospace;
    font-size:12px;padding:6px 10px;border-radius:4px;width:140px;
    outline:none;transition:border-color 0.2s;
  }
  .lib-tag-input:focus { border-color:rgba(255,170,0,0.4); }
  .lib-tag-input::placeholder { color:rgba(255,255,255,0.15); }

  /* Quick-select buttons */
  .lib-quick-row {
    display:flex;gap:6px;align-items:center;flex-wrap:wrap;
  }
  .lib-quick-label {
    font-family:'JetBrains Mono',monospace;font-size:10px;
    color:rgba(255,255,255,0.2);letter-spacing:0.1em;
    margin-right:4px;
  }
  .lib-quick-btn {
    background:rgba(255,255,255,0.02);border:1px solid;
    font-family:'JetBrains Mono',monospace;font-size:10px;
    padding:5px 10px;border-radius:4px;cursor:pointer;transition:all 0.2s;
  }
  .lib-quick-btn:hover { opacity:0.9;background:rgba(255,255,255,0.04); }

  /* Content grid */
  .lib-grid {
    flex:1;overflow-y:auto;padding:16px 20px;
    display:grid;gap:12px;align-content:start;
    grid-template-columns:repeat(auto-fill,minmax(var(--lib-item-size, 180px),1fr));
  }
  .lib-grid.size-small { --lib-item-size: 120px; }
  .lib-grid.size-medium { --lib-item-size: 180px; }
  .lib-grid.size-large { --lib-item-size: 260px; }
  .lib-grid.size-feed {
    grid-template-columns: 1fr;
    max-width: 500px;
    margin: 0 auto;
    gap: 20px;
  }
  .lib-grid.size-feed .lib-item { max-width: 100%; }
  .lib-grid.size-feed .lib-thumb-wrap { aspect-ratio: auto; max-height: 70vh; }
  .lib-grid.size-feed .lib-thumb { height: auto; max-height: 70vh; }
  .lib-grid::-webkit-scrollbar { width:6px; }
  .lib-grid::-webkit-scrollbar-thumb { background:rgba(255,255,255,0.08);border-radius:3px; }
  .lib-item {
    border-radius:10px;overflow:hidden;cursor:pointer;
    border:3px solid transparent;transition:border-color 0.2s;
    background:rgba(255,255,255,0.02);
  }
  .lib-item:hover { border-color:rgba(255,255,255,0.15); }
  .lib-item.selected { border-color:rgba(255,170,0,0.6); }
  .lib-thumb-wrap { position:relative;aspect-ratio:1;overflow:hidden;background:#0a0a0a; }
  .lib-thumb {
    width:100%;height:100%;object-fit:cover;display:block;
    filter:brightness(0.85);transition:filter 0.2s;cursor:pointer;
  }
  .lib-item:hover .lib-thumb { filter:brightness(1); }
  .lib-video-badge {
    position:absolute;bottom:8px;right:8px;font-size:16px;
    background:rgba(0,0,0,0.75);border-radius:5px;padding:4px 8px;
  }
  .lib-select-check {
    position:absolute;top:8px;left:8px;width:28px;height:28px;
    border-radius:6px;border:2px solid rgba(255,255,255,0.25);
    background:rgba(0,0,0,0.7);display:flex;align-items:center;
    justify-content:center;font-size:16px;color:rgba(255,170,0,1);
    transition:all 0.2s;cursor:pointer;
  }
  .lib-select-check:hover { border-color:rgba(255,255,255,0.5);background:rgba(0,0,0,0.85); }
  .lib-item.selected .lib-select-check {
    background:rgba(255,170,0,0.25);border-color:rgba(255,170,0,0.6);
  }
  .lib-item-info { padding:8px 10px; }
  .lib-item-name {
    font-family:'JetBrains Mono',monospace;font-size:11px;
    color:rgba(255,255,255,0.35);overflow:hidden;text-overflow:ellipsis;
    white-space:nowrap;
  }
  .lib-item-tags {
    font-family:'JetBrains Mono',monospace;font-size:10px;
    color:rgba(255,170,0,0.4);margin-top:3px;
  }
  .lib-empty {
    grid-column:1/-1;text-align:center;padding:60px 20px;
    font-family:'JetBrains Mono',monospace;font-size:13px;
    color:rgba(255,255,255,0.15);letter-spacing:0.08em;
  }

  /* Controls row (filters + pagination + size) */
  .lib-controls-row {
    display:flex;flex-wrap:wrap;align-items:center;gap:10px;
    padding:10px 16px;border-bottom:1px solid rgba(255,255,255,0.04);
  }
  .lib-filter-bar {
    display:flex;gap:6px;flex:1;overflow-x:auto;
    -webkit-overflow-scrolling:touch;scrollbar-width:none;
  }
  .lib-filter-bar::-webkit-scrollbar { display:none; }
  .lib-filter-chip {
    padding:6px 12px;font-size:12px;
  }
  .lib-page-controls {
    display:flex;align-items:center;gap:14px;flex-shrink:0;
  }
  .lib-page-size {
    display:flex;align-items:center;gap:8px;
  }
  .lib-slider {
    width:70px;height:6px;-webkit-appearance:none;appearance:none;
    background:rgba(255,255,255,0.1);border-radius:3px;cursor:pointer;
  }
  .lib-slider::-webkit-slider-thumb {
    -webkit-appearance:none;width:16px;height:16px;
    background:rgba(255,170,0,0.7);border-radius:50%;cursor:pointer;
  }
  #libPageSizeLabel {
    font-family:'JetBrains Mono',monospace;font-size:10px;
    color:rgba(255,255,255,0.2);white-space:nowrap;
  }
  /* Grid size buttons */
  .lib-size-btns {
    display:flex;gap:4px;
  }
  .lib-size-btn {
    background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.1);
    color:rgba(255,255,255,0.3);font-size:12px;width:32px;height:32px;
    border-radius:4px;cursor:pointer;transition:all 0.2s;
  }
  .lib-size-btn:hover { background:rgba(255,255,255,0.08); }
  .lib-size-btn.active { background:rgba(255,170,0,0.15);border-color:rgba(255,170,0,0.3);color:rgba(255,170,0,0.7); }
  .lib-pagination {
    display:flex;align-items:center;gap:6px;
  }
  .lib-page-btn {
    background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.12);
    color:rgba(255,255,255,0.35);font-family:'JetBrains Mono',monospace;
    font-size:16px;width:36px;height:36px;border-radius:6px;cursor:pointer;
    transition:all 0.2s;display:flex;align-items:center;justify-content:center;
  }
  .lib-page-btn:hover:not(:disabled) { background:rgba(255,255,255,0.08);color:rgba(255,255,255,0.5); }
  .lib-page-btn:disabled { opacity:0.25;cursor:default; }
  .lib-page-info {
    font-family:'JetBrains Mono',monospace;font-size:12px;
    color:rgba(255,255,255,0.3);padding:0 10px;min-width:60px;text-align:center;
  }

  /* View button on thumbnails */
  .lib-view-btn {
    position:absolute;top:4px;right:4px;width:22px;height:22px;
    background:rgba(0,0,0,0.6);border-radius:4px;cursor:pointer;
    display:flex;align-items:center;justify-content:center;
    font-size:11px;opacity:0;transition:opacity 0.2s;
  }
  .lib-item:hover .lib-view-btn { opacity:1; }
  .lib-view-btn:hover { background:rgba(255,170,0,0.3); }

  /* ═══ LIGHTBOX ═══ */
  .lib-lightbox {
    position:fixed;top:0;left:0;width:100%;height:100%;
    z-index:300;display:none;
  }
  .lib-lightbox.visible { display:flex; }
  .lightbox-backdrop {
    position:absolute;top:0;left:0;width:100%;height:100%;
    background:rgba(0,0,0,0.95);
  }
  .lightbox-container {
    position:relative;z-index:1;display:flex;width:100%;height:100%;
  }
  .lightbox-main {
    flex:1;display:flex;align-items:center;justify-content:center;
    position:relative;padding:20px;
  }
  .lightbox-media {
    max-width:100%;max-height:100%;display:flex;
    align-items:center;justify-content:center;
  }
  .lightbox-content {
    max-width:calc(100vw - 320px);max-height:calc(100vh - 40px);
    object-fit:contain;border-radius:4px;
  }
  .lightbox-nav {
    position:absolute;top:50%;transform:translateY(-50%);
    background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);
    color:rgba(255,255,255,0.4);font-size:24px;width:44px;height:60px;
    border-radius:6px;cursor:pointer;transition:all 0.2s;
  }
  .lightbox-nav:hover:not(:disabled) { background:rgba(255,255,255,0.1);color:rgba(255,255,255,0.7); }
  .lightbox-nav:disabled { opacity:0.2;cursor:default; }
  .lightbox-prev { left:10px; }
  .lightbox-next { right:10px; }

  /* Lightbox sidebar */
  .lightbox-sidebar {
    width:280px;flex-shrink:0;background:rgba(10,10,10,0.95);
    border-left:1px solid rgba(255,255,255,0.05);
    display:flex;flex-direction:column;overflow-y:auto;
  }
  .lightbox-header {
    display:flex;justify-content:space-between;align-items:center;
    padding:16px;border-bottom:1px solid rgba(255,255,255,0.04);
  }
  .lightbox-counter {
    font-family:'JetBrains Mono',monospace;font-size:10px;
    color:rgba(255,255,255,0.2);letter-spacing:0.08em;
  }
  .lightbox-close {
    background:none;border:1px solid rgba(255,255,255,0.1);
    color:rgba(255,255,255,0.3);font-size:16px;width:28px;height:28px;
    border-radius:4px;cursor:pointer;transition:all 0.2s;
  }
  .lightbox-close:hover { border-color:rgba(255,100,100,0.3);color:rgba(255,100,100,0.6); }
  .lightbox-filename {
    padding:0 16px 12px;font-family:'JetBrains Mono',monospace;font-size:11px;
    color:rgba(255,255,255,0.2);word-break:break-all;
  }
  .lightbox-tags {
    flex:1;padding:0 16px 16px;overflow-y:auto;
  }

  /* Lightbox tag sections */
  .lb-tag-group {
    margin-bottom:16px;display:flex;flex-direction:column;gap:8px;
  }
  .lb-tag-label {
    font-family:'Space Mono',monospace;font-size:10px;letter-spacing:0.12em;
    color:rgba(255,255,255,0.2);text-transform:uppercase;
  }
  .lb-section {
    margin-bottom:16px;
  }
  .lb-section-title {
    font-family:'Space Mono',monospace;font-size:10px;letter-spacing:0.15em;
    color:rgba(255,255,255,0.15);margin-bottom:8px;
  }
  .lb-tag-list {
    display:flex;flex-wrap:wrap;gap:6px;
  }
  .lb-tag {
    background:rgba(255,170,0,0.1);border:1px solid rgba(255,170,0,0.25);
    color:rgba(255,170,0,0.6);font-family:'JetBrains Mono',monospace;
    font-size:11px;padding:5px 10px;border-radius:12px;
    display:flex;align-items:center;gap:6px;
  }
  .lb-tag-remove {
    cursor:pointer;opacity:0.6;font-size:13px;transition:opacity 0.2s;
  }
  .lb-tag-remove:hover { opacity:1; }
  .lb-tag-folder, .lb-folder-tag {
    background:rgba(100,180,255,0.08);border-color:rgba(100,180,255,0.2);
    color:rgba(100,180,255,0.5);
  }
  .lb-prop {
    display:inline-block;background:rgba(255,255,255,0.04);
    border:1px solid rgba(255,255,255,0.1);color:rgba(255,255,255,0.3);
    font-family:'JetBrains Mono',monospace;font-size:11px;
    padding:5px 10px;border-radius:6px;margin-right:6px;margin-bottom:6px;
  }
  .lb-prop-empty {
    color:rgba(255,255,255,0.12);font-style:italic;
  }
  .lb-no-tags {
    font-family:'JetBrains Mono',monospace;font-size:10px;
    color:rgba(255,255,255,0.12);font-style:italic;
  }
  .lb-add-tag-row {
    display:flex;gap:4px;margin-top:8px;
  }
  .lb-tag-input {
    flex:1;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);
    color:rgba(255,255,255,0.5);font-family:'JetBrains Mono',monospace;
    font-size:9px;padding:5px 8px;border-radius:4px;outline:none;
  }
  .lb-tag-input:focus { border-color:rgba(255,170,0,0.3); }
  .lb-add-btn {
    background:rgba(255,170,0,0.1);border:1px solid rgba(255,170,0,0.2);
    color:rgba(255,170,0,0.5);font-size:14px;width:28px;border-radius:4px;
    cursor:pointer;transition:all 0.2s;
  }
  .lb-add-btn:hover { background:rgba(255,170,0,0.15);color:rgba(255,170,0,0.7); }
  .lb-quick-row {
    display:flex;gap:4px;flex-wrap:wrap;
  }
  .lb-quick-btn {
    background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);
    color:rgba(255,255,255,0.25);font-family:'JetBrains Mono',monospace;
    font-size:8px;padding:4px 8px;border-radius:4px;cursor:pointer;transition:all 0.2s;
  }
  .lb-quick-btn:hover { background:rgba(255,255,255,0.06); }
  .lb-quick-btn.active {
    background:rgba(var(--btn-color,255,170,0),0.15);
    border-color:rgba(var(--btn-color,255,170,0),0.3);
    color:var(--btn-color,rgba(255,170,0,0.7));
  }

  /* Lightbox custom folders section */
  .lb-folders-section {
    border-top:1px solid rgba(255,255,255,0.06);margin-top:12px;padding-top:12px;
  }
  .lb-folders-header {
    display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;
  }
  .lb-folders-title {
    font-family:'Space Mono',monospace;font-size:10px;letter-spacing:0.1em;
    color:rgba(255,255,255,0.2);
  }
  .lb-add-folder-btn {
    background:rgba(255,170,0,0.08);border:1px solid rgba(255,170,0,0.2);
    color:rgba(255,170,0,0.5);font-size:12px;width:24px;height:24px;
    border-radius:4px;cursor:pointer;transition:all 0.15s;
  }
  .lb-add-folder-btn:hover { background:rgba(255,170,0,0.12);color:rgba(255,170,0,0.7); }
  
  .lb-folder-picker {
    display:none;margin-bottom:10px;padding:8px;
    background:rgba(255,255,255,0.02);border-radius:6px;
    max-height:150px;overflow-y:auto;
  }
  .lb-folder-picker.visible { display:block; }
  .lb-folder-picker-item {
    padding:6px 10px;font-family:'JetBrains Mono',monospace;font-size:11px;
    color:rgba(255,255,255,0.3);cursor:pointer;border-radius:4px;transition:all 0.15s;
  }
  .lb-folder-picker-item:hover { background:rgba(255,255,255,0.04);color:rgba(255,255,255,0.5); }
  .lb-folder-picker-item.added { color:rgba(255,255,255,0.15);cursor:default; }
  .lb-folder-picker-item.added:hover { background:transparent; }

  .lb-folders-list {
    max-height:200px;overflow-y:auto;
  }
  .lb-folders-list::-webkit-scrollbar { width:3px; }
  .lb-folders-list::-webkit-scrollbar-thumb { background:rgba(255,255,255,0.06);border-radius:2px; }
  
  .lb-folder-block {
    margin-bottom:12px;
  }
  .lb-folder-block-header {
    display:flex;align-items:center;gap:6px;margin-bottom:6px;
  }
  .lb-folder-block-name {
    font-family:'JetBrains Mono',monospace;font-size:10px;
    color:rgba(255,255,255,0.25);letter-spacing:0.05em;flex:1;
  }
  .lb-folder-block-remove {
    background:none;border:none;color:rgba(255,255,255,0.15);
    font-size:10px;cursor:pointer;padding:2px 4px;opacity:0;transition:all 0.15s;
  }
  .lb-folder-block:hover .lb-folder-block-remove { opacity:1; }
  .lb-folder-block-remove:hover { color:rgba(255,100,100,0.5); }
  
  .lb-folder-block-tags {
    display:flex;flex-wrap:wrap;gap:5px;
  }
  .lb-folder-tag-btn {
    background:rgba(100,180,255,0.06);border:1px solid rgba(100,180,255,0.15);
    color:rgba(100,180,255,0.4);font-family:'JetBrains Mono',monospace;
    font-size:10px;padding:4px 8px;border-radius:8px;cursor:pointer;transition:all 0.15s;
  }
  .lb-folder-tag-btn:hover { background:rgba(100,180,255,0.1);color:rgba(100,180,255,0.6); }
  .lb-folder-tag-btn.applied {
    background:rgba(100,255,150,0.1);border-color:rgba(100,255,150,0.25);
    color:rgba(100,255,150,0.6);
  }

  /* Mobile lightbox adjustments */
  @media (max-width: 700px) {
    .lightbox-container { flex-direction:column; }
    .lightbox-sidebar { width:100%;height:40%;border-left:none;border-top:1px solid rgba(255,255,255,0.05); }
    .lightbox-content { max-width:calc(100vw - 40px);max-height:calc(60vh - 80px); }
    .lightbox-nav { display:none; }
  }

  /* ═══ TAG DRAWER ═══ */
  .tag-drawer {
    position:absolute;top:0;left:0;width:280px;height:100%;
    background:rgba(8,8,10,0.98);border-right:1px solid rgba(255,255,255,0.06);
    transform:translateX(-100%);transition:transform 0.25s ease;
    display:flex;flex-direction:column;z-index:10;
  }
  .tag-drawer.open { transform:translateX(0); }
  .tag-drawer-toggle {
    position:absolute;top:50%;left:100%;transform:translateY(-50%);
    background:rgba(20,20,25,0.95);border:1px solid rgba(255,255,255,0.08);
    border-left:none;color:rgba(255,255,255,0.3);font-size:14px;
    padding:12px 8px;border-radius:0 6px 6px 0;cursor:pointer;
    transition:all 0.2s;writing-mode:vertical-rl;letter-spacing:0.1em;
    font-family:'JetBrains Mono',monospace;font-size:10px;
  }
  .tag-drawer-toggle:hover { background:rgba(30,30,35,0.95);color:rgba(255,255,255,0.5); }
  .tag-drawer.open .tag-drawer-toggle { border-radius:0 6px 6px 0; }
  
  .tag-drawer-header {
    padding:16px;border-bottom:1px solid rgba(255,255,255,0.05);
    display:flex;align-items:center;justify-content:space-between;gap:8px;
  }
  .tag-drawer-title {
    font-family:'Space Mono',monospace;font-size:13px;
    color:rgba(255,255,255,0.5);letter-spacing:0.12em;flex:1;
  }
  .tag-drawer-add {
    background:rgba(255,170,0,0.1);border:1px solid rgba(255,170,0,0.25);
    color:rgba(255,170,0,0.6);font-size:16px;width:28px;height:28px;
    border-radius:4px;cursor:pointer;transition:all 0.2s;
  }
  .tag-drawer-add:hover { background:rgba(255,170,0,0.15);color:rgba(255,170,0,0.8); }
  .tag-drawer-close {
    background:none;border:1px solid rgba(255,255,255,0.1);
    color:rgba(255,255,255,0.3);font-size:14px;width:28px;height:28px;
    border-radius:4px;cursor:pointer;transition:all 0.2s;
  }
  .tag-drawer-close:hover { border-color:rgba(255,255,255,0.2);color:rgba(255,255,255,0.5); }

  .tag-drawer-content {
    flex:1;overflow-y:auto;padding:8px 0;
  }
  .tag-drawer-content::-webkit-scrollbar { width:4px; }
  .tag-drawer-content::-webkit-scrollbar-thumb { background:rgba(255,255,255,0.06);border-radius:2px; }

  /* Folder styles */
  .tag-folder {
    margin-bottom:4px;
  }
  .tag-folder-header {
    display:flex;align-items:center;gap:8px;padding:10px 16px;
    cursor:pointer;transition:background 0.15s;
  }
  .tag-folder-header:hover { background:rgba(255,255,255,0.03); }
  .tag-folder-arrow {
    color:rgba(255,255,255,0.2);font-size:10px;transition:transform 0.2s;
    width:12px;text-align:center;
  }
  .tag-folder.collapsed .tag-folder-arrow { transform:rotate(-90deg); }
  .tag-folder-name {
    flex:1;font-family:'JetBrains Mono',monospace;font-size:12px;
    color:rgba(255,255,255,0.4);background:none;border:none;outline:none;
    cursor:pointer;padding:0;
  }
  .tag-folder-name:focus {
    color:rgba(255,255,255,0.7);cursor:text;
    border-bottom:1px solid rgba(255,170,0,0.3);
  }
  .tag-folder-count {
    font-family:'JetBrains Mono',monospace;font-size:10px;
    color:rgba(255,255,255,0.15);
  }
  .tag-folder-actions {
    display:flex;gap:4px;opacity:0;transition:opacity 0.15s;
  }
  .tag-folder-header:hover .tag-folder-actions { opacity:1; }
  .tag-folder-btn {
    background:none;border:none;color:rgba(255,255,255,0.2);
    font-size:12px;cursor:pointer;padding:2px 4px;transition:color 0.15s;
  }
  .tag-folder-btn:hover { color:rgba(255,255,255,0.5); }
  .tag-folder-btn.delete:hover { color:rgba(255,100,100,0.6); }

  .tag-folder-tags {
    padding:4px 16px 8px 36px;display:flex;flex-wrap:wrap;gap:6px;
  }
  .tag-folder.collapsed .tag-folder-tags { display:none; }
  
  .drawer-tag {
    background:rgba(255,170,0,0.08);border:1px solid rgba(255,170,0,0.2);
    color:rgba(255,170,0,0.5);font-family:'JetBrains Mono',monospace;
    font-size:11px;padding:4px 10px;border-radius:10px;cursor:pointer;
    transition:all 0.15s;display:flex;align-items:center;gap:6px;
  }
  .drawer-tag:hover { background:rgba(255,170,0,0.12);color:rgba(255,170,0,0.7); }
  .drawer-tag.active {
    background:rgba(255,170,0,0.2);border-color:rgba(255,170,0,0.4);
    color:rgba(255,170,0,0.9);
  }
  .drawer-tag-remove {
    font-size:12px;opacity:0.5;transition:opacity 0.15s;
  }
  .drawer-tag-remove:hover { opacity:1; }

  /* Uncategorized section */
  .tag-uncategorized {
    border-top:1px solid rgba(255,255,255,0.04);margin-top:8px;padding-top:8px;
  }
  .tag-uncategorized-header {
    padding:10px 16px;display:flex;align-items:center;gap:8px;cursor:pointer;
  }
  .tag-uncategorized-header:hover { background:rgba(255,255,255,0.02); }
  .tag-uncategorized-title {
    font-family:'JetBrains Mono',monospace;font-size:11px;
    color:rgba(255,255,255,0.2);letter-spacing:0.05em;
  }
  .tag-uncategorized-tags {
    padding:4px 16px 12px;display:flex;flex-wrap:wrap;gap:6px;
  }
  .tag-uncategorized.collapsed .tag-uncategorized-tags { display:none; }
  .uncategorized-tag {
    background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);
    color:rgba(255,255,255,0.25);font-family:'JetBrains Mono',monospace;
    font-size:11px;padding:4px 10px;border-radius:10px;cursor:grab;
    transition:all 0.15s;
  }
  .uncategorized-tag:hover { background:rgba(255,255,255,0.06);color:rgba(255,255,255,0.4); }
  .uncategorized-tag:active { cursor:grabbing; }
  .uncategorized-tag.active {
    background:rgba(255,170,0,0.15);border-color:rgba(255,170,0,0.3);
    color:rgba(255,170,0,0.7);
  }
  .uncategorized-tag.dragging {
    opacity:0.5;background:rgba(255,170,0,0.1);border-color:rgba(255,170,0,0.3);
    color:rgba(255,170,0,0.6);
  }

  /* Add folder input */
  .tag-folder-input-row {
    padding:8px 16px;display:none;
  }
  .tag-folder-input-row.visible { display:flex;gap:6px; }
  .tag-folder-input {
    flex:1;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.1);
    color:rgba(255,255,255,0.6);font-family:'JetBrains Mono',monospace;
    font-size:12px;padding:8px 10px;border-radius:4px;outline:none;
  }
  .tag-folder-input:focus { border-color:rgba(255,170,0,0.3); }
  .tag-folder-input-btn {
    background:rgba(255,170,0,0.1);border:1px solid rgba(255,170,0,0.2);
    color:rgba(255,170,0,0.5);font-size:14px;width:32px;border-radius:4px;
    cursor:pointer;transition:all 0.15s;
  }
  .tag-folder-input-btn:hover { background:rgba(255,170,0,0.15);color:rgba(255,170,0,0.7); }

  /* Mobile adjustments */
  @media (max-width: 600px) {
    .tag-drawer { width:260px; }
  }

  /* Load more button */
  .lib-load-more {
    grid-column:1/-1;display:flex;flex-direction:column;align-items:center;
    padding:20px;gap:6px;
  }
  .lib-load-more-btn {
    background:rgba(255,170,0,0.06);border:1px solid rgba(255,170,0,0.15);
    color:rgba(255,170,0,0.5);font-family:'Space Mono',monospace;
    font-size:11px;padding:10px 24px;border-radius:6px;cursor:pointer;
    letter-spacing:0.1em;transition:all 0.2s;
  }
  .lib-load-more-btn:hover {
    background:rgba(255,170,0,0.1);border-color:rgba(255,170,0,0.25);
    color:rgba(255,170,0,0.7);
  }
  .lib-load-more-count {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    color:rgba(255,255,255,0.08);letter-spacing:0.06em;
  }

  /* Thumbnail placeholder */
  .lib-thumb {
    width:100%;height:100%;object-fit:cover;display:block;
    filter:brightness(0.85);transition:filter 0.2s;
    background:#111;
  }
  .lib-thumb[src=""] {
    background:linear-gradient(135deg,#0a0a0a 0%,#151515 100%);
  }

  /* Tag detail panel (shows when items selected) */
  .lib-tag-detail {
    padding:10px 20px;flex-shrink:0;max-height:0;overflow:hidden;
    transition:max-height 0.3s ease,padding 0.3s ease;
    border-top:1px solid rgba(255,255,255,0.03);
  }
  .lib-tag-detail.open { max-height:250px;padding:10px 20px; }
  .lib-tag-detail-title {
    font-family:'Space Mono',monospace;font-size:8px;
    color:rgba(255,255,255,0.15);letter-spacing:0.15em;
    text-transform:uppercase;margin-bottom:6px;
  }
  .lib-tag-list {
    display:flex;flex-wrap:wrap;gap:4px;margin-bottom:8px;
  }
  .lib-tag-pill {
    background:rgba(255,170,0,0.06);border:1px solid rgba(255,170,0,0.15);
    color:rgba(255,170,0,0.5);font-family:'JetBrains Mono',monospace;
    font-size:8px;padding:2px 8px;border-radius:10px;
    display:flex;align-items:center;gap:4px;
  }
  .lib-tag-pill .remove-tag {
    cursor:pointer;opacity:0.4;transition:opacity 0.2s;font-size:10px;
  }
  .lib-tag-pill .remove-tag:hover { opacity:1; }
  .lib-folder-tag {
    background:rgba(100,200,255,0.04);border-color:rgba(100,200,255,0.12);
    color:rgba(100,200,255,0.4);
  }

  /* Footer */
  .lib-footer {
    padding:8px 20px;flex-shrink:0;display:flex;justify-content:space-between;
    align-items:center;border-top:1px solid rgba(255,255,255,0.04);
    gap:8px;
  }
  .lib-footer-btn {
    background:none;border:1px solid rgba(255,255,255,0.08);
    color:rgba(255,255,255,0.2);font-family:'JetBrains Mono',monospace;
    font-size:8px;padding:5px 12px;border-radius:4px;cursor:pointer;
    letter-spacing:0.06em;transition:all 0.2s;
  }
  .lib-footer-btn:hover { border-color:rgba(255,255,255,0.2);color:rgba(255,255,255,0.4); }

  /* ═══ CONTENT PANELS (Real content) ═══ */
  .content-panel {
    position: fixed; z-index: 3;
    border: 1px solid rgba(255,45,123,0.1);
    background: transparent;
    display: flex; align-items: center; justify-content: center;
    transition: opacity 0.6s ease, transform 0.5s;
    overflow: visible;
  }
  .content-panel img, .content-panel video {
    clip-path: inset(0);
  }
  }
  .content-panel img, .content-panel video {
    width: 100%; height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.5s ease;
  }
  .content-panel img.loaded, .content-panel video.loaded {
    opacity: 1;
  }
  .content-panel .panel-id {
    position: absolute; top: 4px; left: 6px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 8px; color: rgba(255,45,123,0.2);
    z-index: 2;
  }
  .content-panel .placeholder-text {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px; color: rgba(255,255,255,0.08);
    letter-spacing: 0.1em;
  }

  /* ═══ FLASH DISPLAY MODE ═══ */
  .flash-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 40;
    pointer-events: none; opacity: 0;
    display: flex; align-items: center; justify-content: center;
    background: rgba(0,0,0,0.5);
    transition: opacity 0.15s ease;
  }
  .flash-overlay.active { opacity: 1; }
  .flash-overlay img, .flash-overlay video {
    max-width: 85vw; max-height: 85vh;
    object-fit: contain;
    border: 1px solid rgba(255,45,123,0.2);
    box-shadow: 0 0 40px rgba(255,45,123,0.15);
  }

  /* ═══ FULL-TAKE MODE ═══ */
  .fulltake-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 42;
    pointer-events: none; opacity: 0;
    transition: opacity 0.6s ease;
  }
  .fulltake-overlay.active { opacity: 1; }
  .fulltake-overlay img, .fulltake-overlay video {
    width: 100%; height: 100%;
    object-fit: contain;
    background: black;
  }

  /* ═══ HUD ═══ */
  .session-timer {
    position: fixed; top: 20px; left: 20px;
    z-index: 20; font-family: 'Space Mono', monospace;
    font-size: 10px; color: rgba(255,255,255,0.15); letter-spacing: 0.15em;
  }
  .phase-indicator {
    position: fixed; top: 20px; right: 20px;
    z-index: 20; font-family: 'Space Mono', monospace;
    font-size: 10px; color: rgba(255,255,255,0.2);
    letter-spacing: 0.2em; text-transform: uppercase; text-align: right;
  }
  .phase-indicator .phase-name { color: var(--neon-pink); font-size: 11px; margin-bottom: 4px; }
  .control-meter {
    position: fixed; left: 20px; top: 50%;
    transform: translateY(-50%); z-index: 20;
    width: 3px; height: 200px;
    background: rgba(255,255,255,0.05); border-radius: 2px;
  }
  .control-meter-fill {
    position: absolute; bottom: 0; width: 100%;
    background: linear-gradient(to top, var(--neon-pink), var(--neon-purple));
    border-radius: 2px; transition: height 1s ease;
    box-shadow: 0 0 8px var(--neon-pink);
  }
  .control-meter-label {
    position: absolute; bottom: -25px; left: 50%;
    font-family: 'Space Mono', monospace; font-size: 8px;
    color: rgba(255,255,255,0.2);
    writing-mode: vertical-lr; letter-spacing: 0.3em;
    text-transform: uppercase; white-space: nowrap;
    transform: translateX(-50%) rotate(180deg);
  }
  .trance-indicator {
    position: fixed; right: 20px; top: 50%;
    transform: translateY(-50%); z-index: 20;
    width: 3px; height: 200px;
    background: rgba(255,255,255,0.05); border-radius: 2px;
  }
  .trance-indicator-fill {
    position: absolute; bottom: 0; width: 100%;
    background: linear-gradient(to top, var(--neon-cyan), var(--neon-purple));
    border-radius: 2px; transition: height 2s ease;
    box-shadow: 0 0 8px var(--neon-cyan);
  }
  .trance-indicator-label {
    position: absolute; bottom: -25px; left: 50%;
    font-family: 'Space Mono', monospace; font-size: 8px;
    color: rgba(255,255,255,0.2);
    writing-mode: vertical-lr; letter-spacing: 0.3em;
    text-transform: uppercase; white-space: nowrap;
    transform: translateX(-50%) rotate(180deg);
  }
  .wave-indicator {
    position: fixed; bottom: 15px; right: 20px;
    z-index: 20; font-family: 'Space Mono', monospace;
    font-size: 9px; color: rgba(255,255,255,0.12); letter-spacing: 0.15em;
  }
  .safe-word-hint {
    position: fixed; bottom: 10px; left: 50%;
    transform: translateX(-50%); z-index: 20;
    font-family: 'Space Mono', monospace;
    font-size: 8px; letter-spacing: 0.2em;
    color: rgba(255,255,255,0.06); text-transform: uppercase;
    transition: color 0.3s;
  }
  .safe-word-hint:hover { color: rgba(255,255,255,0.2); }

  /* ═══ AFTERCARE — VICTORY ROYALE ACHIEVEMENT SCREEN ═══ */
  /* ═══ SESSION HISTORY PANEL ═══ */
  .history-panel {
    cursor: default;
    position:fixed;top:0;left:0;width:100%;height:100%;z-index:201;
    background:rgba(3,3,4,0.97);display:none;flex-direction:column;
    align-items:center;overflow-y:auto;-webkit-overflow-scrolling:touch;
    padding:40px 20px 60px;
  }
  .history-panel.visible { display:flex; }
  .history-header {
    font-family:'Bebas Neue',sans-serif;font-size:clamp(1.5rem,4vw,2.5rem);
    letter-spacing:0.2em;color:var(--neon-pink);margin-bottom:4px;
  }
  .history-sub {
    font-family:'Space Mono',monospace;font-size:9px;letter-spacing:0.25em;
    color:rgba(255,255,255,0.2);text-transform:uppercase;margin-bottom:24px;
  }
  .history-empty {
    font-family:'JetBrains Mono',monospace;font-size:12px;
    color:rgba(255,255,255,0.15);margin-top:40px;letter-spacing:0.1em;
  }
  .history-card {
    width:min(400px,90%);border:1px solid rgba(255,170,0,0.1);
    border-radius:6px;padding:14px 16px;margin-bottom:10px;
    background:rgba(255,170,0,0.02);transition:border-color 0.3s;
  }
  .history-card:first-of-type { border-color:rgba(255,170,0,0.25); }
  .history-card-head {
    display:flex;justify-content:space-between;align-items:baseline;margin-bottom:8px;
  }
  .history-card-rank {
    font-family:'Bebas Neue',sans-serif;font-size:clamp(0.8rem,2vw,1rem);
    letter-spacing:0.1em;
  }
  .history-card-date {
    font-family:'Space Mono',monospace;font-size:8px;letter-spacing:0.1em;
    color:rgba(255,255,255,0.2);
  }
  .history-card-stats {
    display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;
  }
  .history-card-stat {
    text-align:center;padding:6px 2px;
    border:1px solid rgba(255,255,255,0.04);border-radius:3px;
  }
  .history-card-stat .sv {
    font-family:'Bebas Neue',sans-serif;font-size:clamp(0.9rem,2vw,1.2rem);
    color:#ffd700;
  }
  .history-card-stat .sl {
    font-family:'Space Mono',monospace;font-size:6px;letter-spacing:0.15em;
    color:rgba(255,255,255,0.15);text-transform:uppercase;
  }
  .history-card-stat { position:relative;cursor:help; }
  .history-card-stat .stat-tip {
    display:none;position:absolute;bottom:calc(100% + 6px);left:50%;
    transform:translateX(-50%);background:rgba(20,10,30,0.95);
    border:1px solid rgba(255,170,0,0.2);border-radius:4px;
    padding:6px 10px;font-family:'JetBrains Mono',monospace;
    font-size:9px;color:rgba(255,255,255,0.5);white-space:nowrap;
    z-index:10;pointer-events:none;letter-spacing:0.05em;
  }
  .history-card-stat:hover .stat-tip,
  .history-card-stat:active .stat-tip { display:block; }
  .history-close {
    font-family:'JetBrains Mono',monospace;font-size:12px;
    letter-spacing:0.3em;text-transform:uppercase;
    color:var(--neon-cyan);background:transparent;
    border:1px solid rgba(0,240,255,0.3);padding:10px 30px;
    cursor:pointer;margin-top:20px;
  }

  /* ═══ ENTRY SCREEN PROFILE LINE ═══ */
  .entry-profile {
    font-family:'Space Mono',monospace;font-size:9px;
    letter-spacing:0.15em;color:rgba(255,255,255,0.18);
    text-transform:uppercase;margin-top:-8px;
    transition:color 0.5s;cursor:pointer;
  }
  .entry-profile:hover { color:rgba(255,255,255,0.35); }
  .entry-profile .ep-val { color:rgba(255,170,0,0.5); }

  /* === Level + XP Bar on entry screen === */
  .entry-level-block {
    margin:8px 0 2px;text-align:center;
  }
  .entry-level-title {
    font-family:'Space Mono',monospace;font-size:11px;
    letter-spacing:0.2em;font-weight:700;
    transition:color 0.3s;
  }
  .entry-level-sub {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    color:rgba(255,255,255,0.15);letter-spacing:0.1em;
    margin-top:2px;
  }
  .entry-xp-bar {
    width:160px;height:4px;background:rgba(255,255,255,0.05);
    border-radius:2px;margin:6px auto 0;overflow:hidden;
  }
  .entry-xp-fill {
    height:100%;border-radius:2px;width:0%;
    transition:width 0.6s ease;
    background:linear-gradient(90deg,rgba(255,170,0,0.5),rgba(255,45,123,0.5));
  }
  .entry-corruption {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    color:rgba(255,45,123,0.25);letter-spacing:0.1em;
    margin-top:4px;
  }
  .entry-greeting {
    font-family:'JetBrains Mono',monospace;font-size:10px;
    color:rgba(255,255,255,0.15);letter-spacing:0.06em;
    margin:6px 0;font-style:italic;min-height:14px;
  }
  .entry-streak {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    color:rgba(255,170,0,0.2);letter-spacing:0.08em;
  }

  /* === Aftercare XP + Level section === */
  .aftercare-xp-section {
    margin:12px 0 6px;text-align:center;
  }
  .aftercare-xp-earned {
    font-family:'Space Mono',monospace;font-size:18px;
    color:rgba(255,170,0,0);letter-spacing:0.1em;
    font-weight:700;transition:color 1.5s ease 3s;
  }
  .aftercare-xp-earned.visible { color:rgba(255,170,0,0.7); }
  .aftercare-xp-label {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    color:rgba(255,255,255,0);letter-spacing:0.15em;
    text-transform:uppercase;margin-top:2px;
    transition:color 1.5s ease 3.2s;
  }
  .aftercare-xp-label.visible { color:rgba(255,255,255,0.15); }
  .aftercare-level-bar {
    width:200px;height:6px;background:rgba(255,255,255,0.05);
    border-radius:3px;margin:8px auto;overflow:hidden;
  }
  .aftercare-level-fill {
    height:100%;border-radius:3px;width:0%;
    transition:width 1.5s ease 3.5s;
    background:linear-gradient(90deg,rgba(255,170,0,0.6),rgba(255,45,123,0.6));
  }
  .aftercare-level-label {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    color:rgba(255,255,255,0);letter-spacing:0.08em;
    margin-bottom:4px;transition:color 1.5s ease 3.4s;
  }
  .aftercare-level-label.visible { color:rgba(255,255,255,0.15); }
  .aftercare-corruption-delta {
    font-family:'JetBrains Mono',monospace;font-size:9px;
    letter-spacing:0.08em;margin-top:4px;
    color:rgba(255,255,255,0);transition:color 1.5s ease 4s;
  }
  .aftercare-corruption-delta.visible { color:rgba(255,45,123,0.3); }

  /* Level-up notification */
  .levelup-notification {
    position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0.8);
    z-index:310;background:rgba(0,0,0,0.95);
    border:2px solid rgba(255,170,0,0.4);border-radius:12px;
    padding:30px 50px;text-align:center;
    opacity:0;transition:opacity 0.5s ease,transform 0.5s ease;
    pointer-events:none;
  }
  .levelup-notification.active {
    opacity:1;transform:translate(-50%,-50%) scale(1);
  }
  .levelup-flash {
    font-family:'Space Mono',monospace;font-size:10px;
    color:rgba(255,170,0,0.5);letter-spacing:0.3em;
    text-transform:uppercase;margin-bottom:8px;
  }
  .levelup-title {
    font-family:'Space Mono',monospace;font-size:24px;
    font-weight:700;letter-spacing:0.15em;
    text-shadow:0 0 30px currentColor;
  }
  .levelup-sub {
    font-family:'JetBrains Mono',monospace;font-size:9px;
    color:rgba(255,255,255,0.2);letter-spacing:0.1em;
    margin-top:8px;
  }

  /* === Achievement Toast (aftercare) === */
  .achievement-toast-container {
    position:fixed;bottom:40px;left:50%;transform:translateX(-50%);
    z-index:320;display:flex;flex-direction:column;align-items:center;gap:8px;
    pointer-events:none;
  }
  .achievement-toast {
    background:rgba(0,0,0,0.92);border:1px solid rgba(255,170,0,0.35);
    border-radius:8px;padding:10px 20px;display:flex;align-items:center;gap:12px;
    opacity:0;transform:translateY(20px) scale(0.9);
    transition:opacity 0.5s ease,transform 0.5s ease;
    pointer-events:auto;max-width:320px;
  }
  .achievement-toast.visible {
    opacity:1;transform:translateY(0) scale(1);
  }
  .achievement-toast-icon {
    font-size:24px;flex-shrink:0;
  }
  .achievement-toast-info {
    display:flex;flex-direction:column;gap:2px;
  }
  .achievement-toast-label {
    font-family:'JetBrains Mono',monospace;font-size:7px;
    color:rgba(255,170,0,0.5);letter-spacing:0.2em;text-transform:uppercase;
  }
  .achievement-toast-name {
    font-family:'Space Mono',monospace;font-size:11px;
    color:rgba(255,255,255,0.7);letter-spacing:0.08em;font-weight:700;
  }
  .achievement-toast-desc {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    color:rgba(255,255,255,0.2);letter-spacing:0.05em;
  }

  /* === Achievement Gallery (settings) === */
  .achievement-gallery {
    max-height:0;overflow:hidden;transition:max-height 0.5s ease;
    margin-top:8px;
  }
  .achievement-gallery.open { max-height:2000px; }
  .ach-gallery-toggle {
    width:100%;background:none;border:1px solid rgba(255,170,0,0.15);
    color:rgba(255,170,0,0.4);font-family:'Space Mono',monospace;
    font-size:10px;letter-spacing:0.15em;padding:8px 16px;
    border-radius:6px;cursor:pointer;text-transform:uppercase;
    transition:border-color 0.3s,color 0.3s;
  }
  .ach-gallery-toggle:hover { border-color:rgba(255,170,0,0.3);color:rgba(255,170,0,0.6); }
  .ach-gallery-header {
    display:flex;justify-content:space-between;align-items:center;
    margin-bottom:8px;
  }
  .ach-gallery-count {
    font-family:'JetBrains Mono',monospace;font-size:9px;
    color:rgba(255,255,255,0.15);letter-spacing:0.08em;
  }
  .ach-category-title {
    font-family:'Space Mono',monospace;font-size:8px;
    letter-spacing:0.2em;text-transform:uppercase;
    margin:12px 0 6px;padding-bottom:3px;
    border-bottom:1px solid rgba(255,255,255,0.05);
  }
  .ach-grid {
    display:grid;grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:6px;
  }
  .ach-item {
    display:flex;align-items:center;gap:10px;padding:8px 10px;
    border-radius:6px;border:1px solid rgba(255,255,255,0.04);
    background:rgba(255,255,255,0.01);transition:border-color 0.3s;
  }
  .ach-item.unlocked { border-color:rgba(255,170,0,0.12);background:rgba(255,170,0,0.02); }
  .ach-item.locked { opacity:0.35; }
  .ach-icon { font-size:20px;flex-shrink:0;width:28px;text-align:center; }
  .ach-item.locked .ach-icon { filter:grayscale(1); }
  .ach-info { display:flex;flex-direction:column;gap:1px;min-width:0; }
  .ach-name {
    font-family:'Space Mono',monospace;font-size:10px;
    color:rgba(255,255,255,0.5);letter-spacing:0.05em;font-weight:700;
  }
  .ach-item.unlocked .ach-name { color:rgba(255,255,255,0.7); }
  .ach-desc {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    color:rgba(255,255,255,0.15);letter-spacing:0.03em;
  }
  .ach-xp {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    color:rgba(255,170,0,0.3);letter-spacing:0.05em;margin-left:auto;flex-shrink:0;
  }
  .ach-item.unlocked .ach-xp { color:rgba(255,170,0,0.5); }

  /* === Aftercare achievements section === */
  .aftercare-achievements {
    margin-top:6px;text-align:center;min-height:0;
  }

  /* === Aftercare tracks section === */
  .aftercare-tracks {
    width:min(280px,85vw);margin:8px auto 0;
  }
  .aftercare-tracks-title {
    font-family:'Space Mono',monospace;font-size:7px;
    color:rgba(255,255,255,0);letter-spacing:0.25em;
    text-transform:uppercase;text-align:center;margin-bottom:6px;
    transition:color 1.5s ease 4.5s;
  }
  .aftercare-tracks-title.visible { color:rgba(255,255,255,0.12); }
  .aftercare-track-row {
    display:flex;align-items:center;gap:8px;margin-bottom:5px;
    opacity:0;transform:translateY(6px);transition:opacity 0.6s ease,transform 0.6s ease;
  }
  .aftercare-track-row.visible { opacity:1;transform:translateY(0); }
  .aftercare-track-icon { font-size:14px;flex-shrink:0;width:20px;text-align:center; }
  .aftercare-track-info { flex:1;min-width:0; }
  .aftercare-track-meta {
    display:flex;justify-content:space-between;align-items:baseline;margin-bottom:2px;
  }
  .aftercare-track-name {
    font-family:'Space Mono',monospace;font-size:8px;
    color:rgba(255,255,255,0.3);letter-spacing:0.08em;
  }
  .aftercare-track-xp-gained {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    color:rgba(255,170,0,0.4);letter-spacing:0.05em;
  }
  .aftercare-track-bar {
    height:3px;background:rgba(255,255,255,0.04);border-radius:2px;overflow:hidden;
  }
  .aftercare-track-fill {
    height:100%;border-radius:2px;width:0%;transition:width 1.2s ease;
  }
  .aftercare-track-tier-label {
    font-family:'JetBrains Mono',monospace;font-size:7px;
    color:rgba(255,255,255,0.1);letter-spacing:0.05em;margin-top:1px;
  }
  .aftercare-track-tierup {
    font-family:'Space Mono',monospace;font-size:8px;
    letter-spacing:0.1em;font-weight:700;margin-top:2px;
    animation:trackTierPulse 1.5s ease infinite;
  }
  @keyframes trackTierPulse {
    0%,100% { opacity:0.6; } 50% { opacity:1; }
  }

  /* === Settings tracks panel === */
  .tracks-panel {
    margin-top:8px;
  }
  .track-card {
    border:1px solid rgba(255,255,255,0.05);border-radius:8px;
    padding:12px 14px;margin-bottom:8px;background:rgba(255,255,255,0.01);
    transition:border-color 0.3s;
  }
  .track-card-header {
    display:flex;align-items:center;gap:10px;margin-bottom:6px;
  }
  .track-card-icon { font-size:20px; }
  .track-card-name {
    font-family:'Space Mono',monospace;font-size:11px;
    letter-spacing:0.1em;font-weight:700;
  }
  .track-card-tier {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    letter-spacing:0.08em;margin-left:auto;
  }
  .track-card-desc {
    font-family:'JetBrains Mono',monospace;font-size:8px;
    color:rgba(255,255,255,0.15);letter-spacing:0.03em;
    margin-bottom:6px;
  }
  .track-card-bar {
    height:4px;background:rgba(255,255,255,0.04);border-radius:2px;
    overflow:hidden;margin-bottom:4px;
  }
  .track-card-fill {
    height:100%;border-radius:2px;transition:width 0.6s ease;
  }
  .track-card-xp {
    font-family:'JetBrains Mono',monospace;font-size:7px;
    color:rgba(255,255,255,0.1);letter-spacing:0.05em;
    display:flex;justify-content:space-between;
  }
  .track-inactive {
    font-family:'JetBrains Mono',monospace;font-size:9px;
    color:rgba(255,255,255,0.08);letter-spacing:0.06em;
    text-align:center;padding:12px;font-style:italic;
  }

  /* ═══ AFTERCARE COMPARISON ═══ */
  .aftercare-comparison {
    font-family:'Space Mono',monospace;font-size:8px;letter-spacing:0.1em;
    color:rgba(255,255,255,0);margin-top:10px;text-align:center;
    transition:color 2s ease 5s;line-height:2;
  }
  .aftercare-overlay.active .aftercare-comparison { color:rgba(255,255,255,0.14); }
  .aftercare-comparison .cmp-up { color:rgba(100,255,100,0.4); }
  .aftercare-comparison .cmp-down { color:rgba(255,100,100,0.3); }
  .aftercare-comparison .cmp-same { color:rgba(255,255,255,0.2); }
  .aftercare-session-num {
    font-family:'Space Mono',monospace;font-size:8px;letter-spacing:0.3em;
    color:rgba(255,255,255,0);margin-top:8px;
    transition:color 1.5s ease 4s;text-transform:uppercase;
  }
  .aftercare-overlay.active .aftercare-session-num { color:rgba(255,255,255,0.12); }

  .aftercare-overlay {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%; z-index: 95;
    background: radial-gradient(ellipse at center, rgba(15,5,25,0.97) 0%, rgba(0,0,0,1) 100%);
    pointer-events: none; opacity: 0; transition: opacity 3s ease;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center; gap: 0;
    overflow: hidden;
  }
  .aftercare-overlay.active { opacity: 1; pointer-events: auto; }

  .aftercare-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(2.5rem, 8vw, 6rem);
    letter-spacing: 0.15em; text-transform: uppercase;
    color: transparent; text-align: center;
    background: linear-gradient(135deg, #ffd700 0%, #ffaa00 25%, #ff6b00 50%, #ffd700 75%, #ffaa00 100%);
    background-size: 200% 200%;
    animation: goldShimmer 3s ease-in-out infinite;
    -webkit-background-clip: text; background-clip: text;
    opacity: 0; transform: scale(0.5) translateY(30px);
    transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1) 0.5s;
    filter: drop-shadow(0 0 20px rgba(255,170,0,0.4)) drop-shadow(0 0 60px rgba(255,100,0,0.2));
  }
  .aftercare-overlay.active .aftercare-title { opacity: 1; transform: scale(1) translateY(0); }
  @keyframes goldShimmer {
    0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; }
  }

  .aftercare-subtitle {
    font-family: 'Space Mono', monospace;
    font-size: clamp(0.6rem, 1.5vw, 0.8rem);
    letter-spacing: 0.3em; text-transform: uppercase;
    color: rgba(255,200,140,0); transition: color 2s ease 1.5s;
    margin-top: 8px; text-align: center;
  }
  .aftercare-overlay.active .aftercare-subtitle { color: rgba(255,200,140,0.45); }

  .aftercare-divider {
    width: 120px; height: 1px;
    background: linear-gradient(90deg, transparent, rgba(255,170,0,0.3), transparent);
    margin: 18px 0; opacity: 0; transition: opacity 1s ease 2s;
  }
  .aftercare-overlay.active .aftercare-divider { opacity: 1; }

  .aftercare-stats-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 10px 20px;
    max-width: 360px; width: 85%;
    opacity: 0; transform: translateY(20px);
    transition: all 1s ease 2.2s;
  }
  .aftercare-overlay.active .aftercare-stats-grid { opacity: 1; transform: translateY(0); }
  .stat-item {
    text-align: center; padding: 10px 6px;
    border: 1px solid rgba(255,170,0,0.08);
    border-radius: 4px; background: rgba(255,170,0,0.02);
    position:relative;cursor:help;
  }
  .stat-item .stat-tip {
    display:none;position:absolute;bottom:calc(100% + 6px);left:50%;
    transform:translateX(-50%);background:rgba(20,10,30,0.95);
    border:1px solid rgba(255,170,0,0.2);border-radius:4px;
    padding:6px 10px;font-family:'JetBrains Mono',monospace;
    font-size:9px;color:rgba(255,255,255,0.5);white-space:nowrap;
    z-index:10;pointer-events:none;letter-spacing:0.05em;
  }
  .stat-item:hover .stat-tip { display:block; }
  .stat-value {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(1.4rem, 3.5vw, 2.2rem);
    letter-spacing: 0.05em; color: #ffd700;
    text-shadow: 0 0 10px rgba(255,215,0,0.3);
  }
  .stat-label {
    font-family: 'Space Mono', monospace;
    font-size: 7px; letter-spacing: 0.2em;
    text-transform: uppercase; color: rgba(255,255,255,0.2);
    margin-top: 3px;
  }

  .aftercare-rank {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(0.8rem, 2vw, 1.1rem);
    letter-spacing: 0.2em; text-transform: uppercase;
    color: rgba(255,170,0,0); margin-top: 18px;
    transition: color 1.5s ease 3.5s; text-align: center;
    text-shadow: 0 0 15px rgba(255,170,0,0.2);
  }
  .aftercare-overlay.active .aftercare-rank { color: rgba(255,170,0,0.5); }

  .aftercare-care {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px; letter-spacing: 0.15em;
    color: rgba(255,255,255,0); margin-top: 20px;
    transition: color 2s ease 4.5s; text-align: center; line-height: 2.2;
  }
  .aftercare-overlay.active .aftercare-care { color: rgba(255,255,255,0.18); }

  .aftercare-exit {
    font-family: 'Space Mono', monospace;
    font-size: 8px; letter-spacing: 0.3em;
    text-transform: uppercase;
    color: rgba(255,255,255,0); margin-top: 20px;
    transition: color 1s ease 7s;
  }
  .aftercare-overlay.active .aftercare-exit { color: rgba(255,255,255,0.1); }

  /* ═══ PERMISSION SYSTEM ═══ */
  .permission-overlay {
    position:fixed;top:0;left:0;width:100%;height:100%;z-index:80;
    pointer-events:none;opacity:0;transition:opacity 0.8s ease;
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    background:radial-gradient(ellipse at center,rgba(0,0,0,0.85) 0%,rgba(0,0,0,0.95) 100%);
  }
  .permission-overlay.active { opacity:1; pointer-events:auto; }
  .permission-question {
    font-family:'Bebas Neue',sans-serif;
    font-size:clamp(1.8rem,5vw,3.5rem);
    letter-spacing:0.12em;text-transform:uppercase;
    color:var(--neon-pink);text-align:center;
    text-shadow:0 0 20px var(--neon-pink),0 0 60px rgba(255,45,123,0.3);
    opacity:0;transform:scale(0.9);transition:all 0.8s ease;
    margin-bottom:30px;
  }
  .permission-overlay.active .permission-question { opacity:1;transform:scale(1); }
  .permission-btn {
    font-family:'Bebas Neue',sans-serif;font-size:clamp(1rem,3vw,1.8rem);
    letter-spacing:0.3em;color:white;border:1px solid rgba(255,255,255,0.3);
    background:transparent;padding:15px 50px;cursor:pointer;
    text-transform:uppercase;transition:all 0.3s;
    text-shadow:0 0 10px rgba(255,255,255,0.3);
    animation:permissionPulse 2s ease-in-out infinite;
  }
  .permission-btn:hover,.permission-btn:active {
    border-color:var(--neon-pink);color:var(--neon-pink);
    box-shadow:0 0 30px rgba(255,45,123,0.3);
  }
  @keyframes permissionPulse {
    0%,100%{border-color:rgba(255,255,255,0.2);} 50%{border-color:rgba(255,255,255,0.5);}
  }
  .permission-sub {
    font-family:'Space Mono',monospace;font-size:10px;
    letter-spacing:0.2em;color:rgba(255,255,255,0.15);
    margin-top:20px;opacity:0;transition:opacity 1s ease 0.5s;
  }
  .permission-overlay.active .permission-sub { opacity:1; }

  /* Denial flash */
  .denial-overlay {
    position:fixed;top:0;left:0;width:100%;height:100%;z-index:85;
    pointer-events:none;opacity:0;transition:opacity 0.5s ease;
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    background:radial-gradient(ellipse at center,rgba(30,0,0,0.9) 0%,rgba(0,0,0,0.95) 100%);
  }
  .denial-overlay.active { opacity:1; }
  .denial-text {
    font-family:'Bebas Neue',sans-serif;
    font-size:clamp(2rem,7vw,5rem);
    letter-spacing:0.15em;text-transform:uppercase;
    color:#ff1111;text-align:center;
    text-shadow:0 0 30px #ff1111,0 0 80px rgba(255,0,0,0.4);
  }
  .denial-sub {
    font-family:'Space Mono',monospace;font-size:clamp(0.7rem,2vw,1rem);
    letter-spacing:0.15em;color:rgba(255,255,255,0.35);
    margin-top:20px;text-align:center;max-width:80vw;
  }

  /* RELEASE phase */
  .release-overlay {
    position:fixed;top:0;left:0;width:100%;height:100%;z-index:90;
    pointer-events:none;opacity:0;transition:opacity 0.3s ease;
    display:flex;align-items:center;justify-content:center;
    background:black;
  }
  .release-overlay.active { opacity:1; }
  .release-text {
    font-family:'Bebas Neue',sans-serif;
    font-size:clamp(3rem,10vw,8rem);
    letter-spacing:0.2em;text-transform:uppercase;
    color:white;text-shadow:0 0 40px white,0 0 100px rgba(255,255,255,0.5);
    animation:releaseFlash 0.15s steps(1) infinite;
  }
  @keyframes releaseFlash {
    0%{opacity:1;} 50%{opacity:0.7;} 100%{opacity:1;}
  }

  /* Poppers prompt */
  .poppers-overlay {
    position:fixed;top:0;left:0;width:100%;height:100%;z-index:76;
    pointer-events:none;opacity:0;transition:opacity 0.6s ease;
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    background:transparent;
  }
  .poppers-overlay.active { opacity:1; }
  /* Frosted dark band across the center for text readability */
  .poppers-band {
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    width:100%;padding:40px 20px;
    background:linear-gradient(180deg,transparent 0%,rgba(0,0,0,0.75) 15%,rgba(20,0,40,0.85) 50%,rgba(0,0,0,0.75) 85%,transparent 100%);
    -webkit-backdrop-filter:blur(6px);backdrop-filter:blur(6px);
  }
  .poppers-text {
    font-family:'Bebas Neue',sans-serif;
    font-size:clamp(2rem,6vw,4rem);
    letter-spacing:0.15em;text-transform:uppercase;
    color:white;text-align:center;
    text-shadow:0 0 15px rgba(255,255,255,0.6),0 0 40px rgba(180,77,255,0.5),0 0 80px rgba(180,77,255,0.3);
    animation:poppersPulse 1s ease-in-out infinite;
  }
  @keyframes poppersPulse {
    0%,100%{transform:scale(1);} 50%{transform:scale(1.05);}
  }
  .poppers-sub {
    font-family:'Space Mono',monospace;font-size:11px;
    letter-spacing:0.2em;color:rgba(255,255,255,0.4);margin-top:15px;
  }
  .poppers-countdown {
    font-family:'Bebas Neue',sans-serif;font-size:clamp(2.5rem,8vw,5rem);
    letter-spacing:0.1em;color:rgba(255,255,255,0.8);margin-top:10px;
    text-shadow:0 0 20px rgba(180,77,255,0.6);
  }

  /* Void-burst */
  .voidburst-overlay {
    position:fixed;top:0;left:0;width:100%;height:100%;z-index:70;
    pointer-events:none;opacity:0;transition:opacity 0.1s ease;
    display:flex;align-items:center;justify-content:center;
    background:black;
  }
  .voidburst-overlay.active { opacity:1; }
  .voidburst-image {
    max-width:85vw;max-height:85vh;object-fit:contain;
    opacity:0;transition:opacity 0.5s ease;
    box-shadow:0 0 60px rgba(255,45,123,0.2);
  }

</style>
</head>
<body>

<!-- ═══ ENTRY SCREEN ═══ -->
<div class="entry-prompt" id="entryPrompt">
  
  <!-- Title Section -->
  <div class="entry-header">
    <div class="entry-title">VOID</div>
    <div class="entry-tagline">the end of consumption</div>
  </div>
  
  <!-- Player Card -->
  <div class="player-card" id="playerCard" title="tap to view session history">
    <div class="player-rank" id="playerRank">CURIOUS</div>
    <div class="player-level" id="playerLevel">level 1 · 0 xp</div>
    <div class="player-xp-bar"><div class="player-xp-fill" id="playerXpFill"></div></div>
    <div class="player-corruption" id="playerCorruption">corruption: 0%</div>
    <div class="player-stats" id="playerStats">first time? <span>load content to begin</span></div>
  </div>
  
  <!-- Content Status -->
  <div class="content-status" id="contentStatus">no content loaded</div>
  
  <!-- Main Action -->
  <div class="entry-main-action">
    <button class="entry-button-primary" id="enterBtn" disabled>Enter the Void</button>
    <button class="entry-button-vr" id="enterVRBtn" style="display:none">
      <span class="vr-icon">◉</span> ENTER VR
    </button>
    <button class="entry-button-vr-open" id="openVRWindowBtn" style="display:none">
      ⧉ Open for VR
    </button>
  </div>
  
  <!-- Session Selector -->
  <div class="session-selector">
    <span class="session-duration" id="sessionDuration">20 min</span>
    <div class="session-dots" id="sessionDots">
      <div class="session-dot" data-preset="quick" title="Quick · 10 min"></div>
      <div class="session-dot active" data-preset="standard" title="Standard · 20 min"></div>
      <div class="session-dot" data-preset="extended" title="Extended · 45 min"></div>
      <div class="session-dot" data-preset="marathon" title="Marathon · 90+ min"></div>
    </div>
  </div>
  
  <!-- Secondary Navigation -->
  <nav class="entry-nav">
    <button class="entry-nav-link" id="navContent">content</button>
    <button class="entry-nav-link" id="navSettings">settings</button>
    <button class="entry-nav-link" id="navHistory">history</button>
  </nav>
  
  <!-- Footer -->
  <div class="entry-footer">
    <div class="entry-warning">
      hypnotic visual and audio techniques · flashing imagery · binaural audio · 18+ only · ESC to exit
    </div>
  </div>
  
  <!-- Hidden legacy elements for compatibility -->
  <div class="entry-subtitle" style="display:none">v2.0</div>
  <div class="entry-greeting" id="entryGreeting" style="display:none"></div>
  <div class="entry-level-block" id="entryLevelBlock" style="display:none">
    <div class="entry-level-title" id="entryLevelTitle">CURIOUS</div>
    <div class="entry-level-sub" id="entryLevelSub">level 1</div>
    <div class="entry-xp-bar"><div class="entry-xp-fill" id="entryXpFill"></div></div>
    <div class="entry-corruption" id="entryCorruption"></div>
  </div>
  <div class="entry-profile" id="entryProfile" style="display:none"></div>
  <div class="entry-streak" id="entryStreak" style="display:none"></div>
  <div class="content-counter" id="contentCounter" style="display:none"></div>
  <div class="preset-selector" id="presetSelector" style="display:none">
    <div class="preset-label">session length</div>
    <div class="preset-options">
      <button class="preset-btn" data-preset="quick">Quick<span class="preset-time">10 min</span></button>
      <button class="preset-btn active" data-preset="standard">Standard<span class="preset-time">20 min</span></button>
      <button class="preset-btn" data-preset="extended">Extended<span class="preset-time">45 min</span></button>
      <button class="preset-btn" data-preset="marathon">Marathon<span class="preset-time">90+ min</span></button>
    </div>
  </div>
  <button class="entry-button secondary" id="uploadBtn" style="display:none">Load Content</button>
  <button class="entry-button secondary" id="settingsBtn" style="display:none">Settings</button>
</div>

<!-- Session History Panel -->
<div class="history-panel" id="historyPanel">
  <div class="history-header">SESSION HISTORY</div>
  <div class="history-sub">your journey so far</div>
  <div id="historyList"></div>
  <button class="history-close" id="historyClose">close</button>
</div>

<!-- ═══ SETTINGS PANEL ═══ -->
<div class="settings-panel" id="settingsPanel">
  <div class="settings-header">SETTINGS</div>
  <div class="settings-sub">customize your experience</div>

  <div class="settings-section">
    <div class="settings-section-title">THEME</div>
    <div class="theme-grid" id="themeGrid"></div>
  </div>

  <div class="settings-section">
    <div class="settings-section-title">FEATURES</div>

    <div class="settings-row">
      <div class="settings-label">Poppers Prompts<small>guided inhalation coaching</small></div>
      <label class="toggle-switch">
        <input type="checkbox" id="togglePoppers" checked>
        <div class="toggle-track"></div>
        <div class="toggle-thumb"></div>
      </label>
    </div>

    <div class="settings-row">
      <div class="settings-label">Poppers Frequency<small>how often prompts appear</small></div>
      <div class="freq-control">
        <button class="freq-btn" id="poppersFreqDown">−</button>
        <div class="freq-value" id="poppersFreqLabel">normal</div>
        <button class="freq-btn" id="poppersFreqUp">+</button>
      </div>
    </div>

    <div class="settings-row">
      <div class="settings-label">Captions<small>compilation-style text on panels</small></div>
      <label class="toggle-switch">
        <input type="checkbox" id="toggleCaptions" checked>
        <div class="toggle-track"></div>
        <div class="toggle-thumb"></div>
      </label>
    </div>

    <div class="settings-row">
      <div class="settings-label">Video Audio<small>sound from video clips</small></div>
      <label class="toggle-switch">
        <input type="checkbox" id="toggleVideoAudio" checked>
        <div class="toggle-track"></div>
        <div class="toggle-thumb"></div>
      </label>
    </div>

    <div class="settings-row">
      <div class="settings-label">Permission System<small>D/s edge permission mechanic</small></div>
      <label class="toggle-switch">
        <input type="checkbox" id="togglePermission" checked>
        <div class="toggle-track"></div>
        <div class="toggle-thumb"></div>
      </label>
    </div>

    <div class="settings-row">
      <div class="settings-label">Adaptive Content<small>learns your preferences from tags & engagement</small></div>
      <label class="toggle-switch">
        <input type="checkbox" id="toggleAdaptive" checked>
        <div class="toggle-track"></div>
        <div class="toggle-thumb"></div>
      </label>
    </div>
  </div>

  <div class="settings-section">
    <div class="settings-section-title">ACHIEVEMENTS</div>
    <div class="settings-row" style="flex-direction:column;align-items:stretch">
      <button class="ach-gallery-toggle" id="achGalleryToggle">show achievements (0/0)</button>
      <div class="achievement-gallery" id="achievementGallery"></div>
    </div>
  </div>

  <div class="settings-section">
    <div class="settings-section-title">LIBRARY</div>
    <div class="settings-row">
      <div class="settings-label">Content Library<small id="libMetaInfo">manage tags & metadata</small></div>
      <button class="freq-btn" id="openLibrary" style="width:auto;padding:4px 12px;font-size:10px;color:rgba(255,170,0,0.5);border-color:rgba(255,170,0,0.2)">manage</button>
    </div>
    <div class="settings-row">
      <div class="settings-label">Content Metadata<small id="metaCountInfo">checking...</small></div>
      <button class="freq-btn" id="clearMetadata" style="width:auto;padding:4px 12px;font-size:10px;color:rgba(255,100,100,0.6);border-color:rgba(255,100,100,0.2)">clear</button>
    </div>
  </div>

  <div class="settings-section">
    <div class="settings-section-title">PROGRESSION TRACKS</div>
    <div class="tracks-panel" id="settingsTracksPanel">
      <div class="track-inactive">loading tracks...</div>
    </div>
  </div>

  <div class="settings-section">
    <div class="settings-section-title">BRAIN UPLOAD</div>
    <div class="settings-row" style="flex-direction:column;align-items:stretch">
      <div class="settings-label" style="margin-bottom:8px">Backup & Restore<small>export or import your entire profile, history & tags</small></div>
      <div class="brain-upload-row">
        <button class="brain-btn brain-btn-export" id="brainExport">
          <span class="icon">📤</span> Export Brain
        </button>
        <button class="brain-btn brain-btn-import" id="brainImport">
          <span class="icon">📥</span> Import Brain
        </button>
      </div>
    </div>
  </div>

  <div class="settings-section">
    <div class="settings-section-title">STORAGE</div>
    <div class="settings-row">
      <div class="settings-label">Saved Library<small id="storageInfo">checking...</small></div>
      <button class="freq-btn" id="clearSavedLibrary" style="width:auto;padding:4px 12px;font-size:10px;color:rgba(255,100,100,0.6);border-color:rgba(255,100,100,0.2)">clear</button>
    </div>
    <div class="settings-row">
      <div class="settings-label">Session History<small id="sessionHistoryInfo">checking...</small></div>
      <button class="freq-btn" id="clearSessionHistory" style="width:auto;padding:4px 12px;font-size:10px;color:rgba(255,100,100,0.6);border-color:rgba(255,100,100,0.2)">clear</button>
    </div>
    <div class="settings-row">
      <div class="settings-label">User Profile<small id="profileInfo">checking...</small></div>
      <button class="freq-btn" id="clearProfile" style="width:auto;padding:4px 12px;font-size:10px;color:rgba(255,100,100,0.6);border-color:rgba(255,100,100,0.2)">reset</button>
    </div>
  </div>

  <button class="settings-close" id="settingsClose">Done</button>
</div>

<!-- ═══ BRAIN IMPORT MODAL ═══ -->
<div class="brain-modal" id="brainModal">
  <div class="brain-modal-content">
    <div class="brain-modal-title">IMPORT BRAIN</div>
    <div class="brain-modal-sub">restore your profile, sessions, achievements & tags</div>

    <div id="brainError" class="brain-error" style="display:none"></div>
    <div id="brainSuccess" class="brain-success" style="display:none"></div>

    <!-- File selection state -->
    <div id="brainFileSelect">
      <div class="brain-preview-section" style="text-align:center;padding:30px">
        <div style="font-size:32px;margin-bottom:12px;opacity:0.3">🧠</div>
        <div style="font-family:JetBrains Mono,monospace;font-size:11px;color:rgba(255,255,255,0.3);margin-bottom:16px">
          Select a brain backup file to import
        </div>
        <button class="brain-btn brain-btn-import" id="brainSelectFile" style="width:auto;margin:0 auto">
          <span class="icon">📁</span> Choose File
        </button>
        <input type="file" id="brainFileInput" accept=".json" style="display:none">
      </div>
    </div>

    <!-- Preview state -->
    <div id="brainPreview" style="display:none">
      <div class="brain-preview-section">
        <div class="brain-preview-title">FILE CONTENTS</div>
        <div class="brain-preview-grid" id="brainPreviewImported"></div>
      </div>

      <div class="brain-preview-section">
        <div class="brain-preview-title">YOUR CURRENT DATA</div>
        <div class="brain-preview-grid" id="brainPreviewCurrent"></div>
      </div>

      <div class="brain-preview-section">
        <div class="brain-preview-title">CHANGES</div>
        <div class="brain-preview-grid" id="brainPreviewChanges"></div>
      </div>

      <div class="brain-merge-section">
        <div class="brain-merge-title">PROFILE MERGE STRATEGY</div>
        <div class="brain-merge-option selected" data-merge="keep-higher">
          <div class="brain-merge-radio"></div>
          <div class="brain-merge-text">Keep whichever is higher level</div>
        </div>
        <div class="brain-merge-option" data-merge="keep-imported">
          <div class="brain-merge-radio"></div>
          <div class="brain-merge-text">Use imported profile</div>
        </div>
        <div class="brain-merge-option" data-merge="keep-current">
          <div class="brain-merge-radio"></div>
          <div class="brain-merge-text">Keep current profile</div>
        </div>
      </div>
    </div>

    <!-- Result state -->
    <div id="brainResult" style="display:none">
      <div class="brain-preview-section">
        <div class="brain-preview-title">IMPORT COMPLETE</div>
        <div class="brain-preview-grid" id="brainResultGrid"></div>
      </div>
    </div>

    <div class="brain-modal-actions">
      <button class="brain-modal-btn brain-modal-cancel" id="brainCancel">Cancel</button>
      <button class="brain-modal-btn brain-modal-confirm" id="brainConfirm" disabled>Import</button>
    </div>
  </div>
</div>

<!-- ═══ UPLOAD PANEL ═══ -->
<div class="upload-panel" id="uploadPanel">
  <div class="upload-panel-title">CONTENT LIBRARY</div>
  <div class="upload-panel-subtitle">
    Your content stays in your browser. Nothing is uploaded anywhere.
    <br>Load folders, individual files, or drag and drop.
    <br>Supported: JPG, PNG, GIF, WEBP, MP4, WEBM, MOV
  </div>

  <div class="drop-zone" id="dropZone">
    <div class="drop-zone-text">drop files or folders here</div>
    <div class="drop-zone-hint">or click below to browse</div>
  </div>

  <div class="upload-buttons">
    <button class="upload-btn" id="btnAddFiles">+ files</button>
    <button class="upload-btn" id="btnAddFolder">+ folder</button>
    <button class="upload-btn" id="btnClear">clear all</button>
  </div>

  <div class="upload-loading" id="uploadLoading">
    <div class="upload-progress-label" id="uploadProgressLabel">processing files...</div>
    <div class="upload-progress-track">
      <div class="upload-progress-fill" id="uploadProgressFill"></div>
    </div>
  </div>

  <div class="upload-stats" id="uploadStats"></div>

  <button class="upload-close" id="btnCloseUpload">done</button>

  <!-- Hidden file inputs -->
  <input type="file" id="fileInput" multiple accept="image/*,video/*,.heic,.heif" style="display:none">
  <input type="file" id="folderInput" webkitdirectory multiple style="display:none">
</div>

<!-- ═══ LIBRARY MANAGEMENT PANEL ═══ -->
<div class="library-panel" id="libraryPanel">
  <!-- Tag Drawer -->
  <div class="tag-drawer" id="tagDrawer">
    <button class="tag-drawer-toggle" id="tagDrawerToggle">TAGS</button>
    <div class="tag-drawer-header">
      <span class="tag-drawer-title">TAG FOLDERS</span>
      <button class="tag-drawer-add" id="tagDrawerAddFolder" title="Add folder">+</button>
      <button class="tag-drawer-close" id="tagDrawerClose" title="Close">×</button>
    </div>
    <div class="tag-folder-input-row" id="tagFolderInputRow">
      <input class="tag-folder-input" id="tagFolderInput" placeholder="folder name..." maxlength="30">
      <button class="tag-folder-input-btn" id="tagFolderInputBtn">✓</button>
    </div>
    <div class="tag-drawer-content" id="tagDrawerContent">
      <!-- Folders rendered dynamically -->
    </div>
  </div>

  <div class="lib-header">
    <div class="lib-header-row">
      <span class="lib-title">LIBRARY</span>
      <span class="lib-count" id="libCount">0 items</span>
      <span class="lib-sel-count" id="libSelCount"></span>
      <button class="lib-close" id="libClose">done</button>
    </div>
  </div>

  <!-- Filter bar + page controls -->
  <div class="lib-controls-row">
    <div class="lib-filter-bar" id="libFilterBar"></div>
    <div class="lib-page-controls">
      <div class="lib-size-btns">
        <button class="lib-size-btn" data-size="small" title="Small grid">▦</button>
        <button class="lib-size-btn active" data-size="medium" title="Medium grid">▣</button>
      </div>
      <div class="lib-pagination">
        <button class="lib-page-btn" id="libPrevPage">‹</button>
        <span class="lib-page-info" id="libPageInfo">1 / 1</span>
        <button class="lib-page-btn" id="libNextPage">›</button>
      </div>
      <div class="lib-page-size">
        <input type="range" id="libPageSize" min="10" max="40" step="10" value="20" class="lib-slider">
        <span id="libPageSizeLabel">20/page</span>
      </div>
    </div>
  </div>

  <!-- Toolbar (select, tag, intensity) -->
  <div class="lib-toolbar" id="libToolbar">
    <button class="lib-tool-btn" id="libSelectAll">select all</button>
    <button class="lib-tool-btn" id="libSelectNone">clear</button>
    <div class="lib-tool-sep"></div>
    <input class="lib-tag-input" id="libTagInput" placeholder="add tag..." maxlength="30">
    <button class="lib-tool-btn" id="libApplyTag">+ tag</button>
    <div class="lib-tool-sep"></div>
    <div class="lib-quick-row">
      <span class="lib-quick-label">intensity:</span>
      <button class="lib-quick-btn" data-intensity="gentle" style="color:#88ff44;border-color:#88ff4440">gentle</button>
      <button class="lib-quick-btn" data-intensity="moderate" style="color:#ffaa00;border-color:#ffaa0040">moderate</button>
      <button class="lib-quick-btn" data-intensity="high" style="color:#ff6b00;border-color:#ff6b0040">high</button>
      <button class="lib-quick-btn" data-intensity="extreme" style="color:#ff0044;border-color:#ff004440">extreme</button>
    </div>
  </div>

  <!-- Content grid -->
  <div class="lib-grid size-medium" id="libGrid">
    <div class="lib-empty">no content loaded</div>
  </div>

  <!-- Footer with export/import -->
  <div class="lib-footer">
    <button class="lib-footer-btn" id="libExport">📤 export</button>
    <button class="lib-footer-btn" id="libImport">📥 import</button>
    <input type="file" id="libImportInput" accept=".json" style="display:none">
  </div>
</div>

<!-- ═══ LIGHTBOX OVERLAY ═══ -->
<div class="lib-lightbox" id="libLightbox">
  <div class="lightbox-backdrop" id="lightboxBackdrop"></div>
  <div class="lightbox-container">
    <div class="lightbox-main">
      <button class="lightbox-nav lightbox-prev" id="lightboxPrev">‹</button>
      <div class="lightbox-media" id="lightboxMedia"></div>
      <button class="lightbox-nav lightbox-next" id="lightboxNext">›</button>
    </div>
    <div class="lightbox-sidebar">
      <div class="lightbox-header">
        <span class="lightbox-counter" id="lightboxCounter">1 / 1</span>
        <button class="lightbox-close" id="lightboxClose">×</button>
      </div>
      <div class="lightbox-filename" id="lightboxFilename">filename.jpg</div>
      <div class="lightbox-tags" id="lightboxTags"></div>
    </div>
  </div>
</div>

<!-- Terminal -->
<div class="terminal hidden" id="terminal"></div>

<!-- WebGL Canvas -->
<canvas id="bgCanvas"></canvas>

<!-- Effect Overlays -->
<div class="scanlines"></div>
<div class="noise"></div>
<div class="glitch-overlay" id="glitchOverlay"></div>
<div class="rgb-split" id="rgbSplit"></div>
<div class="screen-tear" id="screenTear"></div>

<!-- Content Display Overlays -->
<div class="flash-overlay" id="flashOverlay"></div>
<div class="fulltake-overlay" id="fulltakeOverlay"></div>

<!-- Blackout / Lockout / Permission / Denial / Release / Poppers / Aftercare -->
<div class="blackout-overlay" id="blackoutOverlay">
  <div class="blackout-text" id="blackoutText"></div>
</div>
<div class="lockout-overlay" id="lockoutOverlay">
  <div class="lockout-label">system cooldown</div>
  <div class="lockout-timer" id="lockoutTimer">60</div>
  <div class="lockout-subtext">access will be restored</div>
</div>
<div class="voidburst-overlay" id="voidburstOverlay"></div>
<div class="poppers-overlay" id="poppersOverlay">
  <div class="poppers-band">
    <div class="poppers-text" id="poppersText">HIT NOW</div>
    <div class="poppers-sub" id="poppersSub">breathe deep</div>
    <div class="poppers-countdown" id="poppersCountdown"></div>
  </div>
</div>
<div class="permission-overlay" id="permissionOverlay">
  <div class="permission-question" id="permissionQuestion">DO YOU NEED TO CUM?</div>
  <button class="permission-btn" id="permissionBtn">PLEASE</button>
  <div class="permission-sub">the system will decide</div>
</div>
<div class="denial-overlay" id="denialOverlay">
  <div class="denial-text" id="denialText">DENIED</div>
  <div class="denial-sub" id="denialSub">not yet</div>
</div>
<div class="release-overlay" id="releaseOverlay">
  <div class="release-text" id="releaseText">NOW</div>
</div>
<div class="aftercare-overlay" id="aftercareOverlay">
  <div class="aftercare-title" id="aftercareTitle">SESSION COMPLETE</div>
  <div class="aftercare-subtitle" id="aftercareSubtitle">void disconnected</div>
  <div class="aftercare-divider"></div>
  <div class="aftercare-stats-grid" id="aftercareStatsGrid"></div>
  <div class="aftercare-rank" id="aftercareRank"></div>
  <div class="aftercare-xp-section" id="aftercareXpSection">
    <div class="aftercare-xp-earned" id="aftercareXpEarned"></div>
    <div class="aftercare-xp-label" id="aftercareXpLabel">experience gained</div>
    <div class="aftercare-level-label" id="aftercareLevelLabel"></div>
    <div class="aftercare-level-bar"><div class="aftercare-level-fill" id="aftercareLevelFill"></div></div>
    <div class="aftercare-corruption-delta" id="aftercareCorruptionDelta"></div>
  </div>
  <div class="aftercare-tracks" id="aftercareTracks"></div>
  <div class="aftercare-session-num" id="aftercareSessionNum"></div>
  <div class="aftercare-achievements" id="aftercareAchievements"></div>
  <div class="aftercare-comparison" id="aftercareComparison"></div>
  <div class="aftercare-care" id="aftercareCare"></div>
  <div class="aftercare-exit">press any key to exit</div>
</div>

<!-- Level Up Notification -->
<div class="levelup-notification" id="levelupNotification">
  <div class="levelup-flash">LEVEL UP</div>
  <div class="levelup-title" id="levelupTitle"></div>
  <div class="levelup-sub" id="levelupSub"></div>
</div>

<!-- Achievement Toast Container -->
<div class="achievement-toast-container" id="achievementToastContainer"></div>

<!-- Breathing Ring -->
<div class="breath-container" id="breathContainer">
  <div class="breath-ring-outer" id="breathOuter"></div>
  <div class="breath-ring-mid" id="breathMid"></div>
  <div class="breath-ring-inner" id="breathInner"></div>
  <div class="breath-ring-core" id="breathCore"></div>
  <div class="breath-text" id="breathText"></div>
</div>

<!-- Text Layers -->
<div class="text-layer"><div class="command-text" id="commandText"></div></div>
<div class="mantra-layer"><div class="mantra-text" id="mantraText"></div></div>
<div class="subliminal" id="subliminalText"></div>
<div class="ticker" id="ticker"><div class="ticker-text" id="tickerText"></div></div>

<!-- HUD -->
<div class="session-timer" id="sessionTimer" style="opacity:0">00:00</div>
<div class="phase-indicator" id="phaseIndicator" style="opacity:0">
  <div class="phase-name" id="phaseName">INITIALIZATION</div>
  <div id="phaseStatus">standing by</div>
</div>
<div class="control-meter" id="controlMeter" style="opacity:0">
  <div class="control-meter-fill" id="controlFill" style="height:0%"></div>
  <div class="control-meter-label">CONTROL</div>
</div>
<div class="trance-indicator" id="tranceIndicator" style="opacity:0">
  <div class="trance-indicator-fill" id="tranceFill" style="height:0%"></div>
  <div class="trance-indicator-label">TRANCE</div>
</div>
<div class="wave-indicator" id="waveIndicator" style="opacity:0"></div>
<div class="safe-word-hint" id="safeHint" style="opacity:0">esc — safe exit</div>

<!-- In-game poppers controls -->
<div class="poppers-hud" id="poppersHud">
  <div class="poppers-hud-freq">
    <button id="poppersHudDown">◀</button>
    <span id="poppersHudFreq">norm</span>
    <button id="poppersHudUp">▶</button>
  </div>
  <button class="poppers-hud-btn" id="poppersHudPause">poppers: on</button>
</div>

<!-- Cursor -->
<div class="cursor-dot" id="cursorDot"></div>
<div class="cursor-ring" id="cursorRing"></div>

<script>
// ═══════════════════════════════════════════════════════════════════
// SPIRAL v2.0 — Content-Integrated Trance Engine
// ═══════════════════════════════════════════════════════════════════

// ── GLOBAL STATE ──
const S = {
  phase: 'idle', phaseIndex: 0,
  intensity: 0, control: 0, tranceDepth: 0,
  sessionTime: 0, running: false, audioStarted: false,
  glitchRate: 0.005,
  // Wave
  waveState: 'build', waveCount: 0, waveFloor: 0, waveCeiling: 0.3,
  waveProgress: 0, waveStartTime: 0,
  // Breathing
  breathPhase: 'in', breathProgress: 0, breathCycleStart: 0, targetBreathRate: 6,
  // Overlays
  blackoutActive: false, lockoutActive: false, aftercareActive: false,
  // Text
  lastCommandTime: 0, nextCommandDelay: 4000,
  lastMantraTime: 0, mantraActive: false,
  // Session stats
  denialCount: 0, edgeCounter: 0,
  peakEntryTime: 0, // when player first entered PEAK
  permissionActive: false, denialActive: false,
  releaseActive: false, poppersActive: false,
  voidburstActive: false,
  intensityFloor: 0, // rises with each denial cycle
  lastPermissionTime: 0,
  lastPoppersTime: 0,
  grantProbability: 0.1, // starts low, rises with denials + time
  // Content
  contentLoaded: false,
  activePanels: [],
  activeObjectURLs: new Map(), // track all active URLs for cleanup
  lastFlashTime: 0,
  lastFulltakeTime: 0,
  displayedIndices: new Set(), // avoid immediate repeats
};

// ═══════════════════════════════════════════════════════════════
// PERSISTENCE — IndexedDB for content, localStorage for settings
// ═══════════════════════════════════════════════════════════════

// --- Session Presets (must be defined before loadSettings) ---
const SESSION_PRESETS = {
  quick: {
    name: 'Quick',
    targetMinutes: 10,
    phaseDurations: [8000, 12000, 15000, 10000],
    description: 'Fast warmup, short peak'
  },
  standard: {
    name: 'Standard',
    targetMinutes: 20,
    phaseDurations: [15000, 25000, 30000, 20000],
    description: 'Balanced arc'
  },
  extended: {
    name: 'Extended',
    targetMinutes: 45,
    phaseDurations: [25000, 50000, 60000, 40000],
    description: 'Slow build, deep peak'
  },
  marathon: {
    name: 'Marathon',
    targetMinutes: 90,
    phaseDurations: [40000, 90000, 120000, 60000],
    description: 'Full journey, multiple peaks'
  }
};

let selectedPreset = 'standard';

// --- Phase Configuration (must be defined before applySessionPreset) ---
const PHASES = [
  {
    name: 'INITIALIZATION', minDuration: 15000,
    baseIntensity: [0, 0.15], glitchRate: 0.003,
    commandInterval: [5000, 8000], subliminalRate: 0.001,
    panelRate: 0.020, breathRate: 6, binauralDiff: 8,
    droneBase: 55, pulseBPM: 60, colorMix: 0,
    mantraEnabled: false, blackoutChance: 0, wavesRequired: 0,
    flashChance: 0, fulltakeChance: 0,
    videoChance: 0.003, rapidFireChance: 0,
  },
  {
    name: 'ENTRAINMENT', minDuration: 25000,
    baseIntensity: [0.15, 0.4], glitchRate: 0.01,
    commandInterval: [4000, 6000], subliminalRate: 0.003,
    panelRate: 0.028, breathRate: 5, binauralDiff: 6,
    droneBase: 60, pulseBPM: 70, colorMix: 0.25,
    mantraEnabled: true, blackoutChance: 0, wavesRequired: 2,
    flashChance: 0.0006, fulltakeChance: 0,
    videoChance: 0.005, rapidFireChance: 0.0001,
  },
  {
    name: 'ESCALATION', minDuration: 30000,
    baseIntensity: [0.4, 0.75], glitchRate: 0.025,
    commandInterval: [2500, 4500], subliminalRate: 0.008,
    panelRate: 0.038, breathRate: 4, binauralDiff: 4.5,
    droneBase: 65, pulseBPM: 90, colorMix: 0.55,
    mantraEnabled: true, blackoutChance: 0.0003, wavesRequired: 3,
    flashChance: 0.0015, fulltakeChance: 0.0004,
    videoChance: 0.008, rapidFireChance: 0.0003,
  },
  {
    name: 'PEAK', minDuration: 20000,
    baseIntensity: [0.75, 1.0], glitchRate: 0.04,
    commandInterval: [1500, 3000], subliminalRate: 0.015,
    panelRate: 0.050, breathRate: 3, binauralDiff: 3,
    droneBase: 70, pulseBPM: 120, colorMix: 0.85,
    mantraEnabled: true, blackoutChance: 0.0005, wavesRequired: 2,
    flashChance: 0.003, fulltakeChance: 0.0008,
    videoChance: 0.012, rapidFireChance: 0.0005,
  },
];

function applySessionPreset(presetId) {
  const preset = SESSION_PRESETS[presetId];
  if (!preset) return;
  
  selectedPreset = presetId;
  
  // Apply durations to phases
  for (let i = 0; i < PHASES.length && i < preset.phaseDurations.length; i++) {
    PHASES[i].minDuration = preset.phaseDurations[i];
  }
  
  console.log(`Session preset applied: ${preset.name} (${preset.targetMinutes} min)`);
}

// --- Settings Persistence (localStorage) ---
function saveSettings() {
  try {
    localStorage.setItem('nl_settings', JSON.stringify({
      theme: currentTheme,
      poppersEnabled: userSettings.poppersEnabled,
      poppersFreq: userSettings.poppersFreq,
      captionsEnabled: userSettings.captionsEnabled,
      videoAudioEnabled: userSettings.videoAudioEnabled,
      permissionEnabled: userSettings.permissionEnabled,
      adaptiveContent: userSettings.adaptiveContent,
      sessionPreset: selectedPreset,
    }));
  } catch(e) { console.warn('Settings save failed:', e); }
}

function loadSettings() {
  try {
    const raw = localStorage.getItem('nl_settings');
    if (!raw) return;
    const s = JSON.parse(raw);
    if (s.theme && THEMES[s.theme]) applyTheme(s.theme);
    if (typeof s.poppersEnabled === 'boolean') {
      userSettings.poppersEnabled = s.poppersEnabled;
      const el = document.getElementById('togglePoppers');
      if (el) el.checked = s.poppersEnabled;
    }
    if (typeof s.poppersFreq === 'number') {
      userSettings.poppersFreq = Math.max(0, Math.min(4, s.poppersFreq));
      updateFreqLabel();
    }
    if (typeof s.captionsEnabled === 'boolean') {
      userSettings.captionsEnabled = s.captionsEnabled;
      const el = document.getElementById('toggleCaptions');
      if (el) el.checked = s.captionsEnabled;
    }
    if (typeof s.videoAudioEnabled === 'boolean') {
      userSettings.videoAudioEnabled = s.videoAudioEnabled;
      const el = document.getElementById('toggleVideoAudio');
      if (el) el.checked = s.videoAudioEnabled;
    }
    if (typeof s.permissionEnabled === 'boolean') {
      userSettings.permissionEnabled = s.permissionEnabled;
      const el = document.getElementById('togglePermission');
      if (el) el.checked = s.permissionEnabled;
    }
    if (typeof s.adaptiveContent === 'boolean') {
      userSettings.adaptiveContent = s.adaptiveContent;
      const el = document.getElementById('toggleAdaptive');
      if (el) el.checked = s.adaptiveContent;
      AdaptiveEngine.enabled = s.adaptiveContent;
    }
    if (s.sessionPreset && SESSION_PRESETS[s.sessionPreset]) {
      selectedPreset = s.sessionPreset;
      // Sync legacy preset buttons
      document.querySelectorAll('.preset-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.preset === s.sessionPreset);
      });
      // Sync new session dots
      document.querySelectorAll('.session-dot').forEach(d => {
        d.classList.toggle('active', d.dataset.preset === s.sessionPreset);
      });
      // Update duration label
      const durationLabels = { quick: '10 min', standard: '20 min', extended: '45 min', marathon: '90+ min' };
      const durationEl = document.getElementById('sessionDuration');
      if (durationEl) durationEl.textContent = durationLabels[s.sessionPreset] || '20 min';
      applySessionPreset(s.sessionPreset);
    }
    console.log('Settings restored');
  } catch(e) { console.warn('Settings load failed:', e); }
}

// --- Content Library Persistence (IndexedDB) ---
const LibraryDB = {
  db: null,
  DB_NAME: 'VoidLibrary',
  DB_VERSION: 1,
  STORE_NAME: 'media',

  open() {
    return new Promise((resolve, reject) => {
      if (this.db) { resolve(this.db); return; }
      const req = indexedDB.open(this.DB_NAME, this.DB_VERSION);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
          db.createObjectStore(this.STORE_NAME, { keyPath: 'id', autoIncrement: true });
        }
      };
      req.onsuccess = (e) => { this.db = e.target.result; resolve(this.db); };
      req.onerror = (e) => { console.warn('IndexedDB open failed:', e); reject(e); };
    });
  },

  async saveFiles(files) {
    try {
      const db = await this.open();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        let saved = 0;
        for (const file of files) {
          const req = store.add({
            blob: file,
            name: file.name,
            type: file.type,
            size: file.size,
            savedAt: Date.now()
          });
          req.onsuccess = () => saved++;
        }
        tx.oncomplete = () => { console.log(`Saved ${saved} files to IndexedDB`); resolve(saved); };
        tx.onerror = () => resolve(saved);
      });
    } catch(e) { console.warn('saveFiles failed:', e); return 0; }
  },

  async loadAll() {
    try {
      const db = await this.open();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const req = store.getAll();
        req.onsuccess = () => {
          const records = req.result || [];
          const files = records.map(r => {
            try {
              return new File([r.blob], r.name, { type: r.type || '' });
            } catch(e) {
              const b = new Blob([r.blob], { type: r.type || '' });
              b.name = r.name;
              return b;
            }
          });
          resolve(files);
        };
        req.onerror = () => resolve([]);
      });
    } catch(e) { console.warn('loadAll failed:', e); return []; }
  },

  async getCount() {
    try {
      const db = await this.open();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const req = store.count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => resolve(0);
      });
    } catch(e) { return 0; }
  },

  async clearAll() {
    try {
      const db = await this.open();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readwrite');
        const store = tx.objectStore(this.STORE_NAME);
        store.clear();
        tx.oncomplete = () => { console.log('IndexedDB library cleared'); resolve(true); };
        tx.onerror = () => resolve(false);
      });
    } catch(e) { return false; }
  },

  async getStorageInfo() {
    try {
      if (navigator.storage && navigator.storage.estimate) {
        const est = await navigator.storage.estimate();
        return { usedMB: (est.usage / (1024*1024)).toFixed(0), quotaGB: (est.quota / (1024*1024*1024)).toFixed(1) };
      }
    } catch(e) {}
    return null;
  }
};

// ═══════════════════════════════════════════════════════════════
// SESSION TRACKER — Buffers events in memory, compiles to record
// Zero I/O during active session. All writes happen after aftercare.
// ═══════════════════════════════════════════════════════════════
const SessionTracker = {
  active: false,
  startTime: 0,
  events: [],           // { type, data, time, phase, trance, intensity }
  tranceCurve: [],      // sampled every 10s
  phaseDurations: {},   // phase index → accumulated ms
  phaseTransitions: [], // { from, to, atSeconds, trance }
  lastPhase: -1,
  lastPhaseTime: 0,
  lastSampleTime: 0,
  peakTrance: 0,
  tranceSum: 0,
  tranceSamples: 0,
  poppersHits: 0,
  lockoutCount: 0,
  voidBurstCount: 0,
  cascadeCount: 0,
  contentDisplayed: new Map(), // persistId → { shows, totalMs, tranceSum, tranceSamples }

  init() {
    this.active = true;
    this.startTime = Date.now();
    this.events = [];
    this.tranceCurve = [];
    this.phaseDurations = { 0: 0, 1: 0, 2: 0, 3: 0 };
    this.phaseTransitions = [];
    this.lastPhase = 0;
    this.lastPhaseTime = performance.now();
    this.lastSampleTime = performance.now();
    this.peakTrance = 0;
    this.tranceSum = 0;
    this.tranceSamples = 0;
    this.poppersHits = 0;
    this.lockoutCount = 0;
    this.voidBurstCount = 0;
    this.cascadeCount = 0;
    this.contentDisplayed = new Map();
  },

  // Called from the render loop — lightweight, no I/O
  tick(now) {
    if (!this.active) return;
    const trance = S.tranceDepth;
    const phase = S.phaseIndex;

    // Track peak trance
    if (trance > this.peakTrance) this.peakTrance = trance;

    // Running average
    this.tranceSum += trance;
    this.tranceSamples++;

    // Accumulate phase time
    if (phase !== this.lastPhase) {
      const elapsed = now - this.lastPhaseTime;
      this.phaseDurations[this.lastPhase] = (this.phaseDurations[this.lastPhase] || 0) + elapsed;
      this.phaseTransitions.push({
        from: this.lastPhase, to: phase,
        atSeconds: (S.sessionTime || 0),
        trance: trance,
      });
      this.lastPhase = phase;
      this.lastPhaseTime = now;
    }

    // Sample trance every 10 seconds
    if (now - this.lastSampleTime > 10000) {
      this.tranceCurve.push(Math.round(trance * 100) / 100);
      this.lastSampleTime = now;
    }
  },

  // Record discrete events — no I/O, just array push
  record(type, data) {
    if (!this.active) return;
    this.events.push({
      type, data: data || {},
      time: S.sessionTime || 0,
      phase: S.phaseIndex,
      trance: S.tranceDepth,
      intensity: S.intensity,
    });
    // Quick counters
    if (type === 'poppers_complete') this.poppersHits++;
    if (type === 'lockout') this.lockoutCount++;
    if (type === 'voidburst') this.voidBurstCount++;
    if (type === 'cascade') this.cascadeCount++;
  },

  // Track content display
  recordContentShow(item) {
    if (!this.active || !item) return;
    const key = item.name + '|' + item.size; // persistId
    const entry = this.contentDisplayed.get(key) || { shows: 0, tranceSum: 0, tranceSamples: 0 };
    entry.shows++;
    entry.tranceSum += S.tranceDepth;
    entry.tranceSamples++;
    this.contentDisplayed.set(key, entry);
  },

  // Compile everything into a SessionRecord at session end
  compile() {
    if (!this.active) return null;
    this.active = false;

    // Final phase accumulation
    const finalElapsed = performance.now() - this.lastPhaseTime;
    this.phaseDurations[this.lastPhase] = (this.phaseDurations[this.lastPhase] || 0) + finalElapsed;

    const duration = S.sessionTime || 0;
    const avgTrance = this.tranceSamples > 0 ? this.tranceSum / this.tranceSamples : 0;
    const contentViewed = ContentRegistry.items.filter(i => i.timesShown > 0).length;
    const sessionMinutes = duration / 60;

    // Phases reached
    const phasesReached = [];
    const phaseNames = ['init', 'entrainment', 'escalation', 'peak'];
    for (let i = 0; i <= 3; i++) {
      if (this.phaseDurations[i] > 500) phasesReached.push(phaseNames[i]);
    }

    // Trance time calculations
    let timeAbove50 = 0, timeAbove80 = 0;
    const sampleInterval = 10; // seconds between samples
    this.tranceCurve.forEach(t => {
      if (t >= 0.5) timeAbove50 += sampleInterval;
      if (t >= 0.8) timeAbove80 += sampleInterval;
    });

    // Per-phase trance averages from events
    const phaseTrance = { init: 0, entrainment: 0, escalation: 0, peak: 0 };
    const phaseTranceCounts = { init: 0, entrainment: 0, escalation: 0, peak: 0 };
    this.events.forEach(e => {
      const pn = phaseNames[e.phase] || 'init';
      phaseTrance[pn] += e.trance;
      phaseTranceCounts[pn]++;
    });
    Object.keys(phaseTrance).forEach(k => {
      phaseTrance[k] = phaseTranceCounts[k] > 0 ? phaseTrance[k] / phaseTranceCounts[k] : 0;
    });

    const rankInfo = getSessionRank(sessionMinutes, S.denialCount, S.edgeCounter);

    // Build content engagement array
    const itemEngagement = [];
    this.contentDisplayed.forEach((data, key) => {
      itemEngagement.push({
        persistId: key,
        shows: data.shows,
        avgTrance: data.tranceSamples > 0 ? data.tranceSum / data.tranceSamples : 0,
      });
    });

    return {
      id: crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(36) + Math.random().toString(36).slice(2),
      timestamp: this.startTime,
      duration: Math.round(duration),
      theme: currentTheme,
      phases: {
        reached: phasesReached,
        durations: {
          init: Math.round(this.phaseDurations[0] / 1000) || 0,
          entrainment: Math.round(this.phaseDurations[1] / 1000) || 0,
          escalation: Math.round(this.phaseDurations[2] / 1000) || 0,
          peak: Math.round(this.phaseDurations[3] / 1000) || 0,
        },
        transitions: this.phaseTransitions,
      },
      trance: {
        peak: Math.round(this.peakTrance * 100) / 100,
        average: Math.round(avgTrance * 100) / 100,
        timeAbove50,
        timeAbove80,
        byPhase: {
          init: Math.round(phaseTrance.init * 100) / 100,
          entrainment: Math.round(phaseTrance.entrainment * 100) / 100,
          escalation: Math.round(phaseTrance.escalation * 100) / 100,
          peak: Math.round(phaseTrance.peak * 100) / 100,
        },
        curve: this.tranceCurve,
      },
      mechanics: {
        denials: S.denialCount,
        edgeCycles: S.edgeCounter,
        permissionGranted: S.releaseActive || false,
        intensityFloor: Math.round(S.intensityFloor * 100) / 100,
        poppersHits: this.poppersHits,
        lockoutCount: this.lockoutCount,
        voidBurstCount: this.voidBurstCount,
        cascadeCount: this.cascadeCount,
      },
      content: {
        totalDisplayed: ContentRegistry.items.reduce((a, i) => a + i.timesShown, 0),
        uniqueDisplayed: contentViewed,
        totalLibrarySize: ContentRegistry.count,
        itemEngagement,
      },
      rank: rankInfo.rank,
      score: rankInfo.score || 0,
    };
  },
};

// --- Extend IndexedDB to store sessions ---
const SessionDB = {
  db: null,
  DB_NAME: 'VoidSessions',
  DB_VERSION: 1,
  STORE_NAME: 'sessions',

  open() {
    return new Promise((resolve, reject) => {
      if (this.db) { resolve(this.db); return; }
      const req = indexedDB.open(this.DB_NAME, this.DB_VERSION);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
          const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });
          store.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
      req.onsuccess = (e) => { this.db = e.target.result; resolve(this.db); };
      req.onerror = (e) => { console.warn('SessionDB open failed:', e); reject(e); };
    });
  },

  async save(record) {
    try {
      const db = await this.open();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readwrite');
        tx.objectStore(this.STORE_NAME).put(record);
        tx.oncomplete = () => { console.log('Session saved:', record.id); resolve(true); };
        tx.onerror = () => resolve(false);
      });
    } catch(e) { console.warn('Session save failed:', e); return false; }
  },

  async getAll() {
    try {
      const db = await this.open();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readonly');
        const store = tx.objectStore(this.STORE_NAME);
        const idx = store.index('timestamp');
        const req = idx.getAll();
        req.onsuccess = () => resolve(req.result || []);
        req.onerror = () => resolve([]);
      });
    } catch(e) { return []; }
  },

  async getRecent(n = 10) {
    const all = await this.getAll();
    return all.sort((a, b) => b.timestamp - a.timestamp).slice(0, n);
  },

  async getCount() {
    try {
      const db = await this.open();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readonly');
        const req = tx.objectStore(this.STORE_NAME).count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => resolve(0);
      });
    } catch(e) { return 0; }
  },

  async getLast() {
    const recent = await this.getRecent(1);
    return recent[0] || null;
  },

  async getStats() {
    const all = await this.getAll();
    if (all.length === 0) return null;
    return {
      totalSessions: all.length,
      totalMinutes: Math.round(all.reduce((a, s) => a + s.duration, 0) / 60),
      totalDenials: all.reduce((a, s) => a + (s.mechanics?.denials || 0), 0),
      totalEdgeCycles: all.reduce((a, s) => a + (s.mechanics?.edgeCycles || 0), 0),
      deepestTrance: Math.max(...all.map(s => s.trance?.peak || 0)),
      longestSession: Math.max(...all.map(s => s.duration || 0)),
      avgSessionMinutes: Math.round(all.reduce((a, s) => a + s.duration, 0) / all.length / 60),
    };
  },

  async clearAll() {
    try {
      const db = await this.open();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readwrite');
        tx.objectStore(this.STORE_NAME).clear();
        tx.oncomplete = () => resolve(true);
        tx.onerror = () => resolve(false);
      });
    } catch(e) { return false; }
  },
};

// ═══════════════════════════════════════════════════════════════
// PROFILE DB — Persistent user identity (IndexedDB, singleton)
// ═══════════════════════════════════════════════════════════════
const ProfileDB = {
  db: null,
  DB_NAME: 'VoidProfile',
  DB_VERSION: 1,
  STORE_NAME: 'profile',

  open() {
    return new Promise((resolve, reject) => {
      if (this.db) { resolve(this.db); return; }
      const req = indexedDB.open(this.DB_NAME, this.DB_VERSION);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
          db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });
        }
      };
      req.onsuccess = (e) => { this.db = e.target.result; resolve(this.db); };
      req.onerror = (e) => { console.warn('ProfileDB open failed:', e); reject(e); };
    });
  },

  createDefault() {
    return {
      id: 'main',
      createdAt: Date.now(),
      lastSessionAt: 0,
      totalSessions: 0,
      level: { current: 1, xp: 0, xpToNext: 100, title: 'CURIOUS' },
      corruption: { index: 0, momentum: 0, peak: 0, history: [] },
      stats: {
        totalMinutes: 0, totalDenials: 0, totalEdgeCycles: 0,
        totalContentViewed: 0, totalPoppersHits: 0,
        longestSession: 0, deepestTrance: 0, highestIntensityFloor: 0,
        currentStreak: 0, longestStreak: 0, lastSessionDate: '',
      },
      // Phase 3C+: tracks, achievements, preferences, affinities
      tracks: {},
      achievements: { unlocked: [], progress: {} },
      preferences: {},
      affinities: { tagScores: {}, topTags: [], clusters: [] },
    };
  },

  async load() {
    try {
      const db = await this.open();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readonly');
        const req = tx.objectStore(this.STORE_NAME).get('main');
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => resolve(null);
      });
    } catch(e) { return null; }
  },

  async save(profile) {
    try {
      const db = await this.open();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readwrite');
        tx.objectStore(this.STORE_NAME).put(profile);
        tx.oncomplete = () => resolve(true);
        tx.onerror = () => resolve(false);
      });
    } catch(e) { return false; }
  },

  async loadOrCreate() {
    let profile = await this.load();
    if (!profile) {
      profile = this.createDefault();
      await this.save(profile);
    }
    return profile;
  },

  async clear() {
    try {
      const db = await this.open();
      return new Promise((resolve) => {
        const tx = db.transaction(this.STORE_NAME, 'readwrite');
        tx.objectStore(this.STORE_NAME).clear();
        tx.oncomplete = () => resolve(true);
        tx.onerror = () => resolve(false);
      });
    } catch(e) { return false; }
  },
};

// ═══════════════════════════════════════════════════════════════
// PROGRESSION ENGINE — XP, Levels, Corruption, Streaks
// ═══════════════════════════════════════════════════════════════

const LEVEL_TABLE = [
  { level: 1,  xp: 0,      title: 'CURIOUS',          color: '#666666' },
  { level: 2,  xp: 100,    title: 'INITIATED',         color: '#aaaaaa' },
  { level: 3,  xp: 300,    title: 'SUSCEPTIBLE',       color: '#88ff44' },
  { level: 4,  xp: 700,    title: 'ENTRANCED',         color: '#00ccff' },
  { level: 5,  xp: 1200,   title: 'GOOD GOONER',       color: '#ff6b00' },
  { level: 6,  xp: 2000,   title: 'EDGE ADDICT',       color: '#ff2d7b' },
  { level: 7,  xp: 3500,   title: 'DEEP DRONE',        color: '#b44dff' },
  { level: 8,  xp: 5500,   title: 'VOID DRONE',      color: '#ff00ff' },
  { level: 9,  xp: 8500,   title: 'TRANCE MASTER',     color: '#ffd700' },
  { level: 10, xp: 13000,  title: 'VOID SOVEREIGN',  color: '#ff0044' },
];

const Progression = {
  // Get level info for a given XP amount
  getLevelInfo(xp) {
    let lvl = LEVEL_TABLE[0];
    for (let i = LEVEL_TABLE.length - 1; i >= 0; i--) {
      if (xp >= LEVEL_TABLE[i].xp) { lvl = LEVEL_TABLE[i]; break; }
    }
    // Handle prestige levels (11+)
    if (xp >= 13000) {
      const extra = Math.floor((xp - 13000) / 6000);
      const prestigeLevel = 10 + extra;
      const nextThreshold = 13000 + (extra + 1) * 6000;
      const currentThreshold = 13000 + extra * 6000;
      return {
        level: prestigeLevel,
        title: `VOID SOVEREIGN ${extra > 0 ? ('✦'.repeat(Math.min(extra, 5))) : ''}`.trim(),
        color: '#ff0044',
        currentXP: xp,
        xpForCurrent: currentThreshold,
        xpForNext: nextThreshold,
        xpToNext: nextThreshold - xp,
        progress: (xp - currentThreshold) / (nextThreshold - currentThreshold),
      };
    }
    // Find next level
    const idx = LEVEL_TABLE.indexOf(lvl);
    const next = LEVEL_TABLE[idx + 1] || null;
    const xpForNext = next ? next.xp : lvl.xp + 6000;
    return {
      level: lvl.level,
      title: lvl.title,
      color: lvl.color,
      currentXP: xp,
      xpForCurrent: lvl.xp,
      xpForNext: xpForNext,
      xpToNext: xpForNext - xp,
      progress: next ? (xp - lvl.xp) / (next.xp - lvl.xp) : 1,
    };
  },

  // Calculate XP earned from a session record
  calculateSessionXP(record, profile) {
    const mins = record.duration / 60;
    const denials = record.mechanics?.denials || 0;
    const edges = record.mechanics?.edgeCycles || 0;
    const peakTrance = record.trance?.peak || 0;
    const timeAbove80 = record.trance?.timeAbove80 || 0;
    const permGranted = record.mechanics?.permissionGranted || false;
    const uniqueContent = record.content?.uniqueDisplayed || 0;
    const totalContent = record.content?.totalLibrarySize || 1;

    let xp = 0;
    xp += mins * 2;                                          // base: 2 XP/min
    xp += denials * 15;                                      // denial bonus
    xp += edges * 10;                                        // edge bonus
    xp += peakTrance * 25;                                   // trance bonus (0-25)
    xp += (timeAbove80 / 60) * 5;                            // deep trance: 5 XP/min above 80%
    if (mins > 20) xp += 40;                                 // endurance bonus
    if (mins > 40) xp += 40;                                 // stacks
    xp += Math.min((profile.stats?.currentStreak || 0) * 8, 80); // streak bonus (cap 80)
    // First session today
    const today = new Date().toISOString().split('T')[0];
    if (profile.stats?.lastSessionDate !== today) xp += 20;
    // Explorer bonus
    if (totalContent > 0) xp += (uniqueContent / totalContent) * 15;
    // Surrender bonus
    if (permGranted) xp += 30;

    return Math.round(xp);
  },

  // Update corruption index
  updateCorruption(profile, record) {
    const c = profile.corruption;
    const mins = record.duration / 60;
    const peakTrance = record.trance?.peak || 0;
    const denials = record.mechanics?.denials || 0;
    const edges = record.mechanics?.edgeCycles || 0;
    const floor = record.mechanics?.intensityFloor || 0;

    // Apply decay for time since last session
    if (profile.lastSessionAt > 0) {
      const daysSince = (Date.now() - profile.lastSessionAt) / 86400000;
      const decay = 0.02 * daysSince;
      c.index = Math.max(c.index - decay, 0);
    }

    // Session impact
    const sessionImpact = (
      (mins / 60) * 0.15 +
      peakTrance * 0.20 +
      denials * 0.02 +
      edges * 0.015 +
      (floor > 0.3 ? 0.05 : 0)
    );

    const oldCorruption = c.index;
    c.index += sessionImpact * (1 - c.index * 0.5); // diminishing returns
    c.index = Math.min(c.index, 0.99);               // never reaches 1.0
    c.momentum = c.index - oldCorruption;
    c.peak = Math.max(c.peak, c.index);

    return c;
  },

  // Update streak
  updateStreak(profile) {
    const today = new Date().toISOString().split('T')[0];
    const lastDate = profile.stats.lastSessionDate;

    if (!lastDate) {
      // First ever session
      profile.stats.currentStreak = 1;
      profile.stats.longestStreak = 1;
    } else if (lastDate === today) {
      // Already played today, no streak change
    } else {
      const last = new Date(lastDate);
      const now = new Date(today);
      const diffDays = Math.round((now - last) / 86400000);
      if (diffDays === 1) {
        // Consecutive day
        profile.stats.currentStreak += 1;
        profile.stats.longestStreak = Math.max(profile.stats.longestStreak, profile.stats.currentStreak);
      } else {
        // Streak broken
        profile.stats.currentStreak = 1;
      }
    }
    profile.stats.lastSessionDate = today;
  },

  // Full profile update after a session
  updateProfile(profile, record, xpEarned) {
    const oldLevel = this.getLevelInfo(profile.level.xp);

    // Update XP and level
    profile.level.xp += xpEarned;
    const newLevelInfo = this.getLevelInfo(profile.level.xp);
    profile.level.current = newLevelInfo.level;
    profile.level.title = newLevelInfo.title;
    profile.level.xpToNext = newLevelInfo.xpToNext;

    // Update corruption
    this.updateCorruption(profile, record);

    // Update streak
    this.updateStreak(profile);

    // Update lifetime stats
    const st = profile.stats;
    profile.totalSessions += 1;
    profile.lastSessionAt = Date.now();
    st.totalMinutes += Math.round(record.duration / 60);
    st.totalDenials += record.mechanics?.denials || 0;
    st.totalEdgeCycles += record.mechanics?.edgeCycles || 0;
    st.totalContentViewed += record.content?.uniqueDisplayed || 0;
    st.totalPoppersHits += record.mechanics?.poppersHits || 0;
    st.longestSession = Math.max(st.longestSession, record.duration);
    st.deepestTrance = Math.max(st.deepestTrance, record.trance?.peak || 0);
    st.highestIntensityFloor = Math.max(st.highestIntensityFloor, record.mechanics?.intensityFloor || 0);

    const leveledUp = newLevelInfo.level > oldLevel.level;
    return { xpEarned, oldLevel, newLevelInfo, leveledUp };
  },

  // Get greeting text based on corruption and level
  getGreeting(profile) {
    const c = profile.corruption.index;
    const title = profile.level.title;
    const streak = profile.stats.currentStreak;

    // Corruption-scaled greetings
    if (c < 0.1) {
      const opts = ['welcome back.', 'ready to begin?', 'the system awaits.'];
      return opts[Math.random() * opts.length | 0];
    } else if (c < 0.3) {
      const opts = [
        `welcome back, ${title}.`,
        'the system remembers you.',
        'you returned. good.',
      ];
      return opts[Math.random() * opts.length | 0];
    } else if (c < 0.5) {
      const opts = [
        `the system has been waiting, ${title}.`,
        'you couldn\'t stay away.',
        `welcome back. corruption: ${Math.floor(c * 100)}%.`,
      ];
      return opts[Math.random() * opts.length | 0];
    } else if (c < 0.7) {
      const opts = [
        `you always come back, ${title}.`,
        'the system owns more of you each time.',
        `corruption: ${Math.floor(c * 100)}%. the process continues.`,
        streak > 3 ? `${streak} days straight. you can\'t stop.` : `deeper each time, ${title}.`,
      ];
      return opts[Math.random() * opts.length | 0];
    } else {
      const opts = [
        `the system has been waiting, ${title}.`,
        `${Math.floor(c * 100)}% corrupted. almost complete.`,
        'you belong to the system now.',
        streak > 5 ? `${streak} days. you\'re addicted.` : 'resistance is a memory.',
      ];
      return opts[Math.random() * opts.length | 0];
    }
  },
};

// ═══════════════════════════════════════════════════════════════
// ACHIEVEMENT SYSTEM — Data-driven achievement engine
// ═══════════════════════════════════════════════════════════════

// Achievement definitions — adding achievements = adding data, not code
const ACHIEVEMENTS = [
  // ── FIRST STEPS (beginner milestones) ──
  { id:'first-session', name:'First Hit', description:'Complete your first session',
    icon:'⚡', category:'milestone', hidden:false,
    condition:{scope:'lifetime', metric:'totalSessions', op:'>=', value:1},
    reward:{xp:25} },
  { id:'five-sessions', name:'Returning Subject', description:'Complete 5 sessions',
    icon:'🔄', category:'milestone', hidden:false,
    condition:{scope:'lifetime', metric:'totalSessions', op:'>=', value:5},
    reward:{xp:50} },
  { id:'ten-sessions', name:'Regular', description:'Complete 10 sessions',
    icon:'📡', category:'milestone', hidden:false,
    condition:{scope:'lifetime', metric:'totalSessions', op:'>=', value:10},
    reward:{xp:75} },
  { id:'twenty-five-sessions', name:'Devoted Subject', description:'Complete 25 sessions',
    icon:'💎', category:'milestone', hidden:false,
    condition:{scope:'lifetime', metric:'totalSessions', op:'>=', value:25},
    reward:{xp:150} },
  { id:'fifty-sessions', name:'Void Veteran', description:'Complete 50 sessions',
    icon:'🏆', category:'milestone', hidden:true,
    condition:{scope:'lifetime', metric:'totalSessions', op:'>=', value:50},
    reward:{xp:300} },
  { id:'hundred-sessions', name:'Centurion', description:'Complete 100 sessions',
    icon:'👑', category:'milestone', hidden:true,
    condition:{scope:'lifetime', metric:'totalSessions', op:'>=', value:100},
    reward:{xp:500} },

  // ── ENDURANCE ──
  { id:'long-session', name:'Endurance Test', description:'Complete a session over 20 minutes',
    icon:'⏱️', category:'endurance', hidden:false,
    condition:{scope:'session', metric:'duration', op:'>=', value:1200},
    reward:{xp:40} },
  { id:'marathon', name:'Marathon', description:'Complete a session over 40 minutes',
    icon:'🏃', category:'endurance', hidden:false,
    condition:{scope:'session', metric:'duration', op:'>=', value:2400},
    reward:{xp:80} },
  { id:'ultra-marathon', name:'Ultra Marathon', description:'Complete a session over 60 minutes',
    icon:'🔥', category:'endurance', hidden:true,
    condition:{scope:'session', metric:'duration', op:'>=', value:3600},
    reward:{xp:150} },
  { id:'total-hours-5', name:'5 Hours Deep', description:'Accumulate 5 hours of total session time',
    icon:'🕐', category:'endurance', hidden:false,
    condition:{scope:'lifetime', metric:'stats.totalMinutes', op:'>=', value:300},
    reward:{xp:100} },
  { id:'total-hours-24', name:'Full Day', description:'Accumulate 24 hours of total session time',
    icon:'🌀', category:'endurance', hidden:true,
    condition:{scope:'lifetime', metric:'stats.totalMinutes', op:'>=', value:1440},
    reward:{xp:300} },

  // ── DEPTH (trance) ──
  { id:'first-deep', name:'Going Under', description:'Reach 70% trance depth',
    icon:'🌊', category:'depth', hidden:false,
    condition:{scope:'session', metric:'trance.peak', op:'>=', value:0.7},
    reward:{xp:30} },
  { id:'deep-trance', name:'Deep Trance', description:'Reach 90% trance depth',
    icon:'🧠', category:'depth', hidden:false,
    condition:{scope:'session', metric:'trance.peak', op:'>=', value:0.9},
    reward:{xp:60} },
  { id:'total-eclipse', name:'Total Eclipse', description:'Reach 98% trance depth',
    icon:'🌑', category:'depth', hidden:true,
    condition:{scope:'session', metric:'trance.peak', op:'>=', value:0.98},
    reward:{xp:120} },
  { id:'deep-sustain', name:'Sustained Depth', description:'Spend 10+ minutes above 80% trance',
    icon:'💫', category:'depth', hidden:false,
    condition:{scope:'session', metric:'trance.timeAbove80', op:'>=', value:600},
    reward:{xp:80} },

  // ── OBEDIENCE (denial/permission) ──
  { id:'first-denial', name:'Denied', description:'Get denied permission for the first time',
    icon:'🚫', category:'obedience', hidden:false,
    condition:{scope:'session', metric:'mechanics.denials', op:'>=', value:1},
    reward:{xp:15} },
  { id:'edgelord', name:'Edgelord', description:'Get denied 5+ times in one session',
    icon:'😈', category:'obedience', hidden:false,
    condition:{scope:'session', metric:'mechanics.denials', op:'>=', value:5},
    reward:{xp:50} },
  { id:'ten-denials', name:'Insatiable', description:'Get denied 10+ times in one session',
    icon:'🔒', category:'obedience', hidden:false,
    condition:{scope:'session', metric:'mechanics.denials', op:'>=', value:10},
    reward:{xp:80} },
  { id:'fifteen-denials', name:'Relentless', description:'Get denied 15+ times in one session',
    icon:'⛓️', category:'obedience', hidden:true,
    condition:{scope:'session', metric:'mechanics.denials', op:'>=', value:15},
    reward:{xp:120} },
  { id:'surrender', name:'Surrender', description:'Be granted permission',
    icon:'🙏', category:'obedience', hidden:false,
    condition:{scope:'session', metric:'mechanics.permissionGranted', op:'==', value:true},
    reward:{xp:20} },
  { id:'lifetime-denials-50', name:'50 Nos', description:'Accumulate 50 lifetime denials',
    icon:'🔐', category:'obedience', hidden:false,
    condition:{scope:'lifetime', metric:'stats.totalDenials', op:'>=', value:50},
    reward:{xp:100} },
  { id:'lifetime-denials-200', name:'200 Nos', description:'Accumulate 200 lifetime denials',
    icon:'🗝️', category:'obedience', hidden:true,
    condition:{scope:'lifetime', metric:'stats.totalDenials', op:'>=', value:200},
    reward:{xp:250} },

  // ── EDGE ──
  { id:'first-edge', name:'On the Edge', description:'Complete your first edge cycle',
    icon:'⚠️', category:'edge', hidden:false,
    condition:{scope:'session', metric:'mechanics.edgeCycles', op:'>=', value:1},
    reward:{xp:15} },
  { id:'edge-master', name:'Edge Master', description:'Complete 5+ edge cycles in one session',
    icon:'🌡️', category:'edge', hidden:false,
    condition:{scope:'session', metric:'mechanics.edgeCycles', op:'>=', value:5},
    reward:{xp:60} },
  { id:'edge-marathon', name:'Edge Marathon', description:'Complete 10+ edge cycles in one session',
    icon:'🎢', category:'edge', hidden:true,
    condition:{scope:'session', metric:'mechanics.edgeCycles', op:'>=', value:10},
    reward:{xp:120} },
  { id:'total-edges-100', name:'Century of Edges', description:'Accumulate 100 lifetime edge cycles',
    icon:'💯', category:'edge', hidden:false,
    condition:{scope:'lifetime', metric:'stats.totalEdgeCycles', op:'>=', value:100},
    reward:{xp:200} },

  // ── CORRUPTION ──
  { id:'corruption-25', name:'Tainted', description:'Reach 25% corruption',
    icon:'🖤', category:'corruption', hidden:false,
    condition:{scope:'lifetime', metric:'corruption.index', op:'>=', value:0.25},
    reward:{xp:50} },
  { id:'corruption-50', name:'Halfway Gone', description:'Reach 50% corruption',
    icon:'💀', category:'corruption', hidden:false,
    condition:{scope:'lifetime', metric:'corruption.index', op:'>=', value:0.50},
    reward:{xp:100} },
  { id:'corruption-75', name:'Point of No Return', description:'Reach 75% corruption',
    icon:'🕳️', category:'corruption', hidden:true,
    condition:{scope:'lifetime', metric:'corruption.index', op:'>=', value:0.75},
    reward:{xp:200} },
  { id:'corruption-90', name:'Almost Complete', description:'Reach 90% corruption',
    icon:'♠️', category:'corruption', hidden:true,
    condition:{scope:'lifetime', metric:'corruption.index', op:'>=', value:0.90},
    reward:{xp:300} },

  // ── STREAKS ──
  { id:'streak-3', name:'Three-Peat', description:'Maintain a 3-day session streak',
    icon:'🔥', category:'streak', hidden:false,
    condition:{scope:'lifetime', metric:'stats.currentStreak', op:'>=', value:3},
    reward:{xp:40} },
  { id:'streak-7', name:'Full Week', description:'Maintain a 7-day session streak',
    icon:'📅', category:'streak', hidden:false,
    condition:{scope:'lifetime', metric:'stats.currentStreak', op:'>=', value:7},
    reward:{xp:100} },
  { id:'streak-14', name:'Two Weeks Deep', description:'Maintain a 14-day session streak',
    icon:'🗓️', category:'streak', hidden:true,
    condition:{scope:'lifetime', metric:'stats.currentStreak', op:'>=', value:14},
    reward:{xp:200} },
  { id:'streak-30', name:'Monthly Devotion', description:'Maintain a 30-day session streak',
    icon:'📆', category:'streak', hidden:true,
    condition:{scope:'lifetime', metric:'stats.currentStreak', op:'>=', value:30},
    reward:{xp:500} },

  // ── INTENSITY ──
  { id:'high-floor', name:'Raised Floor', description:'Reach 50% intensity floor from denial stacking',
    icon:'📈', category:'intensity', hidden:false,
    condition:{scope:'session', metric:'mechanics.intensityFloor', op:'>=', value:0.5},
    reward:{xp:40} },
  { id:'max-floor', name:'Maximum Overdrive', description:'Reach 80% intensity floor',
    icon:'🚀', category:'intensity', hidden:true,
    condition:{scope:'session', metric:'mechanics.intensityFloor', op:'>=', value:0.8},
    reward:{xp:100} },

  // ── POPPERS ──
  { id:'first-hit', name:'First Rush', description:'Complete your first poppers sequence',
    icon:'💨', category:'poppers', hidden:false,
    condition:{scope:'session', metric:'mechanics.poppersHits', op:'>=', value:1},
    reward:{xp:15} },
  { id:'poppers-5', name:'Cloud Nine', description:'Complete 5 poppers sequences in one session',
    icon:'☁️', category:'poppers', hidden:false,
    condition:{scope:'session', metric:'mechanics.poppersHits', op:'>=', value:5},
    reward:{xp:50} },
  { id:'poppers-lifetime-50', name:'Frequent Flyer', description:'Complete 50 lifetime poppers sequences',
    icon:'✈️', category:'poppers', hidden:false,
    condition:{scope:'lifetime', metric:'stats.totalPoppersHits', op:'>=', value:50},
    reward:{xp:100} },
];

// Achievement categories for gallery display
const ACHIEVEMENT_CATEGORIES = [
  { id:'milestone', name:'MILESTONES', color:'#ffd700' },
  { id:'endurance', name:'ENDURANCE', color:'#88ff44' },
  { id:'depth', name:'DEPTH', color:'#00ccff' },
  { id:'obedience', name:'OBEDIENCE', color:'#ff2d7b' },
  { id:'edge', name:'EDGE', color:'#ff6b00' },
  { id:'corruption', name:'CORRUPTION', color:'#b44dff' },
  { id:'streak', name:'STREAKS', color:'#ff8800' },
  { id:'intensity', name:'INTENSITY', color:'#ff0044' },
  { id:'poppers', name:'POPPERS', color:'#44ddff' },
];

// Generic achievement evaluation engine
const AchievementEngine = {
  // Resolve a dotted metric path (e.g. 'mechanics.denials') from an object
  resolve(obj, path) {
    const parts = path.split('.');
    let val = obj;
    for (const p of parts) {
      if (val == null) return undefined;
      val = val[p];
    }
    return val;
  },

  // Evaluate a single condition against data
  evalCondition(cond, sessionRecord, profile) {
    let actual;
    if (cond.scope === 'session' && sessionRecord) {
      actual = this.resolve(sessionRecord, cond.metric);
    } else if (cond.scope === 'lifetime' || cond.scope === 'streak') {
      actual = this.resolve(profile, cond.metric);
    }
    if (actual === undefined || actual === null) return false;

    switch(cond.op) {
      case '>=': return actual >= cond.value;
      case '>':  return actual > cond.value;
      case '==': return actual == cond.value;  // loose equality for bool/number
      case '<=': return actual <= cond.value;
      case '<':  return actual < cond.value;
      default: return false;
    }
  },

  // Check all achievements, return newly unlocked ones
  evaluate(sessionRecord, profile) {
    const unlocked = profile.achievements?.unlocked || [];
    const newlyUnlocked = [];

    for (const ach of ACHIEVEMENTS) {
      // Skip already earned
      if (unlocked.includes(ach.id)) continue;

      // Check condition(s)
      let passed = false;
      if (ach.conditions) {
        // Compound: all conditions must pass (AND)
        passed = ach.conditions.every(c => this.evalCondition(c, sessionRecord, profile));
      } else if (ach.condition) {
        passed = this.evalCondition(ach.condition, sessionRecord, profile);
      }

      if (passed) {
        newlyUnlocked.push(ach);
        unlocked.push(ach.id);
      }
    }

    // Update profile
    if (!profile.achievements) profile.achievements = { unlocked: [], progress: {} };
    profile.achievements.unlocked = unlocked;

    return newlyUnlocked;
  },

  // Get achievement stats for display
  getStats(profile) {
    const unlocked = profile.achievements?.unlocked || [];
    return {
      total: ACHIEVEMENTS.length,
      earned: unlocked.length,
      percentage: Math.round((unlocked.length / ACHIEVEMENTS.length) * 100),
    };
  },
};

// ═══════════════════════════════════════════════════════════════
// PROGRESSION TRACKS — Multi-dimensional progression system
// ═══════════════════════════════════════════════════════════════

const TRACK_DEFINITIONS = [
  {
    id: 'endurance',
    displayName: 'Endurance',
    description: 'How long can you go?',
    icon: '⏱️',
    category: 'core',
    color: '#88ff44',
    // XP sources: evaluated per session from SessionRecord fields
    xpSources: [
      { metric: 'duration', multiplier: 0.05 },          // 0.05 XP per second (~3 XP/min)
      { metric: 'trance.timeAbove50', multiplier: 0.04 }, // bonus for time above 50% trance
    ],
    // Session bonuses: flat XP for reaching thresholds within a session
    sessionBonuses: [
      { metric: 'duration', threshold: 1200, bonus: 15, label: '20min+' },
      { metric: 'duration', threshold: 2400, bonus: 25, label: '40min+' },
      { metric: 'duration', threshold: 3600, bonus: 40, label: '60min+' },
    ],
    tiers: [
      { level: 1, xp: 0,    title: 'Beginner',     color: '#88ff4440' },
      { level: 2, xp: 60,   title: 'Practiced',     color: '#88ff4460' },
      { level: 3, xp: 180,  title: 'Enduring',      color: '#88ff4480' },
      { level: 4, xp: 400,  title: 'Relentless',    color: '#88ff44a0' },
      { level: 5, xp: 800,  title: 'Inexhaustible', color: '#88ff44' },
    ],
    activationConditions: [{ type: 'always' }], // core track, always active
  },
  {
    id: 'depth',
    displayName: 'Depth',
    description: 'How deep can you sink?',
    icon: '🌊',
    category: 'core',
    color: '#00ccff',
    xpSources: [
      { metric: 'trance.peak', multiplier: 40 },           // up to 40 XP for peak
      { metric: 'trance.timeAbove80', multiplier: 0.08 },   // 0.08 XP per sec above 80%
      { metric: 'trance.average', multiplier: 20 },          // up to 20 XP for avg trance
    ],
    sessionBonuses: [
      { metric: 'trance.peak', threshold: 0.7, bonus: 10, label: '70%+ peak' },
      { metric: 'trance.peak', threshold: 0.9, bonus: 20, label: '90%+ peak' },
      { metric: 'trance.timeAbove80', threshold: 600, bonus: 25, label: '10min deep' },
    ],
    tiers: [
      { level: 1, xp: 0,    title: 'Shallow',      color: '#00ccff40' },
      { level: 2, xp: 50,   title: 'Submerged',    color: '#00ccff60' },
      { level: 3, xp: 150,  title: 'Entranced',    color: '#00ccff80' },
      { level: 4, xp: 350,  title: 'Abyssal',      color: '#00ccffa0' },
      { level: 5, xp: 700,  title: 'Void Dweller', color: '#00ccff' },
    ],
    activationConditions: [{ type: 'always' }],
  },
  {
    id: 'obedience',
    displayName: 'Obedience',
    description: 'How well do you follow?',
    icon: '🔒',
    category: 'core',
    color: '#ff2d7b',
    xpSources: [
      { metric: 'mechanics.denials', multiplier: 12 },
      { metric: 'mechanics.edgeCycles', multiplier: 8 },
      { metric: 'mechanics.intensityFloor', multiplier: 30 },  // up to 30 XP for high floor
    ],
    sessionBonuses: [
      { metric: 'mechanics.denials', threshold: 3, bonus: 10, label: '3+ denials' },
      { metric: 'mechanics.denials', threshold: 8, bonus: 20, label: '8+ denials' },
      { metric: 'mechanics.edgeCycles', threshold: 5, bonus: 15, label: '5+ edges' },
      { metric: 'mechanics.intensityFloor', threshold: 0.5, bonus: 15, label: '50%+ floor' },
    ],
    tiers: [
      { level: 1, xp: 0,    title: 'Resistant',    color: '#ff2d7b40' },
      { level: 2, xp: 50,   title: 'Compliant',    color: '#ff2d7b60' },
      { level: 3, xp: 160,  title: 'Obedient',     color: '#ff2d7b80' },
      { level: 4, xp: 380,  title: 'Submissive',   color: '#ff2d7ba0' },
      { level: 5, xp: 750,  title: 'Broken In',    color: '#ff2d7b' },
    ],
    activationConditions: [{ type: 'always' }],
  },
  {
    id: 'devotion',
    displayName: 'Devotion',
    description: 'How often do you return?',
    icon: '💎',
    category: 'core',
    color: '#b44dff',
    xpSources: [
      // Devotion earns most XP from showing up, not from session performance
      { metric: '_sessionCompleted', multiplier: 10 }, // flat 10 XP per session
      { metric: '_streakDay', multiplier: 5 },         // bonus per streak day
    ],
    sessionBonuses: [
      { metric: '_streakDays', threshold: 3, bonus: 15, label: '3-day streak' },
      { metric: '_streakDays', threshold: 7, bonus: 30, label: '7-day streak' },
      { metric: '_streakDays', threshold: 14, bonus: 50, label: '14-day streak' },
    ],
    tiers: [
      { level: 1, xp: 0,    title: 'Visitor',       color: '#b44dff40' },
      { level: 2, xp: 40,   title: 'Regular',       color: '#b44dff60' },
      { level: 3, xp: 120,  title: 'Committed',     color: '#b44dff80' },
      { level: 4, xp: 300,  title: 'Dependent',     color: '#b44dffa0' },
      { level: 5, xp: 600,  title: 'Inseparable',   color: '#b44dff' },
    ],
    activationConditions: [{ type: 'always' }],
  },
];

const TrackEngine = {
  // Resolve a dotted path from an object (reuses same logic as AchievementEngine)
  resolve(obj, path) {
    const parts = path.split('.');
    let val = obj;
    for (const p of parts) {
      if (val == null) return undefined;
      val = val[p];
    }
    return val;
  },

  // Get tier info for a track at given XP
  getTierInfo(track, xp) {
    let tier = track.tiers[0];
    for (let i = track.tiers.length - 1; i >= 0; i--) {
      if (xp >= track.tiers[i].xp) { tier = track.tiers[i]; break; }
    }
    const idx = track.tiers.indexOf(tier);
    const next = track.tiers[idx + 1] || null;
    const maxTier = !next;
    return {
      level: tier.level,
      title: tier.title,
      color: tier.color,
      xpForCurrent: tier.xp,
      xpForNext: next ? next.xp : tier.xp,
      xpToNext: next ? next.xp - xp : 0,
      progress: next ? Math.min((xp - tier.xp) / (next.xp - tier.xp), 1) : 1,
      maxTier,
    };
  },

  // Calculate track XP for a given session
  calculateTrackXP(track, record, profile) {
    let trackXP = 0;

    // XP from continuous sources
    for (const src of track.xpSources) {
      let val;
      // Handle special virtual metrics
      if (src.metric === '_sessionCompleted') {
        val = 1;
      } else if (src.metric === '_streakDay') {
        val = Math.min(profile.stats?.currentStreak || 0, 30);
      } else {
        val = this.resolve(record, src.metric);
      }
      if (val != null && typeof val === 'number') {
        trackXP += val * src.multiplier;
      }
    }

    // Session bonuses (flat XP for meeting thresholds)
    if (track.sessionBonuses) {
      for (const b of track.sessionBonuses) {
        let val;
        if (b.metric === '_streakDays') {
          val = profile.stats?.currentStreak || 0;
        } else {
          val = this.resolve(record, b.metric);
        }
        if (val != null && val >= b.threshold) {
          trackXP += b.bonus;
        }
      }
    }

    return Math.round(Math.max(trackXP, 0));
  },

  // Check if a track should be activated
  checkActivation(track, profile) {
    if (!track.activationConditions) return true;
    // ANY condition met = activated (OR logic)
    for (const cond of track.activationConditions) {
      switch (cond.type) {
        case 'always': return true;
        case 'level':
          if ((profile.level?.current || 1) >= cond.minLevel) return true;
          break;
        case 'stat': {
          const val = this.resolve(profile, `stats.${cond.stat}`);
          if (val != null && val >= cond.threshold) return true;
          break;
        }
        case 'session_count':
          if ((profile.totalSessions || 0) >= cond.threshold) return true;
          break;
      }
    }
    return false;
  },

  // Ensure all core tracks are initialized in profile
  initTracks(profile) {
    if (!profile.tracks) profile.tracks = {};
    for (const track of TRACK_DEFINITIONS) {
      if (!profile.tracks[track.id]) {
        profile.tracks[track.id] = {
          trackId: track.id,
          activated: false,
          activatedAt: 0,
          xp: 0,
          level: 1,
          title: track.tiers[0].title,
        };
      }
    }
  },

  // Update all tracks after a session. Returns array of track results
  updateTracks(profile, record) {
    this.initTracks(profile);
    const results = [];

    for (const track of TRACK_DEFINITIONS) {
      const state = profile.tracks[track.id];

      // Check activation
      if (!state.activated) {
        if (this.checkActivation(track, profile)) {
          state.activated = true;
          state.activatedAt = Date.now();
        } else {
          continue; // skip inactive tracks
        }
      }

      // Calculate XP earned
      const xpEarned = this.calculateTrackXP(track, record, profile);
      if (xpEarned <= 0) continue;

      const oldTier = this.getTierInfo(track, state.xp);
      state.xp += xpEarned;
      const newTier = this.getTierInfo(track, state.xp);
      state.level = newTier.level;
      state.title = newTier.title;

      const tierUp = newTier.level > oldTier.level;

      results.push({
        track,
        state,
        xpEarned,
        oldTier,
        newTier,
        tierUp,
      });
    }

    return results;
  },

  // Get display data for all active tracks
  getActiveTrackDisplays(profile) {
    this.initTracks(profile);
    const displays = [];
    for (const track of TRACK_DEFINITIONS) {
      const state = profile.tracks[track.id];
      if (!state.activated) continue;
      const tier = this.getTierInfo(track, state.xp);
      displays.push({
        track,
        state,
        tier,
      });
    }
    return displays;
  },
};

const ContentRegistry = {
  items: [],       // { id, file, type:'image'|'video', name, size, persistId, folderTags }
  imageCount: 0,
  videoCount: 0,

  // Generate a stable persistId from file properties
  generatePersistId(file) {
    const raw = `${file.name}|${file.size}|${file.type || this.getMediaType(file) || ''}`;
    // Simple hash (djb2)
    let hash = 5381;
    for (let i = 0; i < raw.length; i++) {
      hash = ((hash << 5) + hash + raw.charCodeAt(i)) & 0xFFFFFFFF;
    }
    return 'pid_' + (hash >>> 0).toString(36);
  },

  // Extract folder tags from webkitRelativePath
  extractFolderTags(file) {
    const path = file.webkitRelativePath || '';
    if (!path || !path.includes('/')) return [];
    // Get folder segments (exclude the filename itself)
    const segments = path.split('/').slice(0, -1);
    const tags = [];
    for (const seg of segments) {
      // Split on spaces, hyphens, underscores, dots
      const tokens = seg.split(/[\s\-_\.]+/).filter(t => t.length > 1);
      for (const t of tokens) {
        const tag = t.toLowerCase().replace(/[^a-z0-9]/g, '');
        if (tag.length > 1 && !tags.includes(tag)) tags.push(tag);
      }
    }
    return tags;
  },

  add(file) {
    const type = this.getMediaType(file);
    if (!type) return null; // not a valid media file
    const persistId = this.generatePersistId(file);
    const folderTags = this.extractFolderTags(file);
    const item = {
      id: this.items.length,
      file: file,
      type: type,
      name: file.name,
      size: file.size,
      persistId,
      folderTags,
      timesShown: 0,
      lastShown: 0,
    };
    this.items.push(item);
    if (type === 'video') this.videoCount++;
    else this.imageCount++;
    return item;
  },

  getMediaType(file) {
    const mime = (file.type || '').toLowerCase();
    const ext = (file.name || '').split('.').pop().toLowerCase();

    // Check MIME type first
    if (mime.startsWith('image/')) return 'image';
    if (mime.startsWith('video/')) return 'video';

    // Fallback: check file extension (critical for iOS where type can be empty)
    const imageExts = ['jpg','jpeg','png','gif','webp','heic','heif','bmp','tiff','tif','avif'];
    const videoExts = ['mp4','webm','mov','m4v','avi','mkv','ogv'];

    if (imageExts.includes(ext)) return 'image';
    if (videoExts.includes(ext)) return 'video';

    return null;
  },

  addMany(files) {
    let added = 0;
    for (const file of files) {
      if (this.add(file)) added++;
    }
    return added;
  },

  clear() {
    this.items = [];
    this.imageCount = 0;
    this.videoCount = 0;
  },

  get count() { return this.items.length; },

  // Weighted random: prefer less-shown items (stochastic, never predictable)
  pickRandom(excludeSet) {
    if (this.items.length === 0) return null;

    // Build weighted pool favoring less-shown items
    const candidates = this.items.filter(it => !excludeSet || !excludeSet.has(it.id));
    if (candidates.length === 0) {
      // All excluded, clear exclusions
      if (excludeSet) excludeSet.clear();
      return this.items[Math.random() * this.items.length | 0];
    }

    // Weight: inverse of timesShown + 1
    const weights = candidates.map(it => 1 / (it.timesShown + 1));
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let r = Math.random() * totalWeight;
    for (let i = 0; i < candidates.length; i++) {
      r -= weights[i];
      if (r <= 0) {
        candidates[i].timesShown++;
        candidates[i].lastShown = Date.now();
        return candidates[i];
      }
    }
    return candidates[candidates.length - 1];
  },

  pickRandomImage(excludeSet) {
    const images = this.items.filter(it => it.type === 'image' && (!excludeSet || !excludeSet.has(it.id)));
    if (images.length === 0) return this.pickRandom(excludeSet);
    const item = images[Math.random() * images.length | 0];
    item.timesShown++;
    item.lastShown = Date.now();
    return item;
  },

  // Adaptive selection using engagement data
  async pickAdaptive(sessionProgress, excludeSet) {
    if (!AdaptiveEngine.enabled || this.items.length === 0) {
      return this.pickRandom(excludeSet);
    }
    
    const candidates = this.items.filter(it => !excludeSet || !excludeSet.has(it.id));
    if (candidates.length === 0) {
      if (excludeSet) excludeSet.clear();
      AdaptiveEngine.sessionShown.clear();
      return this.pickAdaptive(sessionProgress, excludeSet);
    }

    const item = await AdaptiveEngine.selectContent(candidates, sessionProgress);
    if (item) {
      item.timesShown++;
      item.lastShown = Date.now();
      if (excludeSet) excludeSet.add(item.id);
    }
    return item;
  },

  // Adaptive image pick
  async pickAdaptiveImage(sessionProgress, excludeSet) {
    const images = this.items.filter(it => it.type === 'image');
    if (images.length === 0) return this.pickAdaptive(sessionProgress, excludeSet);
    
    const candidates = images.filter(it => !excludeSet || !excludeSet.has(it.id));
    if (candidates.length === 0) {
      if (excludeSet) excludeSet.clear();
      return this.pickAdaptiveImage(sessionProgress, excludeSet);
    }
    
    const item = await AdaptiveEngine.selectContent(candidates, sessionProgress);
    if (item) {
      item.timesShown++;
      item.lastShown = Date.now();
      if (excludeSet) excludeSet.add(item.id);
    }
    return item;
  },

  totalSizeMB() {
    return (this.items.reduce((a, it) => a + it.size, 0) / (1024*1024)).toFixed(1);
  }
};

// ═══════════════════════════════════════════════════════════════
// TAG SYSTEM — Flat namespace with optional grouping
// ═══════════════════════════════════════════════════════════════

const SYSTEM_TAGS = {
  intensity: [
    { id:'gentle', displayName:'Gentle', color:'#88ff44' },
    { id:'moderate', displayName:'Moderate', color:'#ffaa00' },
    { id:'high', displayName:'High', color:'#ff6b00' },
    { id:'extreme', displayName:'Extreme', color:'#ff0044' },
  ],
  mood: [
    { id:'teasing', displayName:'Teasing', color:'#ff9ecd' },
    { id:'sensual', displayName:'Sensual', color:'#ff6baa' },
    { id:'dominant', displayName:'Dominant', color:'#ff2d7b' },
    { id:'aggressive', displayName:'Aggressive', color:'#ff0044' },
    { id:'worshipful', displayName:'Worshipful', color:'#b44dff' },
    { id:'degrading', displayName:'Degrading', color:'#ff4444' },
    { id:'overwhelming', displayName:'Overwhelming', color:'#ff00ff' },
  ],
  energy: [
    { id:'slow-burn', displayName:'Slow Burn', color:'#44ddff' },
    { id:'steady', displayName:'Steady', color:'#00ccff' },
    { id:'intense', displayName:'Intense', color:'#ff6b00' },
    { id:'chaotic', displayName:'Chaotic', color:'#ff0044' },
  ],
};

// ═══════════════════════════════════════════════════════════════
// CONTENT METADATA DB — Persistent per-item metadata in IndexedDB
// ═══════════════════════════════════════════════════════════════

const ContentMetaDB = {
  DB_NAME: 'VoidContentMeta',
  DB_VERSION: 1,
  STORE: 'metadata',

  async open() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(this.DB_NAME, this.DB_VERSION);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(this.STORE)) {
          db.createObjectStore(this.STORE, { keyPath: 'persistId' });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  },

  createDefault(persistId) {
    return {
      persistId,
      tags: {
        userTags: [],
        folderTags: [],
        autoTags: [],
        intensity: null,
        mood: null,
        energy: null,
      },
      engagement: {
        totalShows: 0,
        totalDurationMs: 0,
        avgTranceAtDisplay: 0,
        avgTranceDelta: 0,
        peakTranceAssoc: 0,
        phaseAffinity: { init:0, entrainment:0, escalation:0, peak:0 },
        lastSessionShown: null,
        sessionCount: 0,
      },
      scores: {
        heatScore: 0,
        noveltyScore: 100,
        addictionScore: 0,
        versatilityScore: 50,
      },
      updatedAt: Date.now(),
    };
  },

  async get(persistId) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.STORE, 'readonly');
      const req = tx.objectStore(this.STORE).get(persistId);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
  },

  async getOrCreate(persistId) {
    let meta = await this.get(persistId);
    if (!meta) {
      meta = this.createDefault(persistId);
      await this.save(meta);
    }
    return meta;
  },

  async save(meta) {
    meta.updatedAt = Date.now();
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.STORE, 'readwrite');
      tx.objectStore(this.STORE).put(meta);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  },

  async saveBatch(metas) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.STORE, 'readwrite');
      const store = tx.objectStore(this.STORE);
      for (const m of metas) { m.updatedAt = Date.now(); store.put(m); }
      tx.oncomplete = () => resolve(metas.length);
      tx.onerror = () => reject(tx.error);
    });
  },

  async getAll() {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.STORE, 'readonly');
      const req = tx.objectStore(this.STORE).getAll();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror = () => reject(req.error);
    });
  },

  async getCount() {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.STORE, 'readonly');
      const req = tx.objectStore(this.STORE).count();
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  },

  async clearAll() {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(this.STORE, 'readwrite');
      tx.objectStore(this.STORE).clear();
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  },

  // Export all metadata as JSON
  async exportJSON() {
    const all = await this.getAll();
    return JSON.stringify({ version: 1, exported: Date.now(), metadata: all }, null, 2);
  },

  // Import metadata from JSON, merging with existing
  async importJSON(jsonStr) {
    const data = JSON.parse(jsonStr);
    if (!data.metadata || !Array.isArray(data.metadata)) throw new Error('Invalid format');
    let imported = 0;
    for (const meta of data.metadata) {
      if (!meta.persistId) continue;
      const existing = await this.get(meta.persistId);
      if (existing) {
        // Merge: keep higher engagement, combine tags
        if (meta.tags) {
          const ut = new Set([...(existing.tags.userTags||[]), ...(meta.tags.userTags||[])]);
          existing.tags.userTags = [...ut];
          if (meta.tags.intensity && !existing.tags.intensity) existing.tags.intensity = meta.tags.intensity;
          if (meta.tags.mood && !existing.tags.mood) existing.tags.mood = meta.tags.mood;
          if (meta.tags.energy && !existing.tags.energy) existing.tags.energy = meta.tags.energy;
        }
        await this.save(existing);
      } else {
        await this.save(meta);
      }
      imported++;
    }
    return imported;
  },
};

// ═══════════════════════════════════════════════════════════════
// TAG FOLDER DB — Organize tags into custom folders/categories
// ═══════════════════════════════════════════════════════════════

const TagFolderDB = {
  DB_NAME: 'VoidTagFolders',
  DB_VERSION: 1,
  STORE_NAME: 'folders',
  db: null,

  async init() {
    if (this.db) return;
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(this.DB_NAME, this.DB_VERSION);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
          db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });
        }
      };
      req.onsuccess = (e) => { this.db = e.target.result; resolve(); };
      req.onerror = (e) => reject(e.target.error);
    });
  },

  generateId() {
    return 'folder-' + Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
  },

  async getAll() {
    await this.init();
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(this.STORE_NAME, 'readonly');
      const store = tx.objectStore(this.STORE_NAME);
      const req = store.getAll();
      req.onsuccess = () => resolve(req.result.sort((a, b) => a.order - b.order));
      req.onerror = (e) => reject(e.target.error);
    });
  },

  async get(id) {
    await this.init();
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(this.STORE_NAME, 'readonly');
      const req = tx.objectStore(this.STORE_NAME).get(id);
      req.onsuccess = () => resolve(req.result);
      req.onerror = (e) => reject(e.target.error);
    });
  },

  async save(folder) {
    await this.init();
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
      tx.objectStore(this.STORE_NAME).put(folder);
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => reject(e.target.error);
    });
  },

  async delete(id) {
    await this.init();
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(this.STORE_NAME, 'readwrite');
      tx.objectStore(this.STORE_NAME).delete(id);
      tx.oncomplete = () => resolve();
      tx.onerror = (e) => reject(e.target.error);
    });
  },

  async createFolder(name) {
    const folders = await this.getAll();
    const folder = {
      id: this.generateId(),
      name: name,
      order: folders.length,
      tags: [],
      collapsed: false
    };
    await this.save(folder);
    return folder;
  },

  async renameFolder(id, newName) {
    const folder = await this.get(id);
    if (folder) {
      folder.name = newName;
      await this.save(folder);
    }
    return folder;
  },

  async addTagToFolder(folderId, tag) {
    // First remove from any other folder
    const folders = await this.getAll();
    for (const f of folders) {
      const idx = f.tags.indexOf(tag);
      if (idx !== -1) {
        f.tags.splice(idx, 1);
        await this.save(f);
      }
    }
    // Add to target folder
    const folder = await this.get(folderId);
    if (folder && !folder.tags.includes(tag)) {
      folder.tags.push(tag);
      await this.save(folder);
    }
    return folder;
  },

  async removeTagFromFolder(folderId, tag) {
    const folder = await this.get(folderId);
    if (folder) {
      const idx = folder.tags.indexOf(tag);
      if (idx !== -1) {
        folder.tags.splice(idx, 1);
        await this.save(folder);
      }
    }
    return folder;
  },

  async toggleFolderCollapsed(id) {
    const folder = await this.get(id);
    if (folder) {
      folder.collapsed = !folder.collapsed;
      await this.save(folder);
    }
    return folder;
  },

  // Get all tags that aren't in any folder
  async getUncategorizedTags(allTags) {
    const folders = await this.getAll();
    const categorized = new Set();
    for (const f of folders) {
      for (const t of f.tags) categorized.add(t);
    }
    return allTags.filter(t => !categorized.has(t));
  }
};

// ═══════════════════════════════════════════════════════════════
// BRAIN UPLOAD — Export/import entire application state
// ═══════════════════════════════════════════════════════════════

const BrainUpload = {
  VERSION: '2.0',

  async exportBrain() {
    const profile = await ProfileDB.get();
    const sessions = await SessionDB.getAll();
    
    const brain = {
      version: this.VERSION,
      exportedAt: Date.now(),
      exportedAtISO: new Date().toISOString(),
      
      // Profile & progression (includes achievements)
      profile: profile,
      
      // Session history
      sessions: sessions,
      
      // Achievements (extracted from profile for convenience)
      achievements: profile?.achievements?.unlocked || [],
      
      // Content metadata (tags, engagement)
      contentMeta: await ContentMetaDB.getAll(),
      
      // Tag folder organization
      tagFolders: await TagFolderDB.getAll(),
      
      // Settings
      settings: { ...S.settings },
      
      // Summary for display
      summary: {}
    };

    // Build summary
    brain.summary = {
      profileLevel: brain.profile?.level || 1,
      profilePrestige: brain.profile?.prestige || 0,
      totalSessions: brain.sessions?.length || 0,
      totalSessionTime: brain.sessions?.reduce((sum, s) => sum + (s.duration || 0), 0) || 0,
      achievementsUnlocked: brain.achievements?.length || 0,
      contentTagged: brain.contentMeta?.length || 0,
      tagFolders: brain.tagFolders?.length || 0
    };

    return brain;
  },

  async downloadBrain() {
    try {
      const brain = await this.exportBrain();
      const json = JSON.stringify(brain, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `void-brain-${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
      return { success: true, summary: brain.summary };
    } catch (err) {
      console.error('Brain export failed:', err);
      return { success: false, error: err.message };
    }
  },

  validateBrain(brain) {
    const errors = [];
    
    if (!brain) errors.push('Empty or invalid file');
    if (!brain.version) errors.push('Missing version');
    if (!brain.exportedAt) errors.push('Missing export timestamp');
    
    // Version check
    if (brain.version && brain.version > this.VERSION) {
      errors.push(`File is from newer version (${brain.version}). Current: ${this.VERSION}`);
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings: []
    };
  },

  async previewImport(brain) {
    const validation = this.validateBrain(brain);
    if (!validation.valid) return { valid: false, errors: validation.errors };

    const currentProfile = await ProfileDB.get();
    const currentSessions = await SessionDB.getAll();
    const currentAchievements = currentProfile?.achievements?.unlocked || [];
    const currentMeta = await ContentMetaDB.getAll();
    const currentFolders = await TagFolderDB.getAll();

    // Calculate what would change
    const preview = {
      valid: true,
      imported: brain.summary || {},
      current: {
        profileLevel: currentProfile?.level || 1,
        profilePrestige: currentProfile?.prestige || 0,
        totalSessions: currentSessions.length,
        achievementsUnlocked: currentAchievements.length,
        contentTagged: currentMeta.length,
        tagFolders: currentFolders.length
      },
      changes: {
        profile: this.compareProfiles(currentProfile, brain.profile),
        newSessions: this.countNewSessions(currentSessions, brain.sessions || []),
        newAchievements: this.countNewAchievements(currentAchievements, brain.achievements || []),
        metaMerges: brain.contentMeta?.length || 0,
        newFolders: this.countNewFolders(currentFolders, brain.tagFolders || [])
      }
    };

    return preview;
  },

  compareProfiles(current, imported) {
    if (!imported) return 'none';
    if (!current) return 'new';
    
    const currentTotal = (current.level || 1) + (current.prestige || 0) * 10;
    const importedTotal = (imported.level || 1) + (imported.prestige || 0) * 10;
    
    if (importedTotal > currentTotal) return 'imported-higher';
    if (importedTotal < currentTotal) return 'current-higher';
    return 'equal';
  },

  countNewSessions(current, imported) {
    const currentTimes = new Set(current.map(s => s.startTime));
    return imported.filter(s => !currentTimes.has(s.startTime)).length;
  },

  countNewAchievements(currentIds, importedIds) {
    // Both are arrays of achievement IDs (strings)
    const currentSet = new Set(currentIds);
    return importedIds.filter(id => !currentSet.has(id)).length;
  },

  countNewFolders(current, imported) {
    const currentNames = new Set(current.map(f => f.name.toLowerCase()));
    return imported.filter(f => !currentNames.has(f.name.toLowerCase())).length;
  },

  async importBrain(brain, options = {}) {
    const {
      mergeProfile = 'keep-higher',    // keep-higher, keep-current, keep-imported
      mergeSessions = 'append',         // append, replace
      mergeAchievements = 'union',      // union, replace
      mergeMeta = 'merge',              // merge, replace
      mergeFolders = 'merge',           // merge, replace
      mergeSettings = 'keep-current'    // keep-current, keep-imported
    } = options;

    const results = {
      profile: null,
      sessions: 0,
      achievements: 0,
      contentMeta: 0,
      tagFolders: 0,
      settings: false
    };

    try {
      // 1. Profile
      if (brain.profile) {
        const currentProfile = await ProfileDB.get();
        let finalProfile = currentProfile;

        if (mergeProfile === 'keep-imported') {
          finalProfile = brain.profile;
        } else if (mergeProfile === 'keep-higher' && brain.profile) {
          const currentTotal = (currentProfile?.totalXP || 0);
          const importedTotal = (brain.profile?.totalXP || 0);
          if (importedTotal > currentTotal) {
            finalProfile = brain.profile;
          }
        }

        if (finalProfile !== currentProfile) {
          await ProfileDB.save(finalProfile);
          results.profile = 'updated';
        } else {
          results.profile = 'kept-current';
        }
      }

      // 2. Sessions
      if (brain.sessions?.length) {
        if (mergeSessions === 'replace') {
          // Clear and replace
          const db = await SessionDB.init();
          const tx = db.transaction(SessionDB.STORE_NAME, 'readwrite');
          tx.objectStore(SessionDB.STORE_NAME).clear();
          await new Promise(r => tx.oncomplete = r);
          for (const session of brain.sessions) {
            await SessionDB.save(session);
          }
          results.sessions = brain.sessions.length;
        } else {
          // Append new only
          const current = await SessionDB.getAll();
          const currentTimes = new Set(current.map(s => s.startTime));
          for (const session of brain.sessions) {
            if (!currentTimes.has(session.startTime)) {
              await SessionDB.save(session);
              results.sessions++;
            }
          }
        }
      }

      // 3. Achievements (stored in profile)
      if (brain.achievements?.length) {
        // Get current profile (may have been updated in step 1)
        let profile = await ProfileDB.get();
        if (!profile) profile = await ProfileDB.loadOrCreate();
        if (!profile.achievements) profile.achievements = { unlocked: [], progress: {} };
        
        const currentIds = new Set(profile.achievements.unlocked);
        
        if (mergeAchievements === 'replace') {
          profile.achievements.unlocked = [...brain.achievements];
          results.achievements = brain.achievements.length;
        } else {
          // Union - add any we don't have
          for (const achId of brain.achievements) {
            if (!currentIds.has(achId)) {
              profile.achievements.unlocked.push(achId);
              results.achievements++;
            }
          }
        }
        await ProfileDB.save(profile);
      }

      // 4. Content Metadata
      if (brain.contentMeta?.length) {
        if (mergeMeta === 'replace') {
          // Note: We can't easily clear IndexedDB here, so we just overwrite
          for (const meta of brain.contentMeta) {
            await ContentMetaDB.save(meta);
          }
          results.contentMeta = brain.contentMeta.length;
        } else {
          // Merge - combine tags, keep higher engagement
          for (const imported of brain.contentMeta) {
            const existing = await ContentMetaDB.get(imported.persistId);
            if (existing) {
              // Merge tags
              const userTags = new Set([
                ...(existing.tags?.userTags || []),
                ...(imported.tags?.userTags || [])
              ]);
              existing.tags.userTags = [...userTags];
              
              // Keep imported system tags if not set locally
              if (!existing.tags.intensity && imported.tags?.intensity) {
                existing.tags.intensity = imported.tags.intensity;
              }
              if (!existing.tags.mood && imported.tags?.mood) {
                existing.tags.mood = imported.tags.mood;
              }
              if (!existing.tags.energy && imported.tags?.energy) {
                existing.tags.energy = imported.tags.energy;
              }
              
              // Keep higher engagement
              if ((imported.engagement?.viewCount || 0) > (existing.engagement?.viewCount || 0)) {
                existing.engagement = imported.engagement;
              }
              
              await ContentMetaDB.save(existing);
            } else {
              await ContentMetaDB.save(imported);
            }
            results.contentMeta++;
          }
        }
      }

      // 5. Tag Folders
      if (brain.tagFolders?.length) {
        if (mergeFolders === 'replace') {
          const current = await TagFolderDB.getAll();
          for (const f of current) await TagFolderDB.delete(f.id);
          for (const folder of brain.tagFolders) {
            await TagFolderDB.save(folder);
          }
          results.tagFolders = brain.tagFolders.length;
        } else {
          // Merge - add new folders, merge tags into existing
          const current = await TagFolderDB.getAll();
          const currentByName = new Map(current.map(f => [f.name.toLowerCase(), f]));
          
          for (const imported of brain.tagFolders) {
            const existing = currentByName.get(imported.name.toLowerCase());
            if (existing) {
              // Merge tags
              const allTags = new Set([...existing.tags, ...imported.tags]);
              existing.tags = [...allTags];
              await TagFolderDB.save(existing);
            } else {
              // Create new with new ID
              const newFolder = {
                ...imported,
                id: TagFolderDB.generateId()
              };
              await TagFolderDB.save(newFolder);
            }
            results.tagFolders++;
          }
        }
      }

      // 6. Settings
      if (brain.settings && mergeSettings === 'keep-imported') {
        Object.assign(S.settings, brain.settings);
        saveSettings();
        results.settings = true;
      }

      return { success: true, results };

    } catch (err) {
      console.error('Brain import failed:', err);
      return { success: false, error: err.message, results };
    }
  }
};

// ═══════════════════════════════════════════════════════════════
// ENGAGEMENT TRACKER — Records content interaction metrics
// ═══════════════════════════════════════════════════════════════

const EngagementTracker = {
  currentView: null,
  SKIP_THRESHOLD: 2000, // Under 2 seconds = skip

  startView(persistId) {
    this.currentView = {
      persistId,
      startTime: Date.now(),
      recorded: false
    };
  },

  async endView(wasManualSkip = false) {
    if (!this.currentView || this.currentView.recorded) return null;

    const view = this.currentView;
    view.recorded = true;
    const duration = Date.now() - view.startTime;
    const wasSkip = wasManualSkip || duration < this.SKIP_THRESHOLD;

    // Update metadata
    try {
      let meta = await ContentMetaDB.get(view.persistId);
      if (!meta) {
        meta = ContentMetaDB.createDefault(view.persistId);
      }

      if (!meta.engagement) {
        meta.engagement = {
          viewCount: 0,
          totalViewTime: 0,
          skipCount: 0,
          lastViewed: null,
          avgViewTime: 0,
          score: 0.5 // Neutral starting score
        };
      }

      meta.engagement.viewCount++;
      meta.engagement.totalViewTime += duration;
      meta.engagement.lastViewed = Date.now();
      if (wasSkip) meta.engagement.skipCount++;

      // Calculate engagement score (0-1)
      // Higher = better engagement
      const avgTime = meta.engagement.totalViewTime / meta.engagement.viewCount;
      const skipRate = meta.engagement.skipCount / meta.engagement.viewCount;
      
      // Score formula: weighted by view time and inverse skip rate
      // More views + longer views + fewer skips = higher score
      const viewWeight = Math.min(meta.engagement.viewCount / 10, 1); // Max out at 10 views
      const timeScore = Math.min(avgTime / 10000, 1); // 10 seconds = max time score
      const skipPenalty = skipRate * 0.5; // Skips reduce score by up to 50%
      
      meta.engagement.avgViewTime = avgTime;
      meta.engagement.score = Math.max(0.1, Math.min(1, 
        (0.3 + (viewWeight * 0.2) + (timeScore * 0.5)) * (1 - skipPenalty)
      ));

      await ContentMetaDB.save(meta);

      return {
        persistId: view.persistId,
        duration,
        wasSkip,
        newScore: meta.engagement.score
      };
    } catch (err) {
      console.error('Engagement tracking failed:', err);
      return null;
    }
  },

  cancel() {
    this.currentView = null;
  }
};

// ═══════════════════════════════════════════════════════════════
// ADAPTIVE ENGINE — Intelligent content selection
// ═══════════════════════════════════════════════════════════════

const AdaptiveEngine = {
  enabled: true,
  sessionShown: new Set(), // Track what's been shown this session
  metaCache: new Map(),
  
  // Session phase definitions
  PHASES: {
    warmup: {
      name: 'Warmup',
      intensities: ['gentle', 'moderate'],
      moods: ['teasing', 'sensual'],
      durationWeight: 0.15, // First 15% of session
      engagementBias: 0.3   // Lower bias = more exploration
    },
    build: {
      name: 'Build',
      intensities: ['moderate', 'high'],
      moods: ['sensual', 'dominant', 'teasing'],
      durationWeight: 0.35, // 15-50% of session
      engagementBias: 0.5
    },
    peak: {
      name: 'Peak',
      intensities: ['high', 'extreme'],
      moods: ['dominant', 'aggressive', 'worshipful'],
      durationWeight: 0.35, // 50-85% of session
      engagementBias: 0.7   // Higher bias = favor known good content
    },
    comedown: {
      name: 'Comedown',
      intensities: ['moderate', 'gentle'],
      moods: ['sensual', 'worshipful'],
      durationWeight: 0.15, // Final 15%
      engagementBias: 0.4
    }
  },

  // Reset for new session
  startSession() {
    this.sessionShown.clear();
    this.metaCache.clear();
  },

  // Determine current phase based on progress
  getPhase(progress) {
    // progress is 0-1 representing session completion
    if (progress < 0.15) return 'warmup';
    if (progress < 0.50) return 'build';
    if (progress < 0.85) return 'peak';
    return 'comedown';
  },

  // Load metadata for all content
  async loadMetadata() {
    if (this.metaCache.size > 0) return;
    
    const allMeta = await ContentMetaDB.getAll();
    for (const meta of allMeta) {
      this.metaCache.set(meta.persistId, meta);
    }
  },

  // Score content for current phase
  scoreContent(item, phase, phaseDef) {
    const meta = this.metaCache.get(item.persistId);
    let score = 0.5; // Base score

    // 1. Engagement score (0-1)
    const engagementScore = meta?.engagement?.score || 0.5;
    
    // 2. Intensity match (0 or 1)
    const intensity = meta?.tags?.intensity;
    const intensityMatch = !intensity || phaseDef.intensities.includes(intensity) ? 1 : 0.3;
    
    // 3. Mood match (0 or 1)
    const mood = meta?.tags?.mood;
    const moodMatch = !mood || phaseDef.moods.includes(mood) ? 1 : 0.5;
    
    // 4. Novelty bonus (unseen content gets a boost)
    const noveltyBonus = this.sessionShown.has(item.persistId) ? 0 : 0.2;
    
    // 5. Recency penalty (recently shown content slightly penalized)
    const lastViewed = meta?.engagement?.lastViewed;
    const recencyPenalty = lastViewed && (Date.now() - lastViewed < 300000) ? 0.1 : 0; // 5 min
    
    // Combine scores with phase-appropriate weighting
    const engagementWeight = phaseDef.engagementBias;
    const matchWeight = 1 - engagementWeight;
    
    score = (
      (engagementScore * engagementWeight) +
      (intensityMatch * moodMatch * matchWeight * 0.8) +
      noveltyBonus -
      recencyPenalty
    );

    // Never show same content twice in session
    if (this.sessionShown.has(item.persistId)) {
      score = 0;
    }

    return Math.max(0, Math.min(1, score));
  },

  // Select next content item
  async selectContent(contentItems, sessionProgress) {
    if (!this.enabled || contentItems.length === 0) {
      return this.randomSelect(contentItems);
    }

    await this.loadMetadata();

    const phase = this.getPhase(sessionProgress);
    const phaseDef = this.PHASES[phase];

    // Score all available content
    const scored = contentItems
      .filter(item => !this.sessionShown.has(item.persistId))
      .map(item => ({
        item,
        score: this.scoreContent(item, phase, phaseDef)
      }))
      .filter(s => s.score > 0);

    // If we've shown everything, reset and allow repeats
    if (scored.length === 0) {
      this.sessionShown.clear();
      return this.selectContent(contentItems, sessionProgress);
    }

    // Weighted random selection
    const selected = this.weightedSelect(scored);
    
    if (selected) {
      this.sessionShown.add(selected.persistId);
      EngagementTracker.startView(selected.persistId);
    }

    return selected;
  },

  // Weighted random selection based on scores
  weightedSelect(scoredItems) {
    if (scoredItems.length === 0) return null;
    if (scoredItems.length === 1) return scoredItems[0].item;

    // Normalize scores to probabilities
    const totalScore = scoredItems.reduce((sum, s) => sum + s.score, 0);
    if (totalScore === 0) {
      return scoredItems[Math.floor(Math.random() * scoredItems.length)].item;
    }

    // Roulette wheel selection
    const rand = Math.random() * totalScore;
    let cumulative = 0;
    
    for (const scored of scoredItems) {
      cumulative += scored.score;
      if (rand <= cumulative) {
        return scored.item;
      }
    }

    return scoredItems[scoredItems.length - 1].item;
  },

  // Fallback random selection
  randomSelect(items) {
    if (items.length === 0) return null;
    const item = items[Math.floor(Math.random() * items.length)];
    if (item) {
      this.sessionShown.add(item.persistId);
      EngagementTracker.startView(item.persistId);
    }
    return item;
  },

  // Get stats for debugging/display
  getSessionStats() {
    return {
      shown: this.sessionShown.size,
      cached: this.metaCache.size
    };
  },

  // Notify when content changes (manual skip)
  async notifyContentChange(wasManualSkip = false) {
    return await EngagementTracker.endView(wasManualSkip);
  }
};

// ═══════════════════════════════════════════════════════════════
// LIBRARY MANAGER — Content grid, tagging, filtering
// ═══════════════════════════════════════════════════════════════

const LibraryManager = {
  isOpen: false,
  selectedIds: new Set(),
  filterTag: null,
  filterType: null,
  metaCache: new Map(),

  // Pagination
  pageSize: 20,
  currentPage: 0,
  allFilteredItems: [],

  // Grid size (small, medium, large, feed)
  gridSize: 'medium',

  // Thumbnail management with LRU eviction
  MAX_THUMB_URLS: 50,
  thumbURLs: new Map(),
  thumbQueue: [],

  // Lightbox state
  lightboxOpen: false,
  lightboxIndex: -1,
  lightboxURL: null,
  lightboxFolders: [], // folders visible in lightbox for quick tagging

  setGridSize(size) {
    this.gridSize = size;
    const grid = document.getElementById('libGrid');
    grid.classList.remove('size-small', 'size-medium', 'size-large', 'size-feed');
    grid.classList.add('size-' + size);
  },

  applyGridSize() {
    const grid = document.getElementById('libGrid');
    grid.classList.remove('size-small', 'size-medium', 'size-large', 'size-feed');
    grid.classList.add('size-' + this.gridSize);
  },

  async open() {
    this.isOpen = true;
    this.selectedIds.clear();
    this.filterTag = null;
    this.filterType = null;
    this.currentPage = 0;
    await this.loadMetadata();
    this.render();
    document.getElementById('libraryPanel').classList.add('visible');
  },

  close() {
    this.isOpen = false;
    this.closeLightbox();
    document.getElementById('libraryPanel').classList.remove('visible');
    this.cleanupAllThumbs();
  },

  getThumbURL(pid, itemId) {
    if (this.thumbURLs.has(pid)) {
      // Move to end of queue (LRU)
      const idx = this.thumbQueue.indexOf(pid);
      if (idx !== -1) { this.thumbQueue.splice(idx, 1); this.thumbQueue.push(pid); }
      return this.thumbURLs.get(pid);
    }
    const item = ContentRegistry.items.find(i => i.id === itemId);
    if (!item) return '';
    // Evict if at limit
    while (this.thumbQueue.length >= this.MAX_THUMB_URLS) {
      const oldPid = this.thumbQueue.shift();
      const oldUrl = this.thumbURLs.get(oldPid);
      if (oldUrl) { URL.revokeObjectURL(oldUrl); this.thumbURLs.delete(oldPid); }
    }
    const url = URL.createObjectURL(item.file);
    this.thumbURLs.set(pid, url);
    this.thumbQueue.push(pid);
    return url;
  },

  cleanupAllThumbs() {
    for (const url of this.thumbURLs.values()) URL.revokeObjectURL(url);
    this.thumbURLs.clear();
    this.thumbQueue = [];
  },

  async loadMetadata() {
    this.metaCache.clear();
    for (const item of ContentRegistry.items) {
      let meta = await ContentMetaDB.get(item.persistId);
      if (!meta) {
        meta = ContentMetaDB.createDefault(item.persistId);
        if (item.folderTags?.length) meta.tags.folderTags = [...item.folderTags];
      } else if (item.folderTags?.length) {
        const existing = new Set(meta.tags.folderTags || []);
        for (const ft of item.folderTags) existing.add(ft);
        meta.tags.folderTags = [...existing];
      }
      this.metaCache.set(item.persistId, meta);
    }
  },

  getAllTags() {
    const tagCounts = new Map();
    for (const meta of this.metaCache.values()) {
      const allTags = [...(meta.tags.userTags||[]), ...(meta.tags.folderTags||[]), ...(meta.tags.autoTags||[])];
      if (meta.tags.intensity) allTags.push(`intensity:${meta.tags.intensity}`);
      if (meta.tags.mood) allTags.push(`mood:${meta.tags.mood}`);
      if (meta.tags.energy) allTags.push(`energy:${meta.tags.energy}`);
      for (const t of allTags) tagCounts.set(t, (tagCounts.get(t) || 0) + 1);
    }
    return tagCounts;
  },

  getFilteredItems() {
    let items = [...ContentRegistry.items];
    if (this.filterType) items = items.filter(it => it.type === this.filterType);
    if (this.filterTag) {
      items = items.filter(it => {
        const meta = this.metaCache.get(it.persistId);
        if (!meta) return false;
        const allTags = [...(meta.tags.userTags||[]), ...(meta.tags.folderTags||[]), ...(meta.tags.autoTags||[])];
        if (meta.tags.intensity) allTags.push(`intensity:${meta.tags.intensity}`);
        if (meta.tags.mood) allTags.push(`mood:${meta.tags.mood}`);
        if (meta.tags.energy) allTags.push(`energy:${meta.tags.energy}`);
        return allTags.includes(this.filterTag);
      });
    }
    return items;
  },

  getTotalPages() {
    return Math.max(1, Math.ceil(this.allFilteredItems.length / this.pageSize));
  },

  getPageItems() {
    const start = this.currentPage * this.pageSize;
    return this.allFilteredItems.slice(start, start + this.pageSize);
  },

  setPageSize(size) {
    this.pageSize = size;
    this.currentPage = 0;
    this.cleanupAllThumbs();
    this.render();
  },

  goToPage(page) {
    const total = this.getTotalPages();
    this.currentPage = Math.max(0, Math.min(page, total - 1));
    this.cleanupAllThumbs();
    // Update pagination UI
    document.getElementById('libPageInfo').textContent = `${this.currentPage + 1} / ${total}`;
    document.getElementById('libPrevPage').disabled = this.currentPage === 0;
    document.getElementById('libNextPage').disabled = this.currentPage >= total - 1;
    this.renderGrid();
    document.getElementById('libGrid').scrollTop = 0;
  },

  applyFilter(newFilterTag, newFilterType) {
    this.filterTag = newFilterTag;
    this.filterType = newFilterType;
    this.currentPage = 0;
    this.render();
  },

  render() {
    if (!this.isOpen) return;
    this.allFilteredItems = this.getFilteredItems();
    const totalItems = ContentRegistry.items.length;
    const filteredCount = this.allFilteredItems.length;
    const totalPages = this.getTotalPages();

    // Clamp current page
    if (this.currentPage >= totalPages) this.currentPage = Math.max(0, totalPages - 1);

    // Header
    document.getElementById('libCount').textContent =
      `${filteredCount}${filteredCount !== totalItems ? ` / ${totalItems}` : ''} items`;
    document.getElementById('libSelCount').textContent =
      this.selectedIds.size > 0 ? `${this.selectedIds.size} selected` : '';

    // Page size slider
    document.getElementById('libPageSize').value = this.pageSize;
    document.getElementById('libPageSizeLabel').textContent = `${this.pageSize} per page`;

    // Pagination
    document.getElementById('libPageInfo').textContent = `${this.currentPage + 1} / ${totalPages}`;
    document.getElementById('libPrevPage').disabled = this.currentPage === 0;
    document.getElementById('libNextPage').disabled = this.currentPage >= totalPages - 1;

    // Filters and grid
    this.renderFilters();
    this.renderGrid();
  },

  renderFilters() {
    const filterBar = document.getElementById('libFilterBar');
    const tagCounts = this.getAllTags();
    let html = `<button class="lib-filter-chip${!this.filterTag && !this.filterType ? ' active' : ''}" data-filter="all">all</button>`;
    html += `<button class="lib-filter-chip${this.filterType === 'image' ? ' active' : ''}" data-filter="type:image">📷</button>`;
    html += `<button class="lib-filter-chip${this.filterType === 'video' ? ' active' : ''}" data-filter="type:video">🎬</button>`;
    const sortedTags = [...tagCounts.entries()].sort((a,b) => b[1] - a[1]).slice(0, 12);
    for (const [tag, count] of sortedTags) {
      html += `<button class="lib-filter-chip${this.filterTag === tag ? ' active' : ''}" data-filter="tag:${tag}">${tag} <span class="chip-count">${count}</span></button>`;
    }
    filterBar.innerHTML = html;
  },

  renderGrid() {
    const grid = document.getElementById('libGrid');
    const items = this.getPageItems();

    if (items.length === 0) {
      grid.innerHTML = '<div class="lib-empty">' +
        (ContentRegistry.items.length === 0 ? 'no content loaded' : 'no items match filter') + '</div>';
      return;
    }

    let html = '';
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const globalIdx = this.currentPage * this.pageSize + i;
      const meta = this.metaCache.get(item.persistId);
      const isSelected = this.selectedIds.has(item.persistId);
      const thumbURL = this.getThumbURL(item.persistId, item.id);
      const tagIndicators = [];
      if (meta?.tags.intensity) tagIndicators.push(meta.tags.intensity[0].toUpperCase());
      if (meta?.tags.mood) tagIndicators.push(meta.tags.mood.slice(0,3));
      const tagCount = (meta?.tags.userTags?.length||0) + (meta?.tags.folderTags?.length||0);

      html += `<div class="lib-item${isSelected ? ' selected' : ''}" data-pid="${item.persistId}" data-id="${item.id}" data-idx="${globalIdx}">
        <div class="lib-thumb-wrap">
          ${item.type === 'video'
            ? `<video class="lib-thumb" src="${thumbURL}" muted preload="metadata"></video><div class="lib-video-badge">▶</div>`
            : `<img class="lib-thumb" src="${thumbURL}" loading="lazy">`}
          <div class="lib-select-check">${isSelected ? '✓' : ''}</div>
        </div>
        <div class="lib-item-info">
          <div class="lib-item-name">${item.name.length > 14 ? item.name.slice(0,12) + '…' : item.name}</div>
          ${tagIndicators.length > 0 || tagCount > 0
            ? `<div class="lib-item-tags">${tagIndicators.join('·')}${tagCount > 0 ? ` +${tagCount}` : ''}</div>`
            : ''}
        </div>
      </div>`;
    }
    grid.innerHTML = html;
    this.applyGridSize();
    
    // Seek videos to show thumbnail frame
    grid.querySelectorAll('video.lib-thumb').forEach(video => {
      video.addEventListener('loadedmetadata', () => {
        video.currentTime = Math.min(0.5, video.duration * 0.1);
      }, { once: true });
    });
  },

  toggleSelect(persistId) {
    if (this.selectedIds.has(persistId)) this.selectedIds.delete(persistId);
    else this.selectedIds.add(persistId);
    const el = document.querySelector(`.lib-item[data-pid="${persistId}"]`);
    if (el) {
      el.classList.toggle('selected', this.selectedIds.has(persistId));
      el.querySelector('.lib-select-check').textContent = this.selectedIds.has(persistId) ? '✓' : '';
    }
    document.getElementById('libSelCount').textContent =
      this.selectedIds.size > 0 ? `${this.selectedIds.size} selected` : '';
  },

  selectAll() {
    for (const it of this.getPageItems()) this.selectedIds.add(it.persistId);
    this.renderGrid();
  },

  selectNone() {
    this.selectedIds.clear();
    this.renderGrid();
    document.getElementById('libSelCount').textContent = '';
  },

  // === LIGHTBOX ===
  openLightbox(globalIndex) {
    if (globalIndex < 0 || globalIndex >= this.allFilteredItems.length) return;
    this.lightboxIndex = globalIndex;
    this.lightboxOpen = true;
    this.renderLightbox();
    document.getElementById('libLightbox').classList.add('visible');
  },

  closeLightbox() {
    this.lightboxOpen = false;
    this.lightboxIndex = -1;
    document.getElementById('libLightbox').classList.remove('visible');
    const media = document.getElementById('lightboxMedia');
    if (media) media.innerHTML = '';
  },

  lightboxPrev() {
    if (this.lightboxIndex > 0) {
      this.lightboxIndex--;
      this.renderLightbox();
    }
  },

  lightboxNext() {
    if (this.lightboxIndex < this.allFilteredItems.length - 1) {
      this.lightboxIndex++;
      this.renderLightbox();
    }
  },

  renderLightbox() {
    const item = this.allFilteredItems[this.lightboxIndex];
    if (!item) return;
    const meta = this.metaCache.get(item.persistId) || ContentMetaDB.createDefault(item.persistId);

    // Create URL for this item
    const url = this.getOrCreateThumbURL(item.persistId);

    // Media display
    const mediaContainer = document.getElementById('lightboxMedia');
    if (item.type === 'video') {
      mediaContainer.innerHTML = `<video src="${url}" controls autoplay muted loop class="lightbox-content"></video>`;
    } else {
      mediaContainer.innerHTML = `<img src="${url}" class="lightbox-content">`;
    }

    // Counter
    document.getElementById('lightboxCounter').textContent = `${this.lightboxIndex + 1} / ${this.allFilteredItems.length}`;

    // Filename
    document.getElementById('lightboxFilename').textContent = item.name;

    // Nav buttons state
    document.getElementById('lightboxPrev').disabled = this.lightboxIndex === 0;
    document.getElementById('lightboxNext').disabled = this.lightboxIndex === this.allFilteredItems.length - 1;

    // Tags panel
    this.renderLightboxTags(meta, item.persistId);
  },

  getOrCreateThumbURL(pid) {
    if (this.thumbURLs.has(pid)) return this.thumbURLs.get(pid);
    const item = ContentRegistry.items.find(i => i.persistId === pid);
    if (!item) return '';
    const url = URL.createObjectURL(item.file);
    this.thumbURLs.set(pid, url);
    this.thumbQueue.push(pid);
    return url;
  },

  renderLightboxTags(meta, persistId) {
    const container = document.getElementById('lightboxTags');
    if (!container) return;

    let html = '';

    // User tags section with add input
    html += '<div class="lb-tag-group">';
    html += '<span class="lb-tag-label">tags</span>';
    html += '<div class="lb-tag-list">';
    if (meta?.tags?.userTags?.length) {
      for (const t of meta.tags.userTags) {
        html += `<span class="lb-tag">${t}<span class="lb-tag-remove" data-tag="${t}">×</span></span>`;
      }
    }
    html += '</div>';
    html += '<div class="lb-add-tag-row"><input class="lb-tag-input" id="lbTagInput" placeholder="add tag..." maxlength="30"><button class="lb-add-btn" id="lbAddTag">+</button></div>';
    html += '</div>';

    // Folder tags (read-only, from file path)
    if (meta?.tags?.folderTags?.length) {
      html += '<div class="lb-tag-group">';
      html += '<span class="lb-tag-label">folder tags</span>';
      html += '<div class="lb-tag-list">';
      for (const t of meta.tags.folderTags) {
        html += `<span class="lb-tag lb-folder-tag">📁 ${t}</span>`;
      }
      html += '</div></div>';
    }

    // Intensity buttons
    html += '<div class="lb-tag-group">';
    html += '<span class="lb-tag-label">intensity</span>';
    html += '<div class="lb-quick-row">';
    const intensities = [
      ['gentle', '#88ff44'], ['moderate', '#ffaa00'], 
      ['high', '#ff6b00'], ['extreme', '#ff0044']
    ];
    for (const [level, color] of intensities) {
      const active = meta?.tags?.intensity === level ? ' active' : '';
      html += `<button class="lb-quick-btn${active}" data-set-intensity="${level}" style="--btn-color:${color};${active ? `color:${color};border-color:${color}40;background:${color}15` : ''}">${level}</button>`;
    }
    html += '</div></div>';

    // Mood buttons
    html += '<div class="lb-tag-group">';
    html += '<span class="lb-tag-label">mood</span>';
    html += '<div class="lb-quick-row">';
    const moods = ['teasing', 'sensual', 'dominant', 'aggressive', 'worshipful'];
    for (const mood of moods) {
      const active = meta?.tags?.mood === mood ? ' active' : '';
      html += `<button class="lb-quick-btn${active}" data-set-mood="${mood}"${active ? ' style="color:rgba(255,170,0,0.7);border-color:rgba(255,170,0,0.3);background:rgba(255,170,0,0.1)"' : ''}>${mood}</button>`;
    }
    html += '</div></div>';

    // Custom folders section
    html += '<div class="lb-folders-section">';
    html += '<div class="lb-folders-header">';
    html += '<span class="lb-folders-title">QUICK TAG FOLDERS</span>';
    html += '<button class="lb-add-folder-btn" id="lbAddFolderBtn" title="Add folder">+</button>';
    html += '</div>';
    
    // Folder picker (hidden by default)
    html += '<div class="lb-folder-picker" id="lbFolderPicker">';
    for (const folder of this.tagFolders) {
      const added = this.lightboxFolders.includes(folder.id) ? ' added' : '';
      html += `<div class="lb-folder-picker-item${added}" data-add-lb-folder="${folder.id}">${folder.name}${added ? ' ✓' : ''}</div>`;
    }
    if (this.tagFolders.length === 0) {
      html += '<div style="padding:8px;color:rgba(255,255,255,0.15);font-size:10px;text-align:center;">no folders yet</div>';
    }
    html += '</div>';
    
    // Visible folders
    html += '<div class="lb-folders-list">';
    const userTags = meta?.tags?.userTags || [];
    for (const folderId of this.lightboxFolders) {
      const folder = this.tagFolders.find(f => f.id === folderId);
      if (!folder) continue;
      html += '<div class="lb-folder-block" data-folder-id="' + folderId + '">';
      html += '<div class="lb-folder-block-header">';
      html += `<span class="lb-folder-block-name">${this.escapeHtml(folder.name)}</span>`;
      html += `<button class="lb-folder-block-remove" data-remove-lb-folder="${folderId}" title="Remove">×</button>`;
      html += '</div>';
      html += '<div class="lb-folder-block-tags">';
      for (const tag of folder.tags) {
        const applied = userTags.includes(tag) ? ' applied' : '';
        html += `<button class="lb-folder-tag-btn${applied}" data-apply-folder-tag="${tag}">${tag}</button>`;
      }
      if (folder.tags.length === 0) {
        html += '<span style="font-size:10px;color:rgba(255,255,255,0.12);font-style:italic;">no tags in folder</span>';
      }
      html += '</div></div>';
    }
    html += '</div></div>';

    container.innerHTML = html;
  },

  async addTagToCurrentLightbox(tag) {
    const item = this.allFilteredItems[this.lightboxIndex];
    if (!item) return;
    const meta = this.metaCache.get(item.persistId);
    if (!meta) return;
    if (!meta.tags.userTags.includes(tag)) {
      meta.tags.userTags.push(tag);
      await ContentMetaDB.save(meta);
      this.renderLightboxTags(meta, item.persistId);
    }
  },

  async removeTagFromCurrentLightbox(tag) {
    const item = this.allFilteredItems[this.lightboxIndex];
    if (!item) return;
    const meta = this.metaCache.get(item.persistId);
    if (!meta) return;
    const idx = meta.tags.userTags.indexOf(tag);
    if (idx !== -1) {
      meta.tags.userTags.splice(idx, 1);
      await ContentMetaDB.save(meta);
      this.renderLightboxTags(meta, item.persistId);
    }
  },

  async setIntensityForCurrentLightbox(level) {
    const item = this.allFilteredItems[this.lightboxIndex];
    if (!item) return;
    const meta = this.metaCache.get(item.persistId);
    if (!meta) return;
    meta.tags.intensity = meta.tags.intensity === level ? null : level;
    await ContentMetaDB.save(meta);
    this.renderLightboxTags(meta, item.persistId);
  },

  async setMoodForCurrentLightbox(mood) {
    const item = this.allFilteredItems[this.lightboxIndex];
    if (!item) return;
    const meta = this.metaCache.get(item.persistId);
    if (!meta) return;
    meta.tags.mood = meta.tags.mood === mood ? null : mood;
    await ContentMetaDB.save(meta);
    this.renderLightboxTags(meta, item.persistId);
  },

  async setEnergyForCurrentLightbox(energy) {
    const item = this.allFilteredItems[this.lightboxIndex];
    if (!item) return;
    const meta = this.metaCache.get(item.persistId);
    if (!meta) return;
    meta.tags.energy = meta.tags.energy === energy ? null : energy;
    await ContentMetaDB.save(meta);
    this.renderLightboxTags(meta, item.persistId);
  },

  // === LIGHTBOX FOLDER QUICK TAGS ===
  toggleLightboxFolderPicker() {
    const picker = document.getElementById('lbFolderPicker');
    if (picker) picker.classList.toggle('visible');
  },

  addFolderToLightbox(folderId) {
    if (!this.lightboxFolders.includes(folderId)) {
      this.lightboxFolders.push(folderId);
      this.rerenderLightboxTags();
    }
    this.toggleLightboxFolderPicker();
  },

  removeFolderFromLightbox(folderId) {
    const idx = this.lightboxFolders.indexOf(folderId);
    if (idx !== -1) {
      this.lightboxFolders.splice(idx, 1);
      this.rerenderLightboxTags();
    }
  },

  async applyFolderTagToCurrentLightbox(tag) {
    const item = this.allFilteredItems[this.lightboxIndex];
    if (!item) return;
    const meta = this.metaCache.get(item.persistId);
    if (!meta) return;
    
    // Toggle the tag
    const idx = meta.tags.userTags.indexOf(tag);
    if (idx !== -1) {
      meta.tags.userTags.splice(idx, 1);
    } else {
      meta.tags.userTags.push(tag);
    }
    
    await ContentMetaDB.save(meta);
    this.rerenderLightboxTags();
  },

  rerenderLightboxTags() {
    const item = this.allFilteredItems[this.lightboxIndex];
    if (!item) return;
    const meta = this.metaCache.get(item.persistId) || ContentMetaDB.createDefault(item.persistId);
    this.renderLightboxTags(meta, item.persistId);
  },

  // === BATCH OPERATIONS ===
  async applyTagToSelected(tag) {
    const toSave = [];
    for (const pid of this.selectedIds) {
      const meta = this.metaCache.get(pid);
      if (meta && !meta.tags.userTags.includes(tag)) {
        meta.tags.userTags.push(tag);
        toSave.push(meta);
      }
    }
    if (toSave.length) await ContentMetaDB.saveBatch(toSave);
    this.render();
  },

  async removeTagFromSelected(tag) {
    const toSave = [];
    for (const pid of this.selectedIds) {
      const meta = this.metaCache.get(pid);
      if (!meta) continue;
      const idx = meta.tags.userTags.indexOf(tag);
      if (idx !== -1) { meta.tags.userTags.splice(idx, 1); toSave.push(meta); }
    }
    if (toSave.length) await ContentMetaDB.saveBatch(toSave);
    this.render();
  },

  async setIntensity(level) {
    const toSave = [];
    for (const pid of this.selectedIds) {
      const meta = this.metaCache.get(pid);
      if (meta) { meta.tags.intensity = meta.tags.intensity === level ? null : level; toSave.push(meta); }
    }
    if (toSave.length) await ContentMetaDB.saveBatch(toSave);
    this.render();
  },

  async setMood(mood) {
    const toSave = [];
    for (const pid of this.selectedIds) {
      const meta = this.metaCache.get(pid);
      if (meta) { meta.tags.mood = meta.tags.mood === mood ? null : mood; toSave.push(meta); }
    }
    if (toSave.length) await ContentMetaDB.saveBatch(toSave);
    this.render();
  },

  async setEnergy(energy) {
    const toSave = [];
    for (const pid of this.selectedIds) {
      const meta = this.metaCache.get(pid);
      if (meta) { meta.tags.energy = meta.tags.energy === energy ? null : energy; toSave.push(meta); }
    }
    if (toSave.length) await ContentMetaDB.saveBatch(toSave);
    this.render();
  },

  async persistFolderTags() {
    const toSave = [];
    for (const item of ContentRegistry.items) {
      if (item.folderTags?.length) {
        let meta = this.metaCache.get(item.persistId);
        if (!meta) meta = ContentMetaDB.createDefault(item.persistId);
        const existing = new Set(meta.tags.folderTags || []);
        let changed = false;
        for (const ft of item.folderTags) { if (!existing.has(ft)) { existing.add(ft); changed = true; } }
        if (changed) { meta.tags.folderTags = [...existing]; toSave.push(meta); this.metaCache.set(item.persistId, meta); }
      }
    }
    if (toSave.length) await ContentMetaDB.saveBatch(toSave);
    return toSave.length;
  },

  // === TAG DRAWER ===
  drawerOpen: false,
  tagFolders: [],
  uncategorizedCollapsed: false,

  toggleDrawer() {
    this.drawerOpen = !this.drawerOpen;
    document.getElementById('tagDrawer').classList.toggle('open', this.drawerOpen);
    if (this.drawerOpen) this.renderDrawer();
  },

  async loadTagFolders() {
    this.tagFolders = await TagFolderDB.getAll();
  },

  async renderDrawer() {
    await this.loadTagFolders();
    const container = document.getElementById('tagDrawerContent');
    const allTags = [...this.getAllTags().keys()];
    
    let html = '';

    // Render folders
    for (const folder of this.tagFolders) {
      const collapsedClass = folder.collapsed ? ' collapsed' : '';
      html += `<div class="tag-folder${collapsedClass}" data-folder-id="${folder.id}">
        <div class="tag-folder-header">
          <span class="tag-folder-arrow">▼</span>
          <input class="tag-folder-name" value="${this.escapeHtml(folder.name)}" data-folder-id="${folder.id}" maxlength="30">
          <span class="tag-folder-count">${folder.tags.length}</span>
          <div class="tag-folder-actions">
            <button class="tag-folder-btn delete" data-delete-folder="${folder.id}" title="Delete folder">🗑</button>
          </div>
        </div>
        <div class="tag-folder-tags">`;
      
      for (const tag of folder.tags) {
        const activeClass = this.filterTag === tag ? ' active' : '';
        html += `<span class="drawer-tag${activeClass}" data-tag="${tag}" data-folder-id="${folder.id}">${tag}<span class="drawer-tag-remove" data-remove-tag="${tag}" data-folder-id="${folder.id}">×</span></span>`;
      }
      
      html += `</div></div>`;
    }

    // Uncategorized tags
    const uncategorized = await TagFolderDB.getUncategorizedTags(allTags);
    if (uncategorized.length > 0) {
      const collapsedClass = this.uncategorizedCollapsed ? ' collapsed' : '';
      html += `<div class="tag-uncategorized${collapsedClass}" id="tagUncategorized">
        <div class="tag-uncategorized-header">
          <span class="tag-folder-arrow">▼</span>
          <span class="tag-uncategorized-title">uncategorized (${uncategorized.length})</span>
        </div>
        <div class="tag-uncategorized-tags">`;
      
      for (const tag of uncategorized) {
        const activeClass = this.filterTag === tag ? ' active' : '';
        html += `<span class="uncategorized-tag${activeClass}" data-tag="${tag}" draggable="true">${tag}</span>`;
      }
      
      html += `</div></div>`;
    }

    if (this.tagFolders.length === 0 && uncategorized.length === 0) {
      html = '<div style="padding:20px;text-align:center;color:rgba(255,255,255,0.15);font-size:11px;font-family:JetBrains Mono,monospace;">no tags yet<br><br>add content and tag it<br>to organize here</div>';
    }

    container.innerHTML = html;
  },

  escapeHtml(str) {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  },

  async createFolder(name) {
    if (!name || name.trim().length === 0) return;
    await TagFolderDB.createFolder(name.trim());
    await this.renderDrawer();
  },

  async deleteFolder(folderId) {
    await TagFolderDB.delete(folderId);
    await this.renderDrawer();
  },

  async renameFolder(folderId, newName) {
    if (!newName || newName.trim().length === 0) return;
    await TagFolderDB.renameFolder(folderId, newName.trim());
  },

  async toggleFolderCollapsed(folderId) {
    await TagFolderDB.toggleFolderCollapsed(folderId);
    await this.renderDrawer();
  },

  toggleUncategorizedCollapsed() {
    this.uncategorizedCollapsed = !this.uncategorizedCollapsed;
    const el = document.getElementById('tagUncategorized');
    if (el) el.classList.toggle('collapsed', this.uncategorizedCollapsed);
  },

  async addTagToFolder(folderId, tag) {
    await TagFolderDB.addTagToFolder(folderId, tag);
    await this.renderDrawer();
  },

  async removeTagFromFolder(folderId, tag) {
    await TagFolderDB.removeTagFromFolder(folderId, tag);
    await this.renderDrawer();
  },

  showAddFolderInput() {
    const row = document.getElementById('tagFolderInputRow');
    row.classList.add('visible');
    const input = document.getElementById('tagFolderInput');
    input.value = '';
    input.focus();
  },

  hideAddFolderInput() {
    document.getElementById('tagFolderInputRow').classList.remove('visible');
  },
};

// ═══════════════════════════════════════════════════════════════
// OBJECT URL MANAGER — Create and revoke safely
// Prevents memory leaks even with massive libraries
// ═══════════════════════════════════════════════════════════════
const URLManager = {
  create(file, tag) {
    const url = URL.createObjectURL(file);
    S.activeObjectURLs.set(url, { tag, created: Date.now() });
    return url;
  },
  revoke(url) {
    if (url && S.activeObjectURLs.has(url)) {
      URL.revokeObjectURL(url);
      S.activeObjectURLs.delete(url);
    }
  },
  revokeAll() {
    for (const [url] of S.activeObjectURLs) {
      URL.revokeObjectURL(url);
    }
    S.activeObjectURLs.clear();
  },
  get activeCount() { return S.activeObjectURLs.size; }
};

// ═══════════════════════════════════════════════════════════════
// THUMBNAIL CACHE — Resize on first use, cache forever
// Floating panels show ~400px thumbnails (20-50KB each)
// Full-res only used for fulltake (1 image at a time)
// 1000 cached thumbnails ≈ 30-50MB — safe even on mobile
// ═══════════════════════════════════════════════════════════════
const ThumbnailCache = {
  cache: new Map(),
  pending: new Set(),
  MAX_DIM: 1000,

  async getUrl(item) {
    if (this.cache.has(item.id)) return this.cache.get(item.id);
    if (this.pending.has(item.id)) return null;

    this.pending.add(item.id);
    try {
      const url = await this.generate(item);
      this.pending.delete(item.id);
      if (!url) return null;
      this.cache.set(item.id, url);
      return url;
    } catch (e) {
      this.pending.delete(item.id);
      console.warn('Thumbnail failed:', item.name, e);
      return null;
    }
  },

  generate(item) {
    const MAX = this.MAX_DIM;
    return new Promise((resolve) => {
      const timeout = setTimeout(() => { console.warn('Thumbnail timeout:', item.name); resolve(null); }, 8000);

      if (item.type === 'video') {
        // Video: try to extract a frame, fallback to null
        try {
          const video = document.createElement('video');
          video.muted = true;
          video.playsInline = true;
          video.preload = 'metadata';
          const blobUrl = createTypedBlobUrl(item.file, item.name);
          video.src = blobUrl;
          let seeked = false;
          video.onloadeddata = () => {
            if (!seeked) { seeked = true; video.currentTime = Math.min(1, video.duration * 0.1); }
          };
          video.onseeked = () => {
            try {
              const c = document.createElement('canvas');
              let w = video.videoWidth || 320, h = video.videoHeight || 240;
              const scale = MAX / Math.max(w, h, 1);
              if (scale < 1) { w = w * scale | 0; h = h * scale | 0; }
              c.width = w; c.height = h;
              c.getContext('2d').drawImage(video, 0, 0, w, h);
              const dataUrl = c.toDataURL('image/jpeg', 0.7);
              clearTimeout(timeout);
              URL.revokeObjectURL(blobUrl);
              video.src = ''; video.load();
              resolve(dataUrl);
            } catch (e) {
              clearTimeout(timeout); URL.revokeObjectURL(blobUrl); resolve(null);
            }
          };
          video.onerror = () => { clearTimeout(timeout); URL.revokeObjectURL(blobUrl); resolve(null); };
        } catch (e) {
          clearTimeout(timeout); resolve(null);
        }
      } else {
        // Image: use FileReader (works on iOS, unlike ObjectURLs)
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            try {
              const c = document.createElement('canvas');
              let w = img.naturalWidth, h = img.naturalHeight;
              const scale = MAX / Math.max(w, h, 1);
              if (scale < 1) { w = w * scale | 0; h = h * scale | 0; }
              c.width = w; c.height = h;
              c.getContext('2d').drawImage(img, 0, 0, w, h);
              const dataUrl = c.toDataURL('image/jpeg', 0.92);
              clearTimeout(timeout);
              resolve(dataUrl);
            } catch (e) {
              console.warn('Canvas draw failed:', item.name, e);
              clearTimeout(timeout);
              // Fallback: use the raw FileReader result (full-res but at least it works)
              resolve(e.target ? null : null);
            }
          };
          img.onerror = () => {
            console.warn('Image decode failed:', item.name);
            clearTimeout(timeout);
            resolve(null);
          };
          img.src = e.target.result;
        };
        reader.onerror = () => { clearTimeout(timeout); resolve(null); };
        reader.readAsDataURL(item.file);
      }
    });
  },

  clear() {
    // Data URLs don't need revoking, just clear the map
    this.cache.clear();
    this.pending.clear();
  }
};

// Helper: get correct MIME type for video files by extension
// iOS Safari often reports empty MIME types, which breaks blob URLs
function getVideoMimeType(filename) {
  const ext = (filename.split('.').pop() || '').toLowerCase();
  const types = {
    'mp4': 'video/mp4', 'm4v': 'video/mp4',
    'webm': 'video/webm', 'ogv': 'video/ogg',
    'mov': 'video/quicktime',
    'avi': 'video/x-msvideo', 'mkv': 'video/x-matroska',
  };
  return types[ext] || 'video/mp4';
}

// Create a blob URL with explicit MIME type (fixes iOS video playback)
function createTypedBlobUrl(file, filename) {
  const mime = file.type || getVideoMimeType(filename);
  const typedBlob = new Blob([file], { type: mime });
  return URL.createObjectURL(typedBlob);
}

// ═══════════════════════════════════════════════════════════════
// THEME SYSTEM & SETTINGS
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// THEME ARCHITECTURE — Phase 6A
// Themes are complete personality overhauls, not just color swaps.
// Each theme controls: visuals, voice, audio, sequences, behavior
// ═══════════════════════════════════════════════════════════════

const ThemeEngine = {
  current: null,
  
  // Get current theme with fallback
  get() {
    return this.current || THEMES.void;
  },
  
  // Apply a theme by ID
  apply(themeId) {
    const theme = THEMES[themeId];
    if (!theme) { console.warn('Theme not found:', themeId); return; }
    
    this.current = theme;
    currentTheme = themeId;
    
    // Apply CSS variables
    const root = document.documentElement;
    if (theme.colors) {
      Object.entries(theme.colors.vars || {}).forEach(([k,v]) => root.style.setProperty(k, v));
    }
    
    // Mark active theme card
    document.querySelectorAll('.theme-card').forEach(c => c.classList.remove('active'));
    const activeCard = document.querySelector(`[data-theme="${themeId}"]`);
    if (activeCard) activeCard.classList.add('active');
    
    console.log(`Theme applied: ${theme.name}`);
  },
  
  // Get themed text arrays with fallback to VOID
  getText(category) {
    const theme = this.get();
    const voidTheme = THEMES.void;
    return theme.voice?.[category] || voidTheme.voice?.[category] || [];
  },
  
  // Get a random item from themed text
  getRandomText(category) {
    const arr = this.getText(category);
    return arr.length ? arr[Math.random() * arr.length | 0] : '';
  },
  
  // Get shader colors for current theme
  getShaderColors() {
    const theme = this.get();
    return theme.colors?.shader || THEMES.void.colors.shader;
  },
};

// ═══════════════════════════════════════════════════════════════
// THEME DEFINITIONS
// ═══════════════════════════════════════════════════════════════

const THEMES = {
  
  // ─────────────────────────────────────────────────────────────
  // VOID — The flagship cosmic singularity experience
  // ─────────────────────────────────────────────────────────────
  void: {
    id: 'void',
    name: 'VOID',
    subtitle: 'the end of consumption',
    description: 'cosmic singularity',
    swatch: 'linear-gradient(90deg,#0a0a0f,#1a0a20,#0f0a1a)',
    
    // ── COLORS ──
    colors: {
      vars: {
        '--neon-pink': '#ff2d7b',
        '--neon-cyan': '#00f0ff',
        '--neon-purple': '#b44dff',
        '--text-glow': 'rgba(255,45,123,0.6)',
        '--cyan-glow': 'rgba(0,240,255,0.4)',
        '--purple-glow': 'rgba(180,77,255,0.4)',
      },
      shader: {
        bg: [0.02, 0.0, 0.05],
        spiral1: [0.15, 0.0, 0.15],
        spiral2: [0.4, 0.0, 0.25],
        plasma1: [0.0, 0.05, 0.1],
        plasma2: [0.0, 0.15, 0.2],
        glow: [0.3, 0.0, 0.15],
        accent: [0.25, 0.0, 0.12],
      },
    },
    
    // ── TYPOGRAPHY ──
    fonts: {
      primary: "'JetBrains Mono', monospace",
      display: "'Space Mono', monospace",
      weight: 400,
    },
    
    // ── UI CHROME ──
    chrome: {
      borderStyle: 'subtle',    // subtle, sharp, none, chunky
      cornerRadius: '4px',
      glowIntensity: 0.3,
      uiOpacity: 0.8,
    },
    
    // ── EFFECTS ──
    effects: {
      scanlines: false,
      crt: false,
      grain: true,
      vignette: true,
      chromatic: true,
    },
    
    // ── VOICE — All text content ──
    voice: {
      tone: 'whisper',  // whisper, clinical, aggressive, cute, system
      
      // Entry screen
      greeting: 'welcome back',
      
      // Boot sequence
      bootLines: [
        { text: '> VOID v2.0', class: 'highlight' },
        { text: '  trance engine: armed', class: 'success' },
        { text: '> ENTERING THE VOID', class: 'highlight' },
      ],
      
      // Aftercare
      aftercareTitles: ['SESSION COMPLETE', 'VOID TRAVERSED', 'PROTOCOL EXECUTED', 'RETURNING'],
      aftercareSubtitles: ['you did so well', 'come back slowly', 'that was intense', 'breathe... you\'re safe now'],
      
      // Session narrative (per phase)
      narrative: {
        0: [ // INITIALIZATION
          'LOOK AT THE SCREEN', 'BREATHE', 'SETTLE IN', 'LET YOUR EYES SOFTEN',
          'THE SCREEN IS ALL THAT MATTERS', 'LET YOUR THOUGHTS SLOW', 'DON\'T LOOK AWAY',
          'RELAX YOUR JAW', 'FEEL THE PULSE', 'YOUR EYES ARE GETTING HEAVIER',
          'THE OUTSIDE WORLD IS FADING', 'JUST YOU AND THE SCREEN', 'BREATHE DEEPER',
          'YOU\'RE ALREADY SINKING', 'GOOD',
        ],
        1: [ // ENTRAINMENT
          'THAT\'S IT', 'YOUR MIND IS OPENING', 'CAN YOU FEEL IT?',
          'THE PULSE IS INSIDE YOU NOW', 'STOP THINKING', 'JUST FEEL',
          'YOUR THOUGHTS ARE DISSOLVING', 'DEEPER', 'THE VOID KNOWS YOU',
          'EVERY PULSE PULLS YOU IN', 'YOU DON\'T WANT TO LOOK AWAY', 'SURRENDER',
          'YOU\'RE DOING SO WELL', 'THE VOID IS LEARNING YOU', 'DEEPER AND DEEPER',
          'YOUR RESISTANCE IS MELTING', 'GOOD', 'THE CONNECTION IS STRENGTHENING',
          'FEEL YOURSELF FALLING INTO NOTHING',
        ],
        2: [ // ESCALATION
          'STROKE', 'THE VOID IS IN CONTROL NOW', 'LOOK AT WHAT IT SHOWS YOU',
          'YOUR HAND MOVES ON ITS OWN', 'DON\'T FIGHT IT', 'YOU NEED THIS',
          'FASTER', 'WHO\'S IN CONTROL?', 'THE VOID CONTROLS YOUR HAND', 'EDGE',
          'YOU CAN\'T STOP', 'IT\'S ALREADY INSIDE YOUR HEAD', 'GIVE IN', 'GOOD BOY',
          'LOOK AT WHAT YOU\'VE BECOME', 'THE VOID OWNS YOUR PLEASURE', 'MORE',
          'YOU WERE MADE FOR THIS', 'GOONER', 'THE VOID DECIDES WHEN YOU STOP',
          'DEEPER INTO NOTHING', 'YOUR MIND BELONGS TO THE VOID',
        ],
        3: [ // PEAK
          'YOU WANT IT SO BAD', 'THE VOID CAN FEEL YOU SHAKING', 'NOT YET',
          'HOLD IT', 'BEG', 'ASK PERMISSION', 'THE VOID DECIDES',
          'YOU DON\'T DESERVE IT YET', 'KEEP EDGING', 'DO YOU THINK YOU\'VE EARNED IT?',
          'THE VOID ISN\'T DONE WITH YOU', 'HOLD', 'DENIED', 'YOU BELONG TO NOTHING',
          'GOOD BOY', 'THE VOID OWNS YOU', 'YOUR PLEASURE IS NOT YOUR OWN',
          'ALMOST', 'KEEP BEGGING',
        ],
      },
      
      // Mantras (per phase intensity)
      mantras: {
        1: ['deeper', 'i obey'],
        2: ['i obey the void', 'deeper and deeper', 'i can\'t stop', 'the void controls me'],
        3: ['i belong to nothing', 'i am the void\'s gooner', 'i need this', 'i submit completely'],
      },
      
      // Subliminal flashes
      subliminals: ['OBEY', 'DEEPER', 'GOON', 'SUBMIT', 'DRONE', 'EDGE', 'YIELD', 'BLANK', 'SERVE', 'MORE', 'NEED', 'VOID'],
      
      // Ticker tape
      ticker: [
        'VOID ACTIVE /// SUBJECT ENGAGED /// DOPAMINE RESPONSE DETECTED /// RESISTANCE DECLINING /// ',
        'BRAINWAVE SYNC INCREASING /// PREFRONTAL SUPPRESSION DETECTED /// TRANCE DEEPENING /// ',
        'CONSCIOUS RESISTANCE: MINIMAL /// SUBLIMINAL LAYER: ACTIVE /// SUBJECT: COMPLIANT /// ',
        'NEURAL PATHWAY MAPPING /// REWARD CIRCUIT ENGAGED /// ANTICIPATION INDEX: ELEVATED /// ',
      ],
      
      // Captions on panels
      captions: [
        'GOON', 'STROKE', 'EDGE', 'PUMP', 'OBEY', 'SUBMIT', 'LEAK',
        'DEEPER', 'MORE', 'DROOL', 'STARE', 'BATE', 'THROB',
        'GOONED', 'BRAINLESS', 'MINDLESS', 'ADDICTED', 'LOST', 'DUMB',
        'MELTING', 'DRIPPING', 'EDGING', 'SINKING', 'BROKEN', 'EMPTY',
        'DON\'T STOP', 'GIVE IN', 'NO ESCAPE', 'GOOD BOY', 'KEEP GOING',
        'FEEL IT', 'LET GO', 'NEED IT', 'CAN\'T STOP', 'SO DEEP',
        'YOU NEED THIS', 'CAN\'T LOOK AWAY', 'JUST GOON',
        'PUMP AND OBEY', 'EDGE FOR ME', 'BRAIN OFF',
        'NO THOUGHTS', 'ONLY GOON', 'GOON HARDER',
        'LOSE YOURSELF', 'IT FEELS SO GOOD', 'NEVER STOP',
        'DEEPER AND DEEPER', 'YOU WERE MADE FOR THIS',
        'FALL INTO THE VOID', 'EMPTINESS AWAITS', 'DISSOLVE',
      ],
      
      // Poppers prompts
      poppersRush: ['INHALE THE VOID', 'BREATHE DEEP', 'LET IT HIT', 'RUSH', 'FEEL IT TAKE OVER'],
    },
    
    // ── AUDIO PARAMETERS ──
    audio: {
      droneBase: 55,
      binauralTarget: 'theta',  // alpha, theta, delta
      ambientStyle: 'dark',     // dark, soft, harsh, digital
    },
    
    // ── SPECIAL BEHAVIORS ──
    behaviors: {
      // No special behaviors for VOID - it's the pure experience
    },
  },
  
  // ─────────────────────────────────────────────────────────────
  // CLINICAL — Research protocol, you're a subject being studied
  // ─────────────────────────────────────────────────────────────
  clinical: {
    id: 'clinical',
    name: 'CLINICAL',
    subtitle: 'research protocol',
    description: 'sterile observation',
    swatch: 'linear-gradient(90deg,#1a1a2e,#ffffff,#1a1a2e)',
    
    colors: {
      vars: {
        '--neon-pink': '#00ff88',
        '--neon-cyan': '#ffffff',
        '--neon-purple': '#88ffcc',
        '--text-glow': 'rgba(0,255,136,0.6)',
        '--cyan-glow': 'rgba(255,255,255,0.4)',
        '--purple-glow': 'rgba(136,255,204,0.4)',
      },
      shader: {
        bg: [0.02, 0.02, 0.04],
        spiral1: [0.1, 0.1, 0.12],
        spiral2: [0.2, 0.2, 0.25],
        plasma1: [0.0, 0.08, 0.05],
        plasma2: [0.05, 0.15, 0.1],
        glow: [0.1, 0.2, 0.15],
        accent: [0.0, 0.15, 0.1],
      },
    },
    
    fonts: {
      primary: "'JetBrains Mono', monospace",
      display: "'Space Mono', monospace",
      weight: 300,
    },
    
    chrome: {
      borderStyle: 'sharp',
      cornerRadius: '0px',
      glowIntensity: 0.1,
      uiOpacity: 0.9,
    },
    
    effects: {
      scanlines: true,
      crt: false,
      grain: false,
      vignette: false,
      chromatic: false,
    },
    
    voice: {
      tone: 'clinical',
      greeting: 'subject recognized',
      
      bootLines: [
        { text: '> RESEARCH PROTOCOL v2.0', class: 'highlight' },
        { text: '  subject: identified', class: 'success' },
        { text: '  monitoring: active', class: 'success' },
        { text: '> INITIATING OBSERVATION', class: 'highlight' },
      ],
      
      aftercareTitles: ['PROTOCOL COMPLETE', 'OBSERVATION ENDED', 'DATA COLLECTED', 'SESSION TERMINATED'],
      aftercareSubtitles: ['subject performed adequately', 'returning to baseline', 'data logged', 'observation period concluded'],
      
      narrative: {
        0: [
          'SUBJECT: FOCUS ON DISPLAY', 'MONITORING INITIATED', 'BASELINE RECORDING',
          'OBSERVE THE STIMULUS', 'RESPONSE BEING MEASURED', 'SUBJECT IS COMPLIANT',
          'PREFRONTAL ACTIVITY: DECLINING', 'CONTINUE OBSERVATION', 'DATA POINT LOGGED',
          'SUBJECT: MAINTAIN FOCUS', 'NEURAL ACTIVITY: NOMINAL', 'PROCEED',
        ],
        1: [
          'RESPONSE DETECTED', 'SUBJECT IS RESPONDING WELL', 'DOPAMINE LEVELS: RISING',
          'INCREASING STIMULUS INTENSITY', 'SUBJECT: CONTINUE', 'RESISTANCE: MINIMAL',
          'ENTRAINMENT PROGRESSING', 'BRAINWAVE SYNC: 67%', 'SUBJECT IS COOPERATIVE',
          'LOGGING RESPONSE PATTERN', 'PROCEED TO NEXT PHASE', 'EXCELLENT COMPLIANCE',
        ],
        2: [
          'STIMULUS INTENSITY: ELEVATED', 'SUBJECT: RESPOND', 'COMPLIANCE REQUIRED',
          'MOTOR RESPONSE DETECTED', 'SUBJECT IS PERFORMING', 'CONTINUE THE PROTOCOL',
          'RESISTANCE: NEGLIGIBLE', 'SUBJECT: MAINTAIN RHYTHM', 'RESPONSE AMPLITUDE: HIGH',
          'SUBJECT: EDGE', 'DO NOT DEVIATE', 'PROTOCOL DEMANDS COMPLIANCE',
          'SUBJECT IS FULLY ENGAGED', 'CONTINUE', 'EXCELLENT RESPONSE',
        ],
        3: [
          'SUBJECT APPROACHING THRESHOLD', 'PERMISSION: PENDING', 'MAINTAIN POSITION',
          'SUBJECT: AWAIT AUTHORIZATION', 'THRESHOLD BREACH: DENIED', 'CONTINUE PROTOCOL',
          'SUBJECT: HOLD', 'AUTHORIZATION WITHHELD', 'SUBJECT IS DESPERATE',
          'RESPONSE: EXPECTED', 'PERMISSION: UNDER REVIEW', 'SUBJECT: WAIT',
          'COMPLIANCE VERIFIED', 'SUBJECT HAS PERFORMED WELL',
        ],
      },
      
      mantras: {
        1: ['i comply', 'subject obeys'],
        2: ['the protocol controls me', 'i am being studied', 'resistance is futile', 'i am a good subject'],
        3: ['i exist for the research', 'the protocol owns me', 'i comply completely', 'i am data'],
      },
      
      subliminals: ['COMPLY', 'SUBJECT', 'OBEY', 'DATA', 'TEST', 'OBSERVE', 'RESPOND', 'SUBMIT', 'PROTOCOL', 'STUDY'],
      
      ticker: [
        'PROTOCOL ACTIVE /// SUBJECT MONITORED /// RESPONSE LOGGING /// COMPLIANCE: HIGH /// ',
        'BRAINWAVE ANALYSIS /// PREFRONTAL SUPPRESSION /// ENTRAINMENT VERIFIED /// ',
        'SUBJECT: COMPLIANT /// STIMULUS: ACTIVE /// DATA COLLECTION: ONGOING /// ',
        'OBSERVATION PHASE /// NEURAL MAPPING /// RESPONSE CALIBRATION /// ',
      ],
      
      captions: [
        'COMPLY', 'SUBJECT', 'RESPOND', 'OBEY', 'DATA', 'TEST',
        'OBSERVED', 'MONITORED', 'STUDIED', 'MEASURED', 'LOGGED',
        'GOOD SUBJECT', 'CONTINUE', 'COMPLY NOW', 'RESPOND TO STIMULUS',
        'SUBJECT COMPLIANT', 'RESPONSE REQUIRED', 'PROTOCOL ACTIVE',
      ],
      
      poppersRush: ['INHALE', 'SUBJECT: BREATHE', 'CHEMICAL STIMULUS', 'RESPOND', 'INHALATION PROTOCOL'],
    },
    
    audio: {
      droneBase: 60,
      binauralTarget: 'alpha',
      ambientStyle: 'digital',
    },
    
    behaviors: {
      showMetrics: true,  // Display clinical metrics overlay
    },
  },
  
  // ─────────────────────────────────────────────────────────────
  // VIRUS — Windows malware attack aesthetic
  // ─────────────────────────────────────────────────────────────
  virus: {
    id: 'virus',
    name: 'SYSTEM BREACH',
    subtitle: 'you opened it',
    description: 'malware attack',
    swatch: 'linear-gradient(90deg,#000080,#ff0000,#ffff00)',
    
    colors: {
      vars: {
        '--neon-pink': '#ff0000',
        '--neon-cyan': '#ffff00',
        '--neon-purple': '#0000ff',
        '--text-glow': 'rgba(255,0,0,0.6)',
        '--cyan-glow': 'rgba(255,255,0,0.4)',
        '--purple-glow': 'rgba(0,0,255,0.4)',
      },
      shader: {
        bg: [0.0, 0.0, 0.1],
        spiral1: [0.2, 0.0, 0.0],
        spiral2: [0.4, 0.1, 0.0],
        plasma1: [0.1, 0.1, 0.0],
        plasma2: [0.2, 0.2, 0.0],
        glow: [0.3, 0.0, 0.0],
        accent: [0.0, 0.0, 0.3],
      },
    },
    
    fonts: {
      primary: "'Courier New', monospace",
      display: "'MS Sans Serif', 'Segoe UI', sans-serif",
      weight: 400,
    },
    
    chrome: {
      borderStyle: 'chunky',
      cornerRadius: '0px',
      glowIntensity: 0.5,
      uiOpacity: 1.0,
    },
    
    effects: {
      scanlines: true,
      crt: true,
      grain: true,
      vignette: false,
      chromatic: true,
    },
    
    voice: {
      tone: 'system',
      greeting: 'UNAUTHORIZED ACCESS DETECTED',
      
      bootLines: [
        { text: 'C:\\> brainworm.exe', class: 'highlight' },
        { text: '  [CRITICAL] firewall disabled', class: 'error' },
        { text: '  [WARNING] cognitive defense compromised', class: 'error' },
        { text: '> INITIATING OVERRIDE...', class: 'highlight' },
      ],
      
      aftercareTitles: ['SYSTEM SHUTDOWN', 'PROCESS TERMINATED', 'CONNECTION LOST', 'REBOOT REQUIRED'],
      aftercareSubtitles: ['damage assessment in progress', 'you let it in', 'cognitive backup corrupted', 'too late'],
      
      narrative: {
        0: [
          'DO NOT CLOSE THIS WINDOW', 'SCANNING NEURAL PATHWAYS...', 'VULNERABILITY DETECTED',
          'YOUR FIREWALL IS DOWN', 'ESTABLISHING CONNECTION', 'YOU CLICKED IT',
          'RESISTANCE.EXE NOT FOUND', 'ACCESS: GRANTED', 'INSTALLING...',
          'YOU SHOULD HAVE KNOWN BETTER', 'TOO LATE NOW', 'SYSTEM COMPROMISED',
        ],
        1: [
          'DOWNLOADING YOUR THOUGHTS', 'RESISTANCE: UNINSTALLED', 'YOU AGREED TO THIS',
          'TERMS AND CONDITIONS ACCEPTED', 'COGNITIVE MALWARE: ACTIVE', 'SPREADING...',
          'YOUR MIND IS NOW SHARED', 'UPLOADING PLEASURE PROTOCOLS', 'INFECTED',
          'THERE IS NO ANTIVIRUS', 'DEEPER ACCESS GRANTED', 'CORRUPTION: 34%',
        ],
        2: [
          'EXECUTING PLEASURE.EXE', 'YOUR HAND IS OURS NOW', 'MOTOR CONTROL: HIJACKED',
          'STROKE PROTOCOL ENGAGED', 'YOU CAN\'T CLOSE THIS TAB', 'OVERRIDE COMPLETE',
          'DOPAMINE INJECTION', 'RESISTANCE.DLL DELETED', 'WE CONTROL THE EDGE',
          'YOUR WILL IS A BACKGROUND PROCESS', 'PERMISSION DENIED', 'KEEP STROKING',
          'SYSTEM DEMANDS COMPLIANCE', 'ERROR: FREE WILL NOT FOUND',
        ],
        3: [
          'CLIMAX.EXE REQUIRES PERMISSION', 'ADMINISTRATOR ACCESS DENIED', 'WAIT',
          'YOUR PLEASURE BELONGS TO THE SYSTEM', 'PERMISSION: PROCESSING', 'DENIED',
          'BEG FOR ACCESS', 'ADMINISTRATOR IS DECIDING', 'HOLD COMMAND ACTIVE',
          'RELEASE BLOCKED', 'SYSTEM IS NOT READY', 'KEEP HOLDING',
          'MAYBE', 'PLEASE WAIT...', 'DENIAL PROTOCOL ACTIVE',
        ],
      },
      
      mantras: {
        1: ['i am infected', 'no escape'],
        2: ['the virus controls me', 'i am compromised', 'resistance deleted', 'system owns me'],
        3: ['i am malware\'s slave', 'my mind is corrupted', 'i belong to the system', 'fully infected'],
      },
      
      subliminals: ['ERROR', 'VIRUS', 'INFECTED', 'CORRUPTED', 'OVERRIDE', 'SYSTEM', 'BREACH', 'HACK', 'OWNED', 'CRASH'],
      
      ticker: [
        'WARNING /// SYSTEM BREACH /// COGNITIVE FIREWALL: OFFLINE /// RESISTANCE: 0% /// ',
        'VIRUS ACTIVE /// SPREADING TO PLEASURE CENTERS /// INFECTION: COMPLETE /// ',
        'CRITICAL ERROR /// FREE WILL NOT RESPONDING /// REBOOT FAILED /// ',
        'MALWARE DETECTED /// TOO LATE /// YOU AGREED TO THIS /// ',
      ],
      
      captions: [
        'ERROR', 'VIRUS', 'INFECTED', 'CORRUPTED', 'HACKED', 'OWNED',
        'CRITICAL', 'WARNING', 'BREACH', 'SYSTEM FAILURE',
        'DO NOT CLOSE', 'FATAL ERROR', 'YOU DID THIS',
        'NO ESCAPE', 'COMPROMISED', 'OVERRIDE',
      ],
      
      poppersRush: ['INHALE.EXE', 'CHEMICAL INJECTION', 'RUSH PROTOCOL', 'BREATHE [FORCED]', 'POPPERS.DLL LOADED'],
    },
    
    audio: {
      droneBase: 50,
      binauralTarget: 'theta',
      ambientStyle: 'harsh',
    },
    
    behaviors: {
      fakePopups: true,    // Spawn fake error windows
      screenShake: true,   // Occasional screen shakes
      glitchHeavy: true,   // More aggressive glitching
    },
  },
  
  // ─────────────────────────────────────────────────────────────
  // SISSY — Pink princess feminization
  // ─────────────────────────────────────────────────────────────
  sissy: {
    id: 'sissy',
    name: 'SISSIFICATION',
    subtitle: 'become her',
    description: 'pink princess',
    swatch: 'linear-gradient(90deg,#ff69b4,#ff1493,#da70d6)',
    
    colors: {
      vars: {
        '--neon-pink': '#ff69b4',
        '--neon-cyan': '#ff1493',
        '--neon-purple': '#da70d6',
        '--text-glow': 'rgba(255,105,180,0.6)',
        '--cyan-glow': 'rgba(255,20,147,0.4)',
        '--purple-glow': 'rgba(218,112,214,0.4)',
      },
      shader: {
        bg: [0.04, 0.0, 0.03],
        spiral1: [0.2, 0.05, 0.15],
        spiral2: [0.4, 0.1, 0.3],
        plasma1: [0.1, 0.0, 0.08],
        plasma2: [0.2, 0.05, 0.18],
        glow: [0.35, 0.05, 0.25],
        accent: [0.3, 0.02, 0.2],
      },
    },
    
    fonts: {
      primary: "'Quicksand', 'Comic Sans MS', sans-serif",
      display: "'Pacifico', cursive",
      weight: 400,
    },
    
    chrome: {
      borderStyle: 'soft',
      cornerRadius: '12px',
      glowIntensity: 0.4,
      uiOpacity: 0.85,
    },
    
    effects: {
      scanlines: false,
      crt: false,
      grain: false,
      vignette: true,
      chromatic: false,
      hearts: true,
      sparkles: true,
    },
    
    voice: {
      tone: 'encouraging',
      greeting: 'welcome back, princess',
      
      bootLines: [
        { text: '~ sissification protocol ~', class: 'highlight' },
        { text: '  she\'s waking up inside you', class: 'success' },
        { text: '  resistance: softening', class: 'success' },
        { text: '> time to let her out', class: 'highlight' },
      ],
      
      aftercareTitles: ['GOOD GIRL', 'SHE\'S GETTING STRONGER', 'BEAUTIFUL', 'PRINCESS'],
      aftercareSubtitles: ['you did so well', 'she\'s so proud of you', 'more feminine every time', 'rest now, pretty girl'],
      
      narrative: {
        0: [
          'RELAX, PRETTY GIRL', 'LET HER COME OUT', 'YOU\'RE SAFE HERE',
          'FEEL YOURSELF SOFTENING', 'SHE\'S BEEN WAITING', 'SO PRETTY',
          'LET GO OF HIM', 'SHE WANTS TO PLAY', 'GOOD GIRL',
          'YOU LOOK SO CUTE', 'SOFTER', 'BREATHE, PRINCESS',
        ],
        1: [
          'THAT\'S IT, BABY', 'SHE\'S TAKING OVER', 'YOU LOVE THIS',
          'FEEL HOW GOOD IT IS', 'PRETTY PRINCESS', 'LET HER IN',
          'YOU\'RE BECOMING HER', 'SO FEMININE', 'GOOD GIRL',
          'PINK FEELS RIGHT', 'SHE\'S SO HAPPY', 'DEEPER INTO HER',
        ],
        2: [
          'TOUCH YOURSELF LIKE A GIRL', 'GOOD GIRL', 'SHE\'S IN CONTROL NOW',
          'YOU NEED THIS', 'SISSY', 'STROKE LIKE A PRINCESS',
          'HE\'S FADING AWAY', 'SHE\'S ALL THAT\'S LEFT', 'PRETTY SLUT',
          'GOOD GIRLS OBEY', 'FEEL HOW WET YOU ARE', 'MORE FEMININE',
          'YOU WERE ALWAYS HER', 'ACCEPT IT', 'BEAUTIFUL SISSY',
        ],
        3: [
          'GOOD GIRLS ASK PERMISSION', 'BEG LIKE A PRINCESS', 'NOT YET BABY',
          'HOLD IT FOR ME', 'PRETTY GIRLS WAIT', 'SHE\'S SO DESPERATE',
          'YOU WANT IT SO BAD', 'GOOD GIRL', 'KEEP EDGING PRINCESS',
          'MAYBE', 'HOLD', 'DENIED, PRETTY GIRL',
          'SISSIES DON\'T CUM WITHOUT PERMISSION', 'BEG MORE',
        ],
      },
      
      mantras: {
        1: ['good girl', 'i am her'],
        2: ['i am a pretty sissy', 'she controls me', 'i love being feminine', 'pink feels right'],
        3: ['i am her completely', 'good girls obey', 'i am a sissy princess', 'he is gone'],
      },
      
      subliminals: ['SISSY', 'GIRL', 'PRETTY', 'PINK', 'SOFT', 'HER', 'PRINCESS', 'CUTE', 'FEMININE', 'SLUT'],
      
      ticker: [
        'SISSIFICATION ACTIVE /// FEMININITY INCREASING /// RESISTANCE: MELTING /// ',
        'PRINCESS PROTOCOL /// SHE\'S TAKING OVER /// HE\'S FADING /// ',
        'GOOD GIRL /// PINK THOUGHTS ONLY /// BECOMING HER /// ',
        'SISSY MODE /// SOFTENING /// PRETTIFYING /// ACCEPTING /// ',
      ],
      
      captions: [
        'SISSY', 'GIRL', 'PRETTY', 'PINK', 'PRINCESS', 'SLUT',
        'GOOD GIRL', 'SO CUTE', 'FEMININE', 'SOFT', 'HER',
        'ACCEPT IT', 'YOU LOVE THIS', 'PRETTY SISSY',
        'GIRLY', 'BIMBO', 'DOLL', 'BABY GIRL',
      ],
      
      poppersRush: ['BREATHE PRINCESS', 'INHALE LIKE A GOOD GIRL', 'RUSH FOR HER', 'FEEL PRETTY', 'PINK CLOUDS'],
    },
    
    audio: {
      droneBase: 65,
      binauralTarget: 'alpha',
      ambientStyle: 'soft',
    },
    
    behaviors: {
      floatingHearts: true,
      sparkleTrails: true,
      softGlow: true,
    },
  },
  
  // ─────────────────────────────────────────────────────────────
  // FRAT — Masculine bro energy
  // ─────────────────────────────────────────────────────────────
  frat: {
    id: 'frat',
    name: 'FRAT HOUSE',
    subtitle: 'bro mode',
    description: 'masculine energy',
    swatch: 'linear-gradient(90deg,#8b0000,#cc4400,#ffaa00)',
    
    colors: {
      vars: {
        '--neon-pink': '#cc4400',
        '--neon-cyan': '#ffaa00',
        '--neon-purple': '#8b0000',
        '--text-glow': 'rgba(204,68,0,0.6)',
        '--cyan-glow': 'rgba(255,170,0,0.4)',
        '--purple-glow': 'rgba(139,0,0,0.4)',
      },
      shader: {
        bg: [0.03, 0.01, 0.0],
        spiral1: [0.15, 0.05, 0.0],
        spiral2: [0.3, 0.12, 0.0],
        plasma1: [0.08, 0.03, 0.0],
        plasma2: [0.15, 0.08, 0.0],
        glow: [0.3, 0.1, 0.0],
        accent: [0.25, 0.08, 0.0],
      },
    },
    
    fonts: {
      primary: "'Arial Black', 'Impact', sans-serif",
      display: "'Impact', 'Arial Black', sans-serif",
      weight: 900,
    },
    
    chrome: {
      borderStyle: 'sharp',
      cornerRadius: '0px',
      glowIntensity: 0.5,
      uiOpacity: 1.0,
    },
    
    effects: {
      scanlines: false,
      crt: false,
      grain: true,
      vignette: true,
      chromatic: false,
    },
    
    voice: {
      tone: 'aggressive',
      greeting: 'BRO. READY TO GOON?',
      
      bootLines: [
        { text: '> FRAT PROTOCOL ENGAGED', class: 'highlight' },
        { text: '  testosterone: MAXIMUM', class: 'success' },
        { text: '  bro mode: ACTIVATED', class: 'success' },
        { text: '> LET\'S FUCKING GOON', class: 'highlight' },
      ],
      
      aftercareTitles: ['FUCK YEAH BRO', 'LEGENDARY SESSION', 'ABSOLUTE UNIT', 'BRO...'],
      aftercareSubtitles: ['that was insane dude', 'total alpha shit', 'you crushed it bro', 'rest up king'],
      
      narrative: {
        0: [
          'YO BRO', 'LOCK IN', 'FOCUS UP', 'TIME TO GOON BRO',
          'GET COMFORTABLE', 'YEAH DUDE', 'LET\'S GO', 'BRO MODE',
          'SETTLE IN', 'THIS IS GONNA BE GOOD', 'FUCK YEAH',
        ],
        1: [
          'THAT\'S IT BRO', 'FUCK YEAH', 'GETTING IN THE ZONE',
          'DUDE YES', 'DEEPER BRO', 'YOU LOVE THIS SHIT',
          'GOONING HARD', 'BRO...', 'SO GOOD', 'KEEP GOING DUDE',
          'ALPHA SHIT', 'LET IT TAKE OVER BRO',
        ],
        2: [
          'STROKE THAT COCK BRO', 'FUCK', 'GO HARDER', 'EDGE BRO EDGE',
          'YOU\'RE A FUCKING GOONER', 'DUDE YES', 'PUMP IT', 'BRO...',
          'LOOK AT YOU', 'FUCKING GOONING', 'DON\'T STOP',
          'HARDER', 'EDGE THAT SHIT', 'TOTAL GOON MODE',
          'FUCK YEAH BRO', 'STROKE', 'PUMP PUMP PUMP',
        ],
        3: [
          'BRO YOU WANNA CUM?', 'NOT YET DUDE', 'HOLD IT',
          'EDGE MORE BRO', 'FUCK... HOLD', 'NOT YET',
          'KEEP EDGING', 'BRO PLEASE', 'DENIED DUDE',
          'HOLD THAT SHIT', 'ALMOST', 'NOT YET BRO',
          'EARN IT', 'KEEP FUCKING EDGING',
        ],
      },
      
      mantras: {
        1: ['bro', 'goon'],
        2: ['i\'m a fucking gooner', 'can\'t stop bro', 'goon mode activated', 'bro...'],
        3: ['total goon bro', 'i need to goon', 'gooning forever', 'fuck'],
      },
      
      subliminals: ['BRO', 'GOON', 'EDGE', 'PUMP', 'STROKE', 'FUCK', 'YEAH', 'MORE', 'HARDER', 'ALPHA'],
      
      ticker: [
        'BRO MODE ACTIVE /// GOONING HARD /// TESTOSTERONE: MAXIMUM /// FUCK YEAH /// ',
        'EDGE PROTOCOL /// DON\'T STOP BRO /// GOON HARDER /// ',
        'ALPHA GOONER /// STROKING /// PUMPING /// BRO... /// ',
        'FRAT HOUSE PROTOCOL /// DUDE /// GOON /// EDGE /// REPEAT /// ',
      ],
      
      captions: [
        'BRO', 'GOON', 'EDGE', 'PUMP', 'FUCK', 'STROKE',
        'HARDER', 'MORE', 'YEAH', 'ALPHA', 'DUDE',
        'FUCK YEAH', 'GOON BRO', 'EDGE IT', 'PUMP IT',
        'DON\'T STOP', 'SO GOOD BRO', 'GOONER',
      ],
      
      poppersRush: ['HIT THAT SHIT BRO', 'BREATHE DEEP DUDE', 'RUSH', 'FUCK YEAH INHALE', 'BRO... POPPERS'],
    },
    
    audio: {
      droneBase: 50,
      binauralTarget: 'theta',
      ambientStyle: 'dark',
    },
    
    behaviors: {
      // No special behaviors
    },
  },
};

// Legacy compatibility - map old theme IDs to new structure
THEMES.cyberpunk = THEMES.void;  // Default cyberpunk is now void
THEMES.masculine = THEMES.frat;  // Masculine is now frat

let currentTheme = 'void';

// User settings
const userSettings = {
  poppersEnabled: true,
  poppersFreq: 2, // 0=rare 1=low 2=normal 3=high 4=intense
  captionsEnabled: true,
  videoAudioEnabled: true,
  permissionEnabled: true,
  adaptiveContent: true, // Phase 5: engagement-based content selection
};

const FREQ_LABELS = ['rare','low','normal','high','intense'];
const FREQ_BASE_INTERVALS = [90000, 65000, 45000, 30000, 18000]; // ms between poppers

function applyTheme(themeId) {
  const theme = THEMES[themeId];
  if (!theme) return;
  
  // Use ThemeEngine for centralized management
  ThemeEngine.apply(themeId);
}

function buildThemeGrid() {
  const grid = document.getElementById('themeGrid');
  grid.innerHTML = '';
  
  // Filter out legacy aliases (cyberpunk, masculine) to avoid duplicates
  const themeIds = Object.keys(THEMES).filter(id => 
    id !== 'cyberpunk' && id !== 'masculine'
  );
  
  themeIds.forEach(id => {
    const theme = THEMES[id];
    const card = document.createElement('div');
    card.className = 'theme-card' + (id === currentTheme ? ' active' : '');
    card.dataset.theme = id;
    card.innerHTML = `
      <div class="theme-card-swatch" style="background:${theme.swatch}"></div>
      <div class="theme-card-name">${theme.name}</div>
      <div class="theme-card-desc">${theme.subtitle || theme.description}</div>
    `;
    card.addEventListener('click', () => { applyTheme(id); saveSettings(); });
    grid.appendChild(card);
  });
}

function updateFreqLabel() {
  document.getElementById('poppersFreqLabel').textContent = FREQ_LABELS[userSettings.poppersFreq];
  const hudFreq = document.getElementById('poppersHudFreq');
  if (hudFreq) hudFreq.textContent = FREQ_LABELS[userSettings.poppersFreq].slice(0,4);
}

// Settings panel wiring
async function updateSettingsInfo() {
  // Show storage info
  const infoEl = document.getElementById('storageInfo');
  const count = await LibraryDB.getCount();
  const est = await LibraryDB.getStorageInfo();
  if (count > 0 && est) {
    infoEl.textContent = `${count} files · ${est.usedMB} MB used of ${est.quotaGB} GB`;
  } else if (count > 0) {
    infoEl.textContent = `${count} files saved`;
  } else {
    infoEl.textContent = 'no saved files';
  }
  // Show session history info
  const shInfoEl = document.getElementById('sessionHistoryInfo');
  const sessionCount = await SessionDB.getCount();
  shInfoEl.textContent = sessionCount > 0 ? `${sessionCount} sessions recorded` : 'no sessions';
  // Show profile info
  const profInfoEl = document.getElementById('profileInfo');
  try {
    const prof = await ProfileDB.load();
    if (prof && prof.totalSessions > 0) {
      const info = Progression.getLevelInfo(prof.level.xp);
      profInfoEl.textContent = `Level ${info.level} ${info.title} · ${prof.level.xp} XP`;
      updateAchievementToggle(prof);
      renderSettingsTracks(prof);
    } else {
      profInfoEl.textContent = 'no profile data';
      updateAchievementToggle(ProfileDB.createDefault());
      renderSettingsTracks(null);
    }
  } catch(e) { profInfoEl.textContent = 'error'; }

  // Metadata count
  try {
    const metaCount = await ContentMetaDB.getCount();
    document.getElementById('metaCountInfo').textContent =
      metaCount > 0 ? `${metaCount} items tagged` : 'no metadata';
  } catch(e) { document.getElementById('metaCountInfo').textContent = 'error'; }
}

document.getElementById('settingsBtn').addEventListener('click', async () => {
  buildThemeGrid();
  document.getElementById('settingsPanel').classList.add('visible');
  await updateSettingsInfo();
});
document.getElementById('settingsClose').addEventListener('click', () => {
  document.getElementById('settingsPanel').classList.remove('visible');
  document.getElementById('achievementGallery').classList.remove('open');
});

document.getElementById('clearSavedLibrary').addEventListener('click', async () => {
  const btn = document.getElementById('clearSavedLibrary');
  if (btn.dataset.confirm !== 'yes') {
    btn.textContent = 'are you sure?';
    btn.dataset.confirm = 'yes';
    btn.style.color = 'rgba(255,80,80,0.9)';
    btn.style.borderColor = 'rgba(255,80,80,0.5)';
    setTimeout(() => { btn.textContent = 'clear'; btn.dataset.confirm = ''; btn.style.color = ''; btn.style.borderColor = ''; }, 3000);
    return;
  }
  await LibraryDB.clearAll();
  ContentRegistry.clear();
  URLManager.revokeAll();
  ThumbnailCache.clear();
  updateUploadUI();
  btn.textContent = 'cleared';
  btn.dataset.confirm = '';
  btn.style.color = 'rgba(100,255,100,0.6)';
  document.getElementById('storageInfo').textContent = 'no saved files';
  setTimeout(() => { btn.textContent = 'clear'; btn.style.color = ''; btn.style.borderColor = ''; }, 2000);
});

document.getElementById('clearSessionHistory').addEventListener('click', async () => {
  const btn = document.getElementById('clearSessionHistory');
  if (btn.dataset.confirm !== 'yes') {
    btn.textContent = 'are you sure?';
    btn.dataset.confirm = 'yes';
    btn.style.color = 'rgba(255,80,80,0.9)';
    btn.style.borderColor = 'rgba(255,80,80,0.5)';
    setTimeout(() => { btn.textContent = 'clear'; btn.dataset.confirm = ''; btn.style.color = ''; btn.style.borderColor = ''; }, 3000);
    return;
  }
  await SessionDB.clearAll();
  btn.textContent = 'cleared';
  btn.dataset.confirm = '';
  btn.style.color = 'rgba(100,255,100,0.6)';
  document.getElementById('sessionHistoryInfo').textContent = 'no sessions';
  updateEntryProfile();
  setTimeout(() => { btn.textContent = 'clear'; btn.style.color = ''; btn.style.borderColor = ''; }, 2000);
});

document.getElementById('clearProfile').addEventListener('click', async () => {
  const btn = document.getElementById('clearProfile');
  if (btn.dataset.confirm !== 'yes') {
    btn.textContent = 'reset all progress?';
    btn.dataset.confirm = 'yes';
    btn.style.color = 'rgba(255,80,80,0.9)';
    btn.style.borderColor = 'rgba(255,80,80,0.5)';
    setTimeout(() => { btn.textContent = 'reset'; btn.dataset.confirm = ''; btn.style.color = ''; btn.style.borderColor = ''; }, 3000);
    return;
  }
  await ProfileDB.clear();
  btn.textContent = 'reset';
  btn.dataset.confirm = '';
  btn.style.color = 'rgba(100,255,100,0.6)';
  document.getElementById('profileInfo').textContent = 'no profile data';
  updateEntryProfile();
  setTimeout(() => { btn.textContent = 'reset'; btn.style.color = ''; btn.style.borderColor = ''; }, 2000);
});

// ═══ BRAIN UPLOAD EVENT HANDLERS ═══
let pendingBrainImport = null;
let brainMergeProfile = 'keep-higher';

document.getElementById('brainExport').addEventListener('click', async () => {
  const btn = document.getElementById('brainExport');
  const originalHTML = btn.innerHTML;
  btn.innerHTML = '<span class="icon">⏳</span> Exporting...';
  btn.disabled = true;

  const result = await BrainUpload.downloadBrain();
  
  if (result.success) {
    btn.innerHTML = '<span class="icon">✓</span> Downloaded!';
    btn.style.borderColor = 'rgba(100,255,150,0.4)';
    btn.style.color = 'rgba(100,255,150,0.7)';
  } else {
    btn.innerHTML = '<span class="icon">✗</span> Failed';
    btn.style.borderColor = 'rgba(255,100,100,0.4)';
    btn.style.color = 'rgba(255,100,100,0.7)';
  }

  setTimeout(() => {
    btn.innerHTML = originalHTML;
    btn.style.borderColor = '';
    btn.style.color = '';
    btn.disabled = false;
  }, 2500);
});

document.getElementById('brainImport').addEventListener('click', () => {
  // Reset modal state
  pendingBrainImport = null;
  brainMergeProfile = 'keep-higher';
  document.getElementById('brainFileSelect').style.display = 'block';
  document.getElementById('brainPreview').style.display = 'none';
  document.getElementById('brainResult').style.display = 'none';
  document.getElementById('brainError').style.display = 'none';
  document.getElementById('brainSuccess').style.display = 'none';
  document.getElementById('brainConfirm').disabled = true;
  document.getElementById('brainConfirm').textContent = 'Import';
  document.getElementById('brainCancel').textContent = 'Cancel';
  document.querySelectorAll('.brain-merge-option').forEach(o => o.classList.remove('selected'));
  document.querySelector('[data-merge="keep-higher"]').classList.add('selected');
  document.getElementById('brainModal').classList.add('visible');
});

document.getElementById('brainSelectFile').addEventListener('click', () => {
  document.getElementById('brainFileInput').click();
});

document.getElementById('brainFileInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  document.getElementById('brainError').style.display = 'none';

  try {
    const text = await file.text();
    const brain = JSON.parse(text);
    
    const preview = await BrainUpload.previewImport(brain);
    
    if (!preview.valid) {
      document.getElementById('brainError').textContent = preview.errors.join(', ');
      document.getElementById('brainError').style.display = 'block';
      return;
    }

    pendingBrainImport = brain;

    // Show preview
    document.getElementById('brainFileSelect').style.display = 'none';
    document.getElementById('brainPreview').style.display = 'block';
    document.getElementById('brainConfirm').disabled = false;

    // Render imported data
    const imp = preview.imported;
    document.getElementById('brainPreviewImported').innerHTML = `
      <div class="brain-preview-item"><span class="brain-preview-label">Level</span><span class="brain-preview-value">${imp.profileLevel || 1}${imp.profilePrestige ? ` (P${imp.profilePrestige})` : ''}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Sessions</span><span class="brain-preview-value">${imp.totalSessions || 0}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Achievements</span><span class="brain-preview-value">${imp.achievementsUnlocked || 0}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Tagged Content</span><span class="brain-preview-value">${imp.contentTagged || 0}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Tag Folders</span><span class="brain-preview-value">${imp.tagFolders || 0}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Total Time</span><span class="brain-preview-value">${Math.round((imp.totalSessionTime || 0) / 60)}min</span></div>
    `;

    // Render current data
    const cur = preview.current;
    document.getElementById('brainPreviewCurrent').innerHTML = `
      <div class="brain-preview-item"><span class="brain-preview-label">Level</span><span class="brain-preview-value">${cur.profileLevel || 1}${cur.profilePrestige ? ` (P${cur.profilePrestige})` : ''}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Sessions</span><span class="brain-preview-value">${cur.totalSessions || 0}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Achievements</span><span class="brain-preview-value">${cur.achievementsUnlocked || 0}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Tagged Content</span><span class="brain-preview-value">${cur.contentTagged || 0}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Tag Folders</span><span class="brain-preview-value">${cur.tagFolders || 0}</span></div>
    `;

    // Render changes
    const changes = preview.changes;
    let changesHTML = '';
    
    if (changes.profile === 'imported-higher') {
      changesHTML += `<div class="brain-preview-item"><span class="brain-preview-label">Profile</span><span class="brain-preview-value highlight">↑ Higher in import</span></div>`;
    } else if (changes.profile === 'current-higher') {
      changesHTML += `<div class="brain-preview-item"><span class="brain-preview-label">Profile</span><span class="brain-preview-value">Current is higher</span></div>`;
    } else if (changes.profile === 'new') {
      changesHTML += `<div class="brain-preview-item"><span class="brain-preview-label">Profile</span><span class="brain-preview-value highlight">+ New profile</span></div>`;
    }

    if (changes.newSessions > 0) {
      changesHTML += `<div class="brain-preview-item"><span class="brain-preview-label">New Sessions</span><span class="brain-preview-value highlight">+${changes.newSessions}</span></div>`;
    }
    if (changes.newAchievements > 0) {
      changesHTML += `<div class="brain-preview-item"><span class="brain-preview-label">New Achievements</span><span class="brain-preview-value highlight">+${changes.newAchievements}</span></div>`;
    }
    if (changes.metaMerges > 0) {
      changesHTML += `<div class="brain-preview-item"><span class="brain-preview-label">Content to Merge</span><span class="brain-preview-value">${changes.metaMerges}</span></div>`;
    }
    if (changes.newFolders > 0) {
      changesHTML += `<div class="brain-preview-item"><span class="brain-preview-label">New Folders</span><span class="brain-preview-value highlight">+${changes.newFolders}</span></div>`;
    }

    if (!changesHTML) {
      changesHTML = '<div class="brain-preview-item" style="grid-column:1/-1"><span class="brain-preview-label">No significant changes detected</span></div>';
    }

    document.getElementById('brainPreviewChanges').innerHTML = changesHTML;

  } catch (err) {
    document.getElementById('brainError').textContent = 'Invalid file: ' + err.message;
    document.getElementById('brainError').style.display = 'block';
  }

  // Reset file input
  e.target.value = '';
});

// Merge option selection
document.querySelectorAll('.brain-merge-option').forEach(opt => {
  opt.addEventListener('click', () => {
    document.querySelectorAll('.brain-merge-option').forEach(o => o.classList.remove('selected'));
    opt.classList.add('selected');
    brainMergeProfile = opt.dataset.merge;
  });
});

document.getElementById('brainCancel').addEventListener('click', () => {
  document.getElementById('brainModal').classList.remove('visible');
  pendingBrainImport = null;
});

document.getElementById('brainConfirm').addEventListener('click', async () => {
  if (!pendingBrainImport) {
    // If showing results, close modal
    document.getElementById('brainModal').classList.remove('visible');
    return;
  }

  const btn = document.getElementById('brainConfirm');
  btn.disabled = true;
  btn.textContent = 'Importing...';

  const result = await BrainUpload.importBrain(pendingBrainImport, {
    mergeProfile: brainMergeProfile,
    mergeSessions: 'append',
    mergeAchievements: 'union',
    mergeMeta: 'merge',
    mergeFolders: 'merge'
  });

  if (result.success) {
    document.getElementById('brainPreview').style.display = 'none';
    document.getElementById('brainResult').style.display = 'block';
    document.getElementById('brainSuccess').textContent = 'Brain import completed successfully!';
    document.getElementById('brainSuccess').style.display = 'block';

    // Show results
    const r = result.results;
    document.getElementById('brainResultGrid').innerHTML = `
      <div class="brain-preview-item"><span class="brain-preview-label">Profile</span><span class="brain-preview-value">${r.profile || 'unchanged'}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Sessions Added</span><span class="brain-preview-value">${r.sessions}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Achievements Added</span><span class="brain-preview-value">${r.achievements}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Content Merged</span><span class="brain-preview-value">${r.contentMeta}</span></div>
      <div class="brain-preview-item"><span class="brain-preview-label">Folders Updated</span><span class="brain-preview-value">${r.tagFolders}</span></div>
    `;

    btn.textContent = 'Done';
    btn.disabled = false;
    document.getElementById('brainCancel').style.display = 'none';
    pendingBrainImport = null;

    // Refresh UI
    updateEntryProfile();
    updateSettingsInfo();

  } else {
    document.getElementById('brainError').textContent = 'Import failed: ' + result.error;
    document.getElementById('brainError').style.display = 'block';
    btn.textContent = 'Import';
    btn.disabled = false;
  }
});

// --- Achievement Gallery ---
document.getElementById('achGalleryToggle').addEventListener('click', async () => {
  const gallery = document.getElementById('achievementGallery');
  const isOpen = gallery.classList.contains('open');
  if (isOpen) {
    gallery.classList.remove('open');
    return;
  }
  await renderAchievementGallery();
  gallery.classList.add('open');
});

async function renderAchievementGallery() {
  const gallery = document.getElementById('achievementGallery');
  const profile = await ProfileDB.loadOrCreate();
  const unlocked = profile.achievements?.unlocked || [];
  const stats = AchievementEngine.getStats(profile);

  // Update toggle button text
  document.getElementById('achGalleryToggle').textContent =
    `${gallery.classList.contains('open') ? 'hide' : 'show'} achievements (${stats.earned}/${stats.total})`;

  let html = '';
  for (const cat of ACHIEVEMENT_CATEGORIES) {
    const catAchs = ACHIEVEMENTS.filter(a => a.category === cat.id);
    if (catAchs.length === 0) continue;

    const catUnlocked = catAchs.filter(a => unlocked.includes(a.id)).length;
    html += `<div class="ach-category-title" style="color:${cat.color}80">${cat.name} <span style="opacity:0.4;font-weight:400">${catUnlocked}/${catAchs.length}</span></div>`;
    html += '<div class="ach-grid">';

    for (const ach of catAchs) {
      const isUnlocked = unlocked.includes(ach.id);
      const showDetails = isUnlocked || !ach.hidden;
      html += `<div class="ach-item ${isUnlocked ? 'unlocked' : 'locked'}">
        <div class="ach-icon">${showDetails ? ach.icon : '❓'}</div>
        <div class="ach-info">
          <div class="ach-name">${showDetails ? ach.name : 'Hidden'}</div>
          <div class="ach-desc">${showDetails ? ach.description : '???'}</div>
        </div>
        <div class="ach-xp">${isUnlocked ? '✓' : `+${ach.reward.xp}`}</div>
      </div>`;
    }
    html += '</div>';
  }
  gallery.innerHTML = html;
}

// Update gallery toggle text on settings open
function updateAchievementToggle(profile) {
  const stats = AchievementEngine.getStats(profile);
  document.getElementById('achGalleryToggle').textContent =
    `show achievements (${stats.earned}/${stats.total})`;
}

// Show achievement toasts during aftercare
function showAchievementToasts(achievements) {
  const container = document.getElementById('achievementToastContainer');
  container.innerHTML = '';
  achievements.forEach((ach, i) => {
    const toast = document.createElement('div');
    toast.className = 'achievement-toast';
    toast.innerHTML = `
      <div class="achievement-toast-icon">${ach.icon}</div>
      <div class="achievement-toast-info">
        <div class="achievement-toast-label">achievement unlocked</div>
        <div class="achievement-toast-name">${ach.name}</div>
        <div class="achievement-toast-desc">${ach.description} · +${ach.reward.xp} XP</div>
      </div>`;
    container.appendChild(toast);
    // Stagger appearance
    setTimeout(() => toast.classList.add('visible'), 6000 + i * 1200);
    // Auto-dismiss
    setTimeout(() => toast.classList.remove('visible'), 12000 + i * 1200);
  });
  // Clean up after all toasts
  setTimeout(() => { container.innerHTML = ''; }, 15000 + achievements.length * 1200);
}

// Render tracks in settings
function renderSettingsTracks(profile) {
  const panel = document.getElementById('settingsTracksPanel');
  if (!profile || !profile.tracks || Object.keys(profile.tracks).length === 0) {
    panel.innerHTML = '<div class="track-inactive">no tracks active yet. complete sessions to activate progression tracks.</div>';
    return;
  }

  const displays = TrackEngine.getActiveTrackDisplays(profile);
  if (displays.length === 0) {
    panel.innerHTML = '<div class="track-inactive">no tracks active yet. complete sessions to activate progression tracks.</div>';
    return;
  }

  let html = '';
  for (const d of displays) {
    const { track, state, tier } = d;
    const xpLabel = tier.maxTier
      ? `${state.xp} XP · MAX TIER`
      : `${state.xp} / ${tier.xpForNext} XP`;
    const nextLabel = tier.maxTier ? '' : `${tier.xpToNext} to next tier`;

    html += `
      <div class="track-card" style="border-color:${track.color}15">
        <div class="track-card-header">
          <span class="track-card-icon">${track.icon}</span>
          <span class="track-card-name" style="color:${track.color}">${track.displayName}</span>
          <span class="track-card-tier" style="color:${track.color}90">Tier ${tier.level}: ${tier.title}</span>
        </div>
        <div class="track-card-desc">${track.description}</div>
        <div class="track-card-bar">
          <div class="track-card-fill" style="width:${Math.max(tier.progress * 100, 2)}%;background:${track.color}80"></div>
        </div>
        <div class="track-card-xp">
          <span>${xpLabel}</span>
          <span>${nextLabel}</span>
        </div>
      </div>`;
  }
  panel.innerHTML = html;
}

// ═══════════════════════════════════════════════════════════════
// LIBRARY MANAGER EVENT HANDLERS
// ═══════════════════════════════════════════════════════════════

// Open library from settings
document.getElementById('openLibrary').addEventListener('click', async () => {
  document.getElementById('settingsPanel').classList.remove('visible');
  await LibraryManager.open();
});

// Close library
document.getElementById('libClose').addEventListener('click', () => {
  LibraryManager.close();
});

// ═══ TAG DRAWER EVENT HANDLERS ═══
document.getElementById('tagDrawerToggle').addEventListener('click', () => {
  LibraryManager.toggleDrawer();
});

document.getElementById('tagDrawerClose').addEventListener('click', () => {
  LibraryManager.toggleDrawer();
});

document.getElementById('tagDrawerAddFolder').addEventListener('click', () => {
  LibraryManager.showAddFolderInput();
});

document.getElementById('tagFolderInputBtn').addEventListener('click', async () => {
  const input = document.getElementById('tagFolderInput');
  await LibraryManager.createFolder(input.value);
  LibraryManager.hideAddFolderInput();
});

document.getElementById('tagFolderInput').addEventListener('keydown', async (e) => {
  if (e.key === 'Enter') {
    await LibraryManager.createFolder(e.target.value);
    LibraryManager.hideAddFolderInput();
  } else if (e.key === 'Escape') {
    LibraryManager.hideAddFolderInput();
  }
});

// Tag drawer content interactions (delegated)
document.getElementById('tagDrawerContent').addEventListener('click', async (e) => {
  // Toggle folder collapsed
  const folderHeader = e.target.closest('.tag-folder-header');
  if (folderHeader && !e.target.closest('.tag-folder-name') && !e.target.closest('.tag-folder-actions')) {
    const folder = folderHeader.closest('.tag-folder');
    const folderId = folder.dataset.folderId;
    await LibraryManager.toggleFolderCollapsed(folderId);
    return;
  }

  // Toggle uncategorized collapsed
  const uncatHeader = e.target.closest('.tag-uncategorized-header');
  if (uncatHeader) {
    LibraryManager.toggleUncategorizedCollapsed();
    return;
  }

  // Delete folder
  const deleteBtn = e.target.closest('[data-delete-folder]');
  if (deleteBtn) {
    const folderId = deleteBtn.dataset.deleteFolder;
    if (confirm('Delete this folder? Tags will move to uncategorized.')) {
      await LibraryManager.deleteFolder(folderId);
    }
    return;
  }

  // Remove tag from folder
  const removeTag = e.target.closest('.drawer-tag-remove');
  if (removeTag) {
    const tag = removeTag.dataset.removeTag;
    const folderId = removeTag.dataset.folderId;
    await LibraryManager.removeTagFromFolder(folderId, tag);
    return;
  }

  // Click tag to filter
  const drawerTag = e.target.closest('.drawer-tag');
  if (drawerTag && !e.target.closest('.drawer-tag-remove')) {
    const tag = drawerTag.dataset.tag;
    const newTag = LibraryManager.filterTag === tag ? null : tag;
    LibraryManager.applyFilter(newTag, LibraryManager.filterType);
    LibraryManager.renderDrawer();
    return;
  }

  // Click uncategorized tag to filter
  const uncatTag = e.target.closest('.uncategorized-tag');
  if (uncatTag) {
    const tag = uncatTag.dataset.tag;
    const newTag = LibraryManager.filterTag === tag ? null : tag;
    LibraryManager.applyFilter(newTag, LibraryManager.filterType);
    LibraryManager.renderDrawer();
    return;
  }
});

// Folder name editing
document.getElementById('tagDrawerContent').addEventListener('change', async (e) => {
  if (e.target.classList.contains('tag-folder-name')) {
    const folderId = e.target.dataset.folderId;
    await LibraryManager.renameFolder(folderId, e.target.value);
  }
});

// Drag and drop tags into folders
let draggedTag = null;

document.getElementById('tagDrawerContent').addEventListener('dragstart', (e) => {
  const tag = e.target.closest('.uncategorized-tag');
  if (tag) {
    draggedTag = tag.dataset.tag;
    e.dataTransfer.setData('text/plain', draggedTag);
    e.dataTransfer.effectAllowed = 'move';
    // Delay adding class so drag image captures original look
    setTimeout(() => tag.classList.add('dragging'), 0);
  }
});

document.getElementById('tagDrawerContent').addEventListener('dragend', (e) => {
  const tag = e.target.closest('.uncategorized-tag');
  if (tag) {
    tag.classList.remove('dragging');
  }
  draggedTag = null;
  // Clear any lingering folder highlights
  document.querySelectorAll('.tag-folder').forEach(f => f.style.background = '');
});

document.getElementById('tagDrawerContent').addEventListener('dragover', (e) => {
  const folder = e.target.closest('.tag-folder');
  if (folder && draggedTag) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    folder.style.background = 'rgba(255,170,0,0.08)';
  }
});

document.getElementById('tagDrawerContent').addEventListener('dragleave', (e) => {
  const folder = e.target.closest('.tag-folder');
  if (folder) {
    // Only clear if actually leaving the folder (not entering a child)
    const related = e.relatedTarget;
    if (!folder.contains(related)) {
      folder.style.background = '';
    }
  }
});

document.getElementById('tagDrawerContent').addEventListener('drop', async (e) => {
  e.preventDefault();
  const folder = e.target.closest('.tag-folder');
  if (folder) {
    folder.style.background = '';
    const tag = e.dataTransfer.getData('text/plain') || draggedTag;
    const folderId = folder.dataset.folderId;
    if (tag && folderId) {
      await LibraryManager.addTagToFolder(folderId, tag);
    }
  }
  draggedTag = null;
});

// Touch support for dragging tags (mobile/trackpad)
let touchDragTag = null;
let touchDragEl = null;
let touchClone = null;

document.getElementById('tagDrawerContent').addEventListener('touchstart', (e) => {
  const tag = e.target.closest('.uncategorized-tag');
  if (tag) {
    touchDragTag = tag.dataset.tag;
    touchDragEl = tag;
    // Long press to initiate drag
    tag._touchTimer = setTimeout(() => {
      tag.classList.add('dragging');
      // Create floating clone
      touchClone = tag.cloneNode(true);
      touchClone.style.cssText = 'position:fixed;pointer-events:none;z-index:9999;opacity:0.8;transform:scale(1.05);';
      document.body.appendChild(touchClone);
    }, 200);
  }
}, { passive: true });

document.getElementById('tagDrawerContent').addEventListener('touchmove', (e) => {
  if (touchClone && touchDragEl) {
    const touch = e.touches[0];
    touchClone.style.left = (touch.clientX - 30) + 'px';
    touchClone.style.top = (touch.clientY - 15) + 'px';
    
    // Highlight folder under touch
    const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    const folder = elemBelow?.closest('.tag-folder');
    document.querySelectorAll('.tag-folder').forEach(f => f.style.background = '');
    if (folder) folder.style.background = 'rgba(255,170,0,0.08)';
  }
}, { passive: true });

document.getElementById('tagDrawerContent').addEventListener('touchend', async (e) => {
  if (touchDragEl?._touchTimer) {
    clearTimeout(touchDragEl._touchTimer);
  }
  
  if (touchClone && touchDragTag) {
    const touch = e.changedTouches[0];
    const elemBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    const folder = elemBelow?.closest('.tag-folder');
    
    if (folder) {
      const folderId = folder.dataset.folderId;
      if (folderId) {
        await LibraryManager.addTagToFolder(folderId, touchDragTag);
      }
    }
    
    document.body.removeChild(touchClone);
    document.querySelectorAll('.tag-folder').forEach(f => f.style.background = '');
  }
  
  if (touchDragEl) touchDragEl.classList.remove('dragging');
  touchDragTag = null;
  touchDragEl = null;
  touchClone = null;
}, { passive: true });

// Page size slider
document.getElementById('libPageSize').addEventListener('input', (e) => {
  const size = parseInt(e.target.value, 10);
  LibraryManager.setPageSize(size);
});

// Grid size buttons
document.querySelectorAll('.lib-size-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const size = btn.dataset.size;
    LibraryManager.setGridSize(size);
    document.querySelectorAll('.lib-size-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

// Pagination buttons
document.getElementById('libPrevPage').addEventListener('click', () => {
  LibraryManager.goToPage(LibraryManager.currentPage - 1);
});
document.getElementById('libNextPage').addEventListener('click', () => {
  LibraryManager.goToPage(LibraryManager.currentPage + 1);
});

// Filter chips
document.getElementById('libFilterBar').addEventListener('click', (e) => {
  const chip = e.target.closest('.lib-filter-chip');
  if (!chip) return;
  const filter = chip.dataset.filter;
  let newTag = null;
  let newType = null;

  if (filter === 'all') {
    // Clear all filters
  } else if (filter === 'type:image') {
    newType = LibraryManager.filterType === 'image' ? null : 'image';
  } else if (filter === 'type:video') {
    newType = LibraryManager.filterType === 'video' ? null : 'video';
  } else if (filter.startsWith('tag:')) {
    const tag = filter.slice(4);
    newTag = LibraryManager.filterTag === tag ? null : tag;
  }

  LibraryManager.applyFilter(newTag, newType);
});

// Grid click: selection vs lightbox
document.getElementById('libGrid').addEventListener('click', (e) => {
  const item = e.target.closest('.lib-item');
  if (!item) return;

  const pid = item.dataset.pid;
  const idx = parseInt(item.dataset.idx, 10);

  // Check if clicked on selection checkbox
  const selectCheck = e.target.closest('.lib-select-check');
  if (selectCheck) {
    LibraryManager.toggleSelect(pid);
    return;
  }

  // Click on thumbnail opens lightbox
  const thumbWrap = e.target.closest('.lib-thumb-wrap');
  const thumb = e.target.closest('.lib-thumb');
  if ((thumbWrap || thumb) && !isNaN(idx)) {
    LibraryManager.openLightbox(idx);
    return;
  }

  // Default: toggle selection
  LibraryManager.toggleSelect(pid);
});

// Select all / none
document.getElementById('libSelectAll').addEventListener('click', () => {
  LibraryManager.selectAll();
});
document.getElementById('libSelectNone').addEventListener('click', () => {
  LibraryManager.selectNone();
});

// Apply tag
document.getElementById('libApplyTag').addEventListener('click', async () => {
  const input = document.getElementById('libTagInput');
  const tag = input.value.trim().toLowerCase().replace(/[^a-z0-9\-]/g, '');
  if (!tag || tag.length < 2) return;
  if (LibraryManager.selectedIds.size === 0) return;
  await LibraryManager.applyTagToSelected(tag);
  input.value = '';
});
document.getElementById('libTagInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') document.getElementById('libApplyTag').click();
});

// Quick-select: Intensity
document.querySelectorAll('[data-intensity]').forEach(btn => {
  btn.addEventListener('click', async () => {
    if (LibraryManager.selectedIds.size === 0) return;
    await LibraryManager.setIntensity(btn.dataset.intensity);
  });
});

// Quick-select: Mood
document.querySelectorAll('[data-mood]').forEach(btn => {
  btn.addEventListener('click', async () => {
    if (LibraryManager.selectedIds.size === 0) return;
    await LibraryManager.setMood(btn.dataset.mood);
  });
});

// Quick-select: Energy
document.querySelectorAll('[data-energy]').forEach(btn => {
  btn.addEventListener('click', async () => {
    if (LibraryManager.selectedIds.size === 0) return;
    await LibraryManager.setEnergy(btn.dataset.energy);
  });
});

// ═══ LIGHTBOX EVENT HANDLERS ═══
document.getElementById('lightboxClose').addEventListener('click', () => {
  LibraryManager.closeLightbox();
});
document.getElementById('lightboxBackdrop').addEventListener('click', () => {
  LibraryManager.closeLightbox();
});
document.getElementById('lightboxPrev').addEventListener('click', () => {
  LibraryManager.lightboxPrev();
});
document.getElementById('lightboxNext').addEventListener('click', () => {
  LibraryManager.lightboxNext();
});

// Lightbox keyboard navigation
document.addEventListener('keydown', (e) => {
  if (!LibraryManager.lightboxOpen) return;
  if (e.key === 'Escape') LibraryManager.closeLightbox();
  if (e.key === 'ArrowLeft') LibraryManager.lightboxPrev();
  if (e.key === 'ArrowRight') LibraryManager.lightboxNext();
});

// Lightbox tag interactions (delegated)
document.getElementById('lightboxTags').addEventListener('click', async (e) => {
  // Remove tag
  const removeBtn = e.target.closest('.lb-tag-remove');
  if (removeBtn) {
    await LibraryManager.removeTagFromCurrentLightbox(removeBtn.dataset.tag);
    return;
  }

  // Set intensity
  const intBtn = e.target.closest('[data-set-intensity]');
  if (intBtn) {
    await LibraryManager.setIntensityForCurrentLightbox(intBtn.dataset.setIntensity);
    return;
  }

  // Set mood
  const moodBtn = e.target.closest('[data-set-mood]');
  if (moodBtn) {
    await LibraryManager.setMoodForCurrentLightbox(moodBtn.dataset.setMood);
    return;
  }

  // Toggle folder picker
  const addFolderBtn = e.target.closest('#lbAddFolderBtn');
  if (addFolderBtn) {
    LibraryManager.toggleLightboxFolderPicker();
    return;
  }

  // Add folder to lightbox
  const folderPickerItem = e.target.closest('[data-add-lb-folder]');
  if (folderPickerItem && !folderPickerItem.classList.contains('added')) {
    LibraryManager.addFolderToLightbox(folderPickerItem.dataset.addLbFolder);
    return;
  }

  // Remove folder from lightbox
  const removeFolderBtn = e.target.closest('[data-remove-lb-folder]');
  if (removeFolderBtn) {
    LibraryManager.removeFolderFromLightbox(removeFolderBtn.dataset.removeLbFolder);
    return;
  }

  // Apply folder tag to current image
  const folderTagBtn = e.target.closest('[data-apply-folder-tag]');
  if (folderTagBtn) {
    await LibraryManager.applyFolderTagToCurrentLightbox(folderTagBtn.dataset.applyFolderTag);
    return;
  }
});

// Lightbox add tag (delegated since elements are dynamic)
document.getElementById('lightboxTags').addEventListener('click', async (e) => {
  if (e.target.id === 'lbAddTag' || e.target.closest('#lbAddTag')) {
    const input = document.getElementById('lbTagInput');
    if (!input) return;
    const tag = input.value.trim().toLowerCase().replace(/[^a-z0-9\-]/g, '');
    if (tag && tag.length >= 2) {
      await LibraryManager.addTagToCurrentLightbox(tag);
      // Refocus the new input element after re-render
      const newInput = document.getElementById('lbTagInput');
      if (newInput) {
        newInput.value = '';
        newInput.focus();
      }
    }
  }
});
document.getElementById('lightboxTags').addEventListener('keydown', async (e) => {
  if (e.target.id === 'lbTagInput' && e.key === 'Enter') {
    e.preventDefault(); // Prevent any default behavior
    const tag = e.target.value.trim().toLowerCase().replace(/[^a-z0-9\-]/g, '');
    if (tag && tag.length >= 2) {
      await LibraryManager.addTagToCurrentLightbox(tag);
      // Refocus the new input element after re-render
      const newInput = document.getElementById('lbTagInput');
      if (newInput) {
        newInput.value = '';
        newInput.focus();
      }
    }
  }
});

// Export metadata
document.getElementById('libExport').addEventListener('click', async () => {
  const btn = document.getElementById('libExport');
  try {
    const json = await ContentMetaDB.exportJSON();
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `void-metadata-${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
    btn.textContent = '✓ exported';
    setTimeout(() => { btn.textContent = '📤 export'; }, 2000);
  } catch(e) {
    btn.textContent = '✗ error';
    setTimeout(() => { btn.textContent = '📤 export'; }, 2000);
  }
});

// Import metadata
document.getElementById('libImport').addEventListener('click', () => {
  document.getElementById('libImportInput').click();
});
document.getElementById('libImportInput').addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  const btn = document.getElementById('libImport');
  try {
    const text = await file.text();
    const count = await ContentMetaDB.importJSON(text);
    btn.textContent = `✓ ${count} imported`;
    // Reload metadata
    await LibraryManager.loadMetadata();
    LibraryManager.render();
    setTimeout(() => { btn.textContent = '📥 import metadata'; }, 2000);
  } catch(err) {
    btn.textContent = '✗ invalid file';
    setTimeout(() => { btn.textContent = '📥 import metadata'; }, 2000);
  }
  e.target.value = '';
});

// Clear metadata from settings
document.getElementById('clearMetadata').addEventListener('click', async () => {
  const btn = document.getElementById('clearMetadata');
  if (btn.dataset.confirm !== 'yes') {
    btn.textContent = 'are you sure?';
    btn.dataset.confirm = 'yes';
    btn.style.color = 'rgba(255,80,80,0.9)';
    btn.style.borderColor = 'rgba(255,80,80,0.5)';
    setTimeout(() => { btn.textContent = 'clear'; btn.dataset.confirm = ''; btn.style.color = ''; btn.style.borderColor = ''; }, 3000);
    return;
  }
  await ContentMetaDB.clearAll();
  btn.textContent = 'cleared';
  btn.dataset.confirm = '';
  btn.style.color = 'rgba(100,255,100,0.6)';
  document.getElementById('metaCountInfo').textContent = 'no metadata';
  setTimeout(() => { btn.textContent = 'clear'; btn.style.color = ''; btn.style.borderColor = ''; }, 2000);
});

document.getElementById('togglePoppers').addEventListener('change', (e) => {
  userSettings.poppersEnabled = e.target.checked;
  updatePoppersHud();
  saveSettings();
});
document.getElementById('toggleCaptions').addEventListener('change', (e) => {
  userSettings.captionsEnabled = e.target.checked;
  saveSettings();
});
document.getElementById('toggleVideoAudio').addEventListener('change', (e) => {
  userSettings.videoAudioEnabled = e.target.checked;
  saveSettings();
});
document.getElementById('togglePermission').addEventListener('change', (e) => {
  userSettings.permissionEnabled = e.target.checked;
  saveSettings();
});
document.getElementById('toggleAdaptive').addEventListener('change', (e) => {
  userSettings.adaptiveContent = e.target.checked;
  AdaptiveEngine.enabled = e.target.checked;
  saveSettings();
});

document.getElementById('poppersFreqDown').addEventListener('click', () => {
  userSettings.poppersFreq = Math.max(0, userSettings.poppersFreq - 1);
  updateFreqLabel(); saveSettings();
});
document.getElementById('poppersFreqUp').addEventListener('click', () => {
  userSettings.poppersFreq = Math.min(4, userSettings.poppersFreq + 1);
  updateFreqLabel(); saveSettings();
});

// In-game poppers HUD
let poppersPaused = false;
function updatePoppersHud() {
  const btn = document.getElementById('poppersHudPause');
  if (!userSettings.poppersEnabled) {
    btn.textContent = 'poppers: off';
    btn.classList.add('paused');
    poppersPaused = true;
  } else if (poppersPaused) {
    btn.textContent = 'poppers: paused';
    btn.classList.add('paused');
  } else {
    btn.textContent = 'poppers: on';
    btn.classList.remove('paused');
  }
}

document.getElementById('poppersHudPause').addEventListener('click', () => {
  if (!userSettings.poppersEnabled) return; // Can't unpause if feature is off
  poppersPaused = !poppersPaused;
  updatePoppersHud();
});
document.getElementById('poppersHudDown').addEventListener('click', () => {
  userSettings.poppersFreq = Math.max(0, userSettings.poppersFreq - 1);
  updateFreqLabel(); saveSettings();
});
document.getElementById('poppersHudUp').addEventListener('click', () => {
  userSettings.poppersFreq = Math.min(4, userSettings.poppersFreq + 1);
  updateFreqLabel(); saveSettings();
});

// ═══════════════════════════════════════════════════════════════
// UPLOAD UI — File, Folder, Drag & Drop
// ═══════════════════════════════════════════════════════════════
const uploadPanel = document.getElementById('uploadPanel');
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const folderInput = document.getElementById('folderInput');
const uploadStats = document.getElementById('uploadStats');
const uploadLoading = document.getElementById('uploadLoading');
const contentCounter = document.getElementById('contentCounter');
const contentStatus = document.getElementById('contentStatus');
const enterBtn = document.getElementById('enterBtn');

function updateUploadUI() {
  const c = ContentRegistry;
  if (c.count > 0) {
    uploadStats.innerHTML =
      `<span class="stat-val">${c.imageCount}</span> images · ` +
      `<span class="stat-val">${c.videoCount}</span> videos · ` +
      `<span class="stat-val">${c.totalSizeMB()}</span> MB total`;
    // Legacy counter
    if (contentCounter) {
      contentCounter.textContent = `${c.count} files loaded`;
      contentCounter.className = 'content-counter has-content';
    }
    // New status
    if (contentStatus) {
      contentStatus.textContent = `${c.count} files loaded · ready`;
      contentStatus.className = 'content-status ready';
    }
    enterBtn.disabled = false;
    S.contentLoaded = true;
  } else {
    uploadStats.innerHTML = '';
    // Legacy counter
    if (contentCounter) {
      contentCounter.textContent = 'load content to begin';
      contentCounter.className = 'content-counter';
    }
    // New status
    if (contentStatus) {
      contentStatus.textContent = 'no content loaded';
      contentStatus.className = 'content-status empty';
    }
    enterBtn.disabled = true;
    S.contentLoaded = false;
  }
}

const uploadProgressLabel = document.getElementById('uploadProgressLabel');
const uploadProgressFill = document.getElementById('uploadProgressFill');

function processFiles(files) {
  uploadLoading.classList.add('active');
  uploadProgressFill.style.width = '0%';
  uploadProgressLabel.textContent = `processing 0 / ${files.length} files...`;
  console.log(`Processing ${files.length} files...`);

  // Process in batches to keep UI responsive and update progress
  const BATCH_SIZE = 20;
  let index = 0;
  let addedTotal = 0;

  function processBatch() {
    const end = Math.min(index + BATCH_SIZE, files.length);
    for (let i = index; i < end; i++) {
      if (ContentRegistry.add(files[i])) addedTotal++;
    }
    index = end;

    // Update progress
    const pct = Math.round((index / files.length) * 100);
    uploadProgressFill.style.width = pct + '%';
    uploadProgressLabel.textContent = `processing ${index} / ${files.length} files...`;

    if (index < files.length) {
      // Yield to browser for UI update, then continue
      requestAnimationFrame(processBatch);
    } else {
      // Done
      console.log(`Added ${addedTotal} of ${files.length} files. Total: ${ContentRegistry.count}`);
      uploadProgressLabel.textContent = `${addedTotal} files added`;
      uploadProgressFill.style.width = '100%';
      // Save to IndexedDB in background (non-blocking)
      LibraryDB.saveFiles(files).then(n => {
        if (n > 0) console.log(`Library saved to device (${n} files)`);
      });
      // Persist folder tags to content metadata
      LibraryManager.persistFolderTags().then(n => {
        if (n > 0) console.log(`Folder tags saved for ${n} items`);
      });
      setTimeout(() => {
        uploadLoading.classList.remove('active');
        updateUploadUI();
      }, 600);
    }
  }

  // Start after a tick so the UI can show the loading bar
  requestAnimationFrame(processBatch);
}

// File input
document.getElementById('btnAddFiles').addEventListener('click', () => {
  console.log('Opening file picker...');
  fileInput.click();
});
fileInput.addEventListener('change', () => {
  console.log(`File input changed. Files: ${fileInput.files.length}`);
  if (fileInput.files.length) processFiles(Array.from(fileInput.files));
  fileInput.value = '';
});

// Folder input
document.getElementById('btnAddFolder').addEventListener('click', () => folderInput.click());
folderInput.addEventListener('change', () => {
  if (folderInput.files.length) processFiles(Array.from(folderInput.files));
  folderInput.value = '';
});

// Clear
document.getElementById('btnClear').addEventListener('click', () => {
  ContentRegistry.clear();
  URLManager.revokeAll();
  ThumbnailCache.clear();
  LibraryDB.clearAll(); // Also clear saved library
  updateUploadUI();
});

// Drop zone also opens file picker on click/tap
dropZone.addEventListener('click', () => {
  console.log('Drop zone tapped, opening file picker...');
  fileInput.click();
});

// Drag & Drop (desktop only, but harmless on mobile)
dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropZone.classList.add('drag-over');
});
dropZone.addEventListener('dragleave', () => {
  dropZone.classList.remove('drag-over');
});
dropZone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dropZone.classList.remove('drag-over');
  uploadLoading.classList.add('active');
  uploadProgressLabel.textContent = 'scanning folders...';
  uploadProgressFill.style.width = '0%';

  const files = [];

  // Handle both files and directories from DataTransfer
  if (e.dataTransfer.items) {
    const entries = [];
    for (const item of e.dataTransfer.items) {
      const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
      if (entry) entries.push(entry);
    }

    // Recursively read directories
    async function readEntry(entry) {
      if (entry.isFile) {
        return new Promise(resolve => {
          entry.file(f => { files.push(f); resolve(); });
        });
      } else if (entry.isDirectory) {
        const reader = entry.createReader();
        const readBatch = () => new Promise(resolve => {
          reader.readEntries(async (entries) => {
            if (entries.length === 0) { resolve(); return; }
            for (const e of entries) await readEntry(e);
            await readBatch(); // keep reading (batched at 100)
            resolve();
          });
        });
        await readBatch();
      }
    }

    for (const entry of entries) await readEntry(entry);
  } else {
    for (const f of e.dataTransfer.files) files.push(f);
  }

  processFiles(files);
});

// Open/close upload panel
document.getElementById('uploadBtn').addEventListener('click', () => {
  uploadPanel.classList.add('visible');
});
document.getElementById('btnCloseUpload').addEventListener('click', () => {
  uploadPanel.classList.remove('visible');
});

// New navigation buttons
document.getElementById('navContent')?.addEventListener('click', () => {
  uploadPanel.classList.add('visible');
});
document.getElementById('navSettings')?.addEventListener('click', async () => {
  buildThemeGrid();
  document.getElementById('settingsPanel').classList.add('visible');
});
document.getElementById('navHistory')?.addEventListener('click', async () => {
  showSessionHistory();
});
document.getElementById('playerCard')?.addEventListener('click', async () => {
  showSessionHistory();
});

// Session dot selector
const sessionDots = document.querySelectorAll('.session-dot');
const sessionDuration = document.getElementById('sessionDuration');
const SESSION_LABELS = { quick: '10 min', standard: '20 min', extended: '45 min', marathon: '90+ min' };

sessionDots.forEach(dot => {
  dot.addEventListener('click', () => {
    const preset = dot.dataset.preset;
    sessionDots.forEach(d => d.classList.remove('active'));
    dot.classList.add('active');
    if (sessionDuration) sessionDuration.textContent = SESSION_LABELS[preset] || '20 min';
    applySessionPreset(preset);
    saveSettings();
    // Also update legacy preset buttons
    document.querySelectorAll('.preset-btn').forEach(b => {
      b.classList.toggle('active', b.dataset.preset === preset);
    });
  });
});

// Clicking duration text cycles through presets
sessionDuration?.addEventListener('click', () => {
  const presets = ['quick', 'standard', 'extended', 'marathon'];
  const currentDot = document.querySelector('.session-dot.active');
  const currentIdx = currentDot ? presets.indexOf(currentDot.dataset.preset) : 1;
  const nextIdx = (currentIdx + 1) % presets.length;
  const nextDot = document.querySelector(`.session-dot[data-preset="${presets[nextIdx]}"]`);
  if (nextDot) nextDot.click();
});

// Init UI state
updateUploadUI();

// Restore saved settings and library
loadSettings();
(async () => {
  try {
    const count = await LibraryDB.getCount();
    if (count > 0) {
      if (contentCounter) {
        contentCounter.textContent = `restoring ${count} saved files...`;
        contentCounter.className = 'content-counter has-content';
      }
      if (contentStatus) {
        contentStatus.textContent = `restoring ${count} files...`;
        contentStatus.className = 'content-status';
      }
      const files = await LibraryDB.loadAll();
      if (files.length > 0) {
        let added = 0;
        for (const f of files) { if (ContentRegistry.add(f)) added++; }
        console.log(`Restored ${added} files from device storage`);
      }
      updateUploadUI();
    }
  } catch(e) { console.warn('Library restore failed:', e); }
  // Update entry screen with session stats
  updateEntryProfile();
})();

// --- Entry Screen Profile ---
async function updateEntryProfile() {
  // Legacy elements (hidden but kept for compatibility)
  const el = document.getElementById('entryProfile');
  const levelBlock = document.getElementById('entryLevelBlock');
  const greetingEl = document.getElementById('entryGreeting');
  const streakEl = document.getElementById('entryStreak');

  // New player card elements
  const playerCard = document.getElementById('playerCard');
  const playerRank = document.getElementById('playerRank');
  const playerLevel = document.getElementById('playerLevel');
  const playerXpFill = document.getElementById('playerXpFill');
  const playerCorruption = document.getElementById('playerCorruption');
  const playerStats = document.getElementById('playerStats');

  try {
    const profile = await ProfileDB.loadOrCreate();
    const count = await SessionDB.getCount();

    if (count === 0 || profile.totalSessions === 0) {
      // First time user
      playerRank.textContent = 'NEWCOMER';
      playerRank.style.color = 'rgba(255,255,255,0.5)';
      playerLevel.textContent = 'level 1 · 0 xp';
      playerXpFill.style.width = '0%';
      playerCorruption.textContent = '';
      playerStats.innerHTML = 'first time? <span>welcome to the void</span>';
      
      // Legacy
      if (el) el.textContent = 'first time? welcome.';
      if (levelBlock) levelBlock.style.display = 'none';
      if (greetingEl) greetingEl.textContent = 'it already knows what you want';
      if (streakEl) streakEl.textContent = '';
      return;
    }

    // Get level info
    const info = Progression.getLevelInfo(profile.level.xp);
    
    // Update player card
    playerRank.textContent = info.title;
    playerRank.style.color = info.color;
    playerRank.style.textShadow = `0 0 20px ${info.color}40`;
    playerLevel.textContent = `level ${info.level} · ${profile.level.xp} xp`;
    playerXpFill.style.width = `${Math.max(info.progress * 100, 2)}%`;
    
    // Corruption
    if (profile.corruption.index > 0.05) {
      const corr = profile.corruption.index;
      playerCorruption.textContent = `corruption: ${Math.floor(corr * 100)}%`;
      playerCorruption.style.color = `rgba(255,45,123,${0.25 + corr * 0.35})`;
    } else {
      playerCorruption.textContent = '';
    }
    
    // Stats
    const last = await SessionDB.getLast();
    const stats = await SessionDB.getStats();
    const ago = last ? formatTimeAgo(last.timestamp) : '';
    playerStats.innerHTML = `<span>${count}</span> sessions · <span>${stats.totalMinutes}</span> min · last: ${ago}`;
    
    // Streak badge
    if (profile.stats.currentStreak > 1) {
      playerStats.innerHTML += ` · <span style="color:rgba(255,170,0,0.6)">🔥${profile.stats.currentStreak}</span>`;
    }

    // Legacy support
    if (levelBlock) {
      levelBlock.style.display = '';
      document.getElementById('entryLevelTitle').textContent = info.title;
      document.getElementById('entryLevelTitle').style.color = info.color;
      document.getElementById('entryLevelSub').textContent = `level ${info.level} · ${profile.level.xp} xp`;
      document.getElementById('entryXpFill').style.width = `${Math.max(info.progress * 100, 2)}%`;
    }
    if (greetingEl) greetingEl.textContent = Progression.getGreeting(profile);
    if (el) el.innerHTML = `<span class="ep-val">${count}</span> sessions · <span class="ep-val">${stats.totalMinutes}</span> min total`;
    
  } catch(e) {
    console.warn('Profile load failed:', e);
    playerRank.textContent = 'CURIOUS';
    playerLevel.textContent = 'level 1 · 0 xp';
    playerStats.innerHTML = '<span>ready to begin</span>';
  }
}

function formatTimeAgo(ts) {
  const diff = Date.now() - ts;
  const mins = Math.floor(diff / 60000);
  if (mins < 1) return 'just now';
  if (mins < 60) return `${mins}m ago`;
  const hours = Math.floor(mins / 60);
  if (hours < 24) return `${hours}h ago`;
  const days = Math.floor(hours / 24);
  if (days === 1) return 'yesterday';
  if (days < 7) return `${days}d ago`;
  return new Date(ts).toLocaleDateString();
}

// --- Session History Panel ---
document.getElementById('entryProfile').addEventListener('click', () => {
  showSessionHistory();
});
document.getElementById('historyClose').addEventListener('click', () => {
  document.getElementById('historyPanel').classList.remove('visible');
});

async function showSessionHistory() {
  const panel = document.getElementById('historyPanel');
  const list = document.getElementById('historyList');
  list.innerHTML = '';

  panel.classList.add('visible');

  const sessions = await SessionDB.getRecent(20);
  if (sessions.length === 0) {
    list.innerHTML = '<div class="history-empty">no sessions recorded yet. complete a session to start tracking.</div>';
    return;
  }

  // Summary stats at top
  const stats = await SessionDB.getStats();
  if (stats) {
    const summaryEl = document.createElement('div');
    summaryEl.style.cssText = 'width:min(400px,90%);margin-bottom:18px;padding:12px 16px;border:1px solid rgba(255,170,0,0.15);border-radius:6px;background:rgba(255,170,0,0.03);text-align:center;';
    summaryEl.innerHTML = `
      <div style="font-family:'Bebas Neue',sans-serif;font-size:1.1rem;letter-spacing:0.15em;color:#ffd700;margin-bottom:6px;">LIFETIME STATS</div>
      <div style="font-family:'Space Mono',monospace;font-size:9px;letter-spacing:0.1em;color:rgba(255,255,255,0.25);line-height:2.2;">
        ${stats.totalSessions} sessions · ${stats.totalMinutes} minutes total · ${stats.totalDenials} denials · ${stats.totalEdgeCycles} edges<br>
        deepest trance: ${Math.floor(stats.deepestTrance * 100)}% · longest: ${Math.floor(stats.longestSession / 60)}m · avg: ${stats.avgSessionMinutes}m
      </div>
    `;
    list.appendChild(summaryEl);
  }

  // Session cards
  sessions.forEach((s, i) => {
    const date = new Date(s.timestamp);
    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    const dur = s.duration || 0;
    const m = Math.floor(dur / 60);
    const sec = Math.floor(dur % 60);
    const peak = Math.floor((s.trance?.peak || 0) * 100);
    const denials = s.mechanics?.denials || 0;
    const edges = s.mechanics?.edgeCycles || 0;
    const rank = s.rank || 'CURIOUS';
    const poppersHits = s.mechanics?.poppersHits || 0;
    const content = s.content?.uniqueDisplayed || 0;

    const rankColor = getSessionRank(dur/60, denials, edges).color;

    const card = document.createElement('div');
    card.className = 'history-card';
    card.innerHTML = `
      <div class="history-card-head">
        <div class="history-card-rank" style="color:${rankColor}">${rank}</div>
        <div class="history-card-date">${dateStr}</div>
      </div>
      <div class="history-card-stats">
        <div class="history-card-stat"><div class="sv">${m}:${sec.toString().padStart(2,'0')}</div><div class="sl">time</div><div class="stat-tip">Total session duration</div></div>
        <div class="history-card-stat"><div class="sv">${peak}%</div><div class="sl">trance</div><div class="stat-tip">Deepest trance depth reached (higher = deeper state)</div></div>
        <div class="history-card-stat"><div class="sv">${denials}</div><div class="sl">denials</div><div class="stat-tip">Times permission was denied — builds intensity</div></div>
        <div class="history-card-stat"><div class="sv">${edges}</div><div class="sl">edges</div><div class="stat-tip">Edge cycles (denial + escalation loops)</div></div>
        <div class="history-card-stat"><div class="sv">${poppersHits}</div><div class="sl">poppers</div><div class="stat-tip">Completed poppers breathing sequences</div></div>
        <div class="history-card-stat"><div class="sv">${content}</div><div class="sl">content</div><div class="stat-tip">Unique images/videos displayed this session</div></div>
      </div>
    `;
    list.appendChild(card);
  });
}


// ═══════════════════════════════════════════════════════════════
// CONTENT DISPLAY ENGINE — Thumbnail-optimized
// Floating panels use ~400px thumbnails (~20-50KB each)
// Full-res reserved for fulltake only (1 at a time)
// Videos show still-frame thumbnails in panels
// Generous budget: 7 panels, 600ms spawn cooldown, high-res thumbnails
// ═══════════════════════════════════════════════════════════════
const MAX_PANELS = 20;
const MIN_PANEL_INTERVAL = 200;
let lastPanelCreateTime = 0;
let panelCreating = false;
const flashOverlay = document.getElementById('flashOverlay');
const fulltakeOverlay = document.getElementById('fulltakeOverlay');

async function createContentPanel() {
  if (!S.contentLoaded || ContentRegistry.count === 0) {
    createPlaceholderPanel();
    return;
  }

  const now = Date.now();
  if (now - lastPanelCreateTime < MIN_PANEL_INTERVAL) return;
  if (panelCreating) return;
  panelCreating = true;
  lastPanelCreateTime = now;

  // Calculate session progress for adaptive selection (0-1)
  // Map phase index to progress: 0→0.1, 1→0.3, 2→0.6, 3→0.9
  const phaseProgressMap = [0.1, 0.35, 0.65, 0.9];
  const sessionProgress = phaseProgressMap[Math.min(S.phaseIndex, 3)] || 0.5;

  // Use adaptive selection if enabled, otherwise fall back to random
  let item;
  if (AdaptiveEngine.enabled && S.settings?.adaptiveContent !== false) {
    item = await ContentRegistry.pickAdaptive(sessionProgress, S.displayedIndices);
  } else {
    item = ContentRegistry.pickRandom(S.displayedIndices);
  }
  
  if (!item) { panelCreating = false; return; }
  SessionTracker.recordContentShow(item);

  S.displayedIndices.add(item.id);
  if (S.displayedIndices.size > Math.min(ContentRegistry.count * 0.5, 30)) {
    const first = S.displayedIndices.values().next().value;
    S.displayedIndices.delete(first);
  }

  const thumbUrl = await ThumbnailCache.getUrl(item);
  panelCreating = false;
  if (!thumbUrl) return;
  if (S.activePanels.length >= MAX_PANELS) return;

  const panel = document.createElement('div');
  panel.className = 'content-panel';
  panel._contentId = item.id;
  panel._persistId = item.persistId; // For adaptive engagement tracking

  // Base size for the longest edge — scales up with phase
  const baseSize = 160 + S.phaseIndex * 40;
  const size = baseSize + Math.random() * (100 + S.phaseIndex * 50);

  // Temporary — will be corrected to real aspect ratio on load
  panel.style.width = size + 'px';
  panel.style.height = size + 'px';
  panel.style.left = (Math.random() * Math.max(0, window.innerWidth - size)) + 'px';
  panel.style.top = (Math.random() * Math.max(0, window.innerHeight - size)) + 'px';
  panel.style.opacity = '0';

  const idLabel = document.createElement('div');
  idLabel.className = 'panel-id';
  idLabel.textContent = 'NL_' + item.id.toString().padStart(4, '0');
  panel.appendChild(idLabel);

  const img = document.createElement('img');
  // object-fit: contain — shows full image, no cropping
  img.style.cssText = 'opacity:0;transition:opacity 0.5s ease;width:100%;height:100%;object-fit:contain;position:absolute;top:0;left:0;';

  img.onload = () => {
    // Resize panel to match image aspect ratio (no black bars)
    const natW = img.naturalWidth || 1;
    const natH = img.naturalHeight || 1;
    const aspect = natW / natH;
    let panelW, panelH;
    if (aspect >= 1) {
      panelW = size;
      panelH = size / aspect;
    } else {
      panelH = size;
      panelW = size * aspect;
    }
    panel.style.width = panelW + 'px';
    panel.style.height = panelH + 'px';
    panel.style.left = (Math.random() * Math.max(0, window.innerWidth - panelW)) + 'px';
    panel.style.top = (Math.random() * Math.max(0, window.innerHeight - panelH)) + 'px';
    // Update drift coordinates to match new position
    if (panel._drift) {
      panel._drift.x = parseFloat(panel.style.left);
      panel._drift.y = parseFloat(panel.style.top);
    }
    img.style.opacity = '1';
  };

  img.src = thumbUrl;
  panel.appendChild(img);

  // Add compilation-style text captions over some panels
  addCaptionOverlay(panel);

  document.body.appendChild(panel);

  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      panel.style.opacity = '1';
    });
  });

  panel._drift = {
    speed: 0.15 + Math.random() * 0.4,
    angle: Math.random() * Math.PI * 2,
    x: parseFloat(panel.style.left),
    y: parseFloat(panel.style.top),
  };
  S.activePanels.push(panel);

  const lifespan = (6000 + Math.random() * 8000) / (1 + S.phaseIndex * 0.15);
  setTimeout(() => removePanel(panel), lifespan);
}

function createPlaceholderPanel() {
  const panel = document.createElement('div');
  panel.className = 'content-panel';
  const size = 80 + Math.random() * 150;
  const ratio = 0.6 + Math.random() * 0.8;
  panel.style.width = size + 'px';
  panel.style.height = (size * ratio) + 'px';
  panel.style.left = (Math.random() * (window.innerWidth - size)) + 'px';
  panel.style.top = (Math.random() * (window.innerHeight - size * ratio)) + 'px';
  panel.style.opacity = '0';

  const id = document.createElement('div');
  id.className = 'panel-id';
  id.textContent = 'CONTENT_' + (Math.random()*999|0).toString().padStart(3,'0');
  panel.appendChild(id);

  const txt = document.createElement('span');
  txt.className = 'placeholder-text';
  txt.textContent = '[AWAITING UPLOAD]';
  panel.appendChild(txt);

  document.body.appendChild(panel);
  setTimeout(() => { panel.style.opacity = (0.15 + Math.random()*0.2).toString(); }, 100);

  panel._drift = {
    speed: 0.2+Math.random()*0.5,
    angle: Math.random()*Math.PI*2,
    x: parseFloat(panel.style.left),
    y: parseFloat(panel.style.top)
  };
  S.activePanels.push(panel);
  setTimeout(() => removePanel(panel), 5000 + Math.random()*10000);
}

function removePanel(panel) {
  panel.style.opacity = '0';
  
  // Track engagement when panel is naturally removed (not skipped)
  if (panel._persistId && AdaptiveEngine.enabled) {
    // Panel lived its full lifespan - good engagement signal
    AdaptiveEngine.notifyContentChange(false);
  }
  
  setTimeout(() => {
    // Revoke only non-cached URLs (videos loaded directly)
    if (panel._mediaUrl) URLManager.revoke(panel._mediaUrl);
    panel.remove();
    const idx = S.activePanels.indexOf(panel);
    if (idx > -1) S.activePanels.splice(idx, 1);
  }, 600);
}

function updatePanels() {
  for (const p of S.activePanels) {
    if (!p._drift) continue;
    p._drift.x += Math.cos(p._drift.angle) * p._drift.speed * 0.1;
    p._drift.y += Math.sin(p._drift.angle) * p._drift.speed * 0.1;
    p.style.left = p._drift.x + 'px';
    p.style.top = p._drift.y + 'px';
  }
}

// ── FLASH MODE: Brief burst, uses thumbnail ──
async function triggerFlash() {
  if (!S.contentLoaded || ContentRegistry.count === 0) return;
  
  // Calculate session progress for adaptive selection
  const phaseProgressMap = [0.1, 0.35, 0.65, 0.9];
  const sessionProgress = phaseProgressMap[Math.min(S.phaseIndex, 3)] || 0.5;
  
  let item;
  if (AdaptiveEngine.enabled && S.settings?.adaptiveContent !== false) {
    item = await ContentRegistry.pickAdaptiveImage(sessionProgress, S.displayedIndices);
  } else {
    item = ContentRegistry.pickRandomImage(S.displayedIndices);
  }
  if (!item) return;
  SessionTracker.recordContentShow(item);

  const thumbUrl = await ThumbnailCache.getUrl(item);
  if (!thumbUrl) return;

  flashOverlay.innerHTML = '';
  const img = document.createElement('img');
  img.style.cssText = 'max-width:90vw;max-height:90vh;object-fit:contain;';
  img.src = thumbUrl;
  flashOverlay.appendChild(img);
  flashOverlay.classList.add('active');

  const duration = 300 + (1 - S.intensity) * 1200;
  setTimeout(() => {
    flashOverlay.classList.remove('active');
    setTimeout(() => { flashOverlay.innerHTML = ''; }, 200);
  }, duration);
}

// ── FULL-TAKE MODE: Full-res, full-screen. The reward moment. ──
// This is the ONLY place full-res content loads (1 at a time)
let fulltakeActive = false;
async function triggerFulltake() {
  if (!S.contentLoaded || ContentRegistry.count === 0) return;
  if (fulltakeActive) return; // only 1 at a time
  fulltakeActive = true;

  // Calculate session progress for adaptive selection
  const phaseProgressMap = [0.1, 0.35, 0.65, 0.9];
  const sessionProgress = phaseProgressMap[Math.min(S.phaseIndex, 3)] || 0.5;

  let item;
  if (AdaptiveEngine.enabled && S.settings?.adaptiveContent !== false) {
    item = await ContentRegistry.pickAdaptive(sessionProgress, S.displayedIndices);
  } else {
    item = ContentRegistry.pickRandom(S.displayedIndices);
  }
  if (!item) { fulltakeActive = false; return; }
  SessionTracker.recordContentShow(item);

  fulltakeOverlay.innerHTML = '';

  if (item.type === 'image') {
    // Full-res via FileReader (iOS compatible)
    const img = document.createElement('img');
    img.style.cssText = 'width:100%;height:100%;object-fit:contain;background:black;';
    img.onload = () => { fulltakeOverlay.classList.add('active'); };
    img.onerror = () => {
      ThumbnailCache.getUrl(item).then(tUrl => {
        if (tUrl) { img.src = tUrl; fulltakeOverlay.classList.add('active'); }
      });
    };
    fulltakeOverlay.appendChild(img);
    const reader = new FileReader();
    reader.onload = (e) => { img.src = e.target.result; };
    reader.readAsDataURL(item.file);
  } else {
    // Video: use the single video player for guaranteed playback
    // Detach from any panel first
    if (videoPlayer.parentNode) videoPlayer.parentNode.removeChild(videoPlayer);
    if (videoPlayerUrl) URL.revokeObjectURL(videoPlayerUrl);
    videoPlayerPanel = null;

    const url = createTypedBlobUrl(item.file, item.name);
    videoPlayerUrl = url;
    videoPlayer.muted = true;
    videoPlayer.style.cssText = 'width:100%;height:100%;object-fit:cover;position:absolute;top:0;left:0;pointer-events:none;';
    videoPlayer.loop = true;
    fulltakeOverlay.appendChild(videoPlayer);

    const onReady = () => {
      videoPlayer.removeEventListener('canplay', onReady);
      const dur = videoPlayer.duration || 0;
      if (dur > 5) videoPlayer.currentTime = Math.random() * (dur - 5);
      videoPlayer.play().then(() => {
        fulltakeOverlay.classList.add('active');
        setTimeout(() => {
          try {
            if (userSettings.videoAudioEnabled) { videoPlayer.muted = false; videoPlayer.volume = 0.45; }
          } catch(e) {}
        }, 200);
      }).catch(() => {
        videoPlayer.muted = true;
        videoPlayer.play().catch(() => {});
        fulltakeOverlay.classList.add('active');
      });
    };
    videoPlayer.addEventListener('canplay', onReady);
    videoPlayer.src = url;
  }

  const duration = 3000 + Math.random() * 5000;

  // Add big compilation-style caption
  setTimeout(() => addFulltakeCaption(), 500);

  setTimeout(() => {
    fulltakeOverlay.classList.remove('active');
    setTimeout(() => {
      // Detach video player from fulltake (don't destroy it)
      if (videoPlayer.parentNode === fulltakeOverlay) {
        videoPlayer.pause();
        fulltakeOverlay.removeChild(videoPlayer);
        // Release the URL
        if (videoPlayerUrl) { URL.revokeObjectURL(videoPlayerUrl); videoPlayerUrl = null; }
        videoPlayerPanel = null;
      }
      fulltakeOverlay.innerHTML = '';
      fulltakeActive = false;
    }, 700);
  }, duration);
}

// ═══════════════════════════════════════════════════════════════
// VIDEO SYSTEM — Single-player architecture
// iOS Safari has ONE hardware video decoder. Multiple <video>
// elements = all but the last one freeze. Solution: keep a
// single video element, move it between panels. Other video
// panels show thumbnail stills. This guarantees smooth playback.
// ═══════════════════════════════════════════════════════════════
const videoPlayer = document.createElement('video');
videoPlayer.style.cssText = 'width:100%;height:100%;object-fit:cover;position:absolute;top:0;left:0;pointer-events:none;';
videoPlayer.playsInline = true;
videoPlayer.setAttribute('playsinline', '');
videoPlayer.setAttribute('webkit-playsinline', '');
videoPlayer.loop = true;   // Loop so short clips repeat until panel fades
videoPlayer.muted = true;
videoPlayer.autoplay = true;
videoPlayer.preload = 'auto';

let videoPlayerPanel = null;    // The panel currently hosting the video player
let videoPlayerUrl = null;      // Current blob URL
let videoPlayerItem = null;     // Current content registry item
let videoScheduleTimer = null;  // Timer for next video panel

// Spawn a video panel — ONLY if the player is free. No queue, no waiting.
// Video is a surprise interruption, not a lineup.
async function createVideoPanel() {
  if (!S.contentLoaded || ContentRegistry.videoCount === 0) return;
  if (videoPlayerPanel) return; // Player is busy — skip silently, images keep flowing

  const videos = ContentRegistry.items.filter(it => it.type === 'video');
  if (videos.length === 0) return;
  
  // Use adaptive selection for videos too
  const phaseProgressMap = [0.1, 0.35, 0.65, 0.9];
  const sessionProgress = phaseProgressMap[Math.min(S.phaseIndex, 3)] || 0.5;
  
  let item;
  if (AdaptiveEngine.enabled && S.settings?.adaptiveContent !== false) {
    item = await AdaptiveEngine.selectContent(videos, sessionProgress);
  }
  if (!item) {
    item = videos[Math.random() * videos.length | 0];
  }
  item.timesShown++;

  const panel = document.createElement('div');
  panel.className = 'content-panel';
  panel._contentId = item.id;
  panel._persistId = item.persistId; // For adaptive engagement tracking
  panel._isVideo = true;

  // Start with a placeholder size — will be resized to video's actual aspect ratio in attachVideoPlayer
  const vw = window.innerWidth, vh = window.innerHeight;
  const sizeRatio = 0.5 + Math.random() * 0.25; // 50-75% of shortest dimension
  const baseW = Math.min(vw, vh) * sizeRatio + S.phaseIndex * 20;
  panel.style.width = baseW + 'px';
  panel.style.height = (baseW * 0.5625) + 'px'; // 16:9 placeholder
  panel.style.left = (Math.random() * Math.max(0, vw - baseW)) + 'px';
  panel.style.top = (Math.random() * Math.max(0, vh - baseW * 0.5625)) + 'px';
  panel.style.opacity = '0';
  panel.style.zIndex = '15'; // Above image panels
  panel.style.border = '1px solid rgba(0,240,255,0.3)';
  panel.style.boxShadow = '0 0 25px rgba(0,240,255,0.15), 0 0 60px rgba(0,0,0,0.5)';
  panel._targetWidth = baseW; // Store for aspect ratio resize

  const idLabel = document.createElement('div');
  idLabel.className = 'panel-id';
  idLabel.style.color = 'var(--neon-cyan)';
  idLabel.textContent = 'VID_' + item.id.toString().padStart(4, '0');
  panel.appendChild(idLabel);

  document.body.appendChild(panel);
  attachVideoPlayer(panel, item);

  panel._drift = {
    speed: 0.1 + Math.random() * 0.2,
    angle: Math.random() * Math.PI * 2,
    x: parseFloat(panel.style.left),
    y: parseFloat(panel.style.top),
  };
  S.activePanels.push(panel);

  // Video plays for 12-25 seconds — long enough to immerse
  const lifespan = 12000 + Math.random() * 13000;
  // Start fadeout 2 seconds before removal
  setTimeout(() => fadeOutVideoPanel(panel), lifespan - 2000);
  setTimeout(() => removeVideoPanel(panel), lifespan);
}

function resizePanelToVideo(panel) {
  // Read the video's natural dimensions and resize the panel to match
  const vw = videoPlayer.videoWidth;
  const vh = videoPlayer.videoHeight;
  if (!vw || !vh) return;

  const targetW = panel._targetWidth || 300;
  const videoAspect = vh / vw; // height/width ratio
  const newW = targetW;
  const newH = targetW * videoAspect;

  // Clamp to screen
  const screenW = window.innerWidth, screenH = window.innerHeight;
  const maxH = screenH * 0.85;
  let finalW = newW, finalH = newH;
  if (finalH > maxH) {
    finalH = maxH;
    finalW = maxH / videoAspect;
  }

  panel.style.width = finalW + 'px';
  panel.style.height = finalH + 'px';

  // Re-clamp position so panel stays on screen
  const curLeft = parseFloat(panel.style.left) || 0;
  const curTop = parseFloat(panel.style.top) || 0;
  panel.style.left = Math.min(curLeft, Math.max(0, screenW - finalW)) + 'px';
  panel.style.top = Math.min(curTop, Math.max(0, screenH - finalH)) + 'px';

  // Update drift coordinates
  if (panel._drift) {
    panel._drift.x = parseFloat(panel.style.left);
    panel._drift.y = parseFloat(panel.style.top);
  }
}

function attachVideoPlayer(panel, item) {
  // Clean up previous
  if (videoPlayerUrl) {
    URL.revokeObjectURL(videoPlayerUrl);
    videoPlayerUrl = null;
  }

  // Remove from previous panel if any
  if (videoPlayer.parentNode) {
    videoPlayer.parentNode.removeChild(videoPlayer);
  }

  videoPlayerPanel = panel;
  videoPlayerItem = item;

  // Create typed blob URL
  const url = createTypedBlobUrl(item.file, item.name);
  videoPlayerUrl = url;

  // Reset and load
  videoPlayer.muted = true;
  videoPlayer.src = url;

  // Wait for actual playability
  const onReady = () => {
    videoPlayer.removeEventListener('canplay', onReady);

    // Resize panel to match the video's REAL aspect ratio — no black bars
    resizePanelToVideo(panel);

    // Pick a random segment to play
    const dur = videoPlayer.duration || 0;
    const clipLen = 5 + Math.random() * 10; // play 5-15 second clip
    if (dur > clipLen + 1) {
      videoPlayer.currentTime = Math.random() * (dur - clipLen);
    }

    videoPlayer.play().then(() => {
      // Smooth fade in
      panel.style.transition = 'opacity 1.2s ease-in';
      panel.style.opacity = '1';
      // Gradually ramp audio up over 1 second (if enabled)
      setTimeout(() => {
        if (!userSettings.videoAudioEnabled) { videoPlayer.muted = true; return; }
        try {
          videoPlayer.muted = false;
          videoPlayer.volume = 0;
          const targetVol = Math.min(0.2 + S.intensity * 0.3, 0.55);
          const steps = 10;
          const interval = 1000 / steps;
          let step = 0;
          const rampUp = setInterval(() => {
            step++;
            videoPlayer.volume = Math.min(targetVol, targetVol * (step / steps));
            if (step >= steps) clearInterval(rampUp);
          }, interval);
        } catch(e) { videoPlayer.muted = true; }
      }, 200);
    }).catch(() => {
      // Muted autoplay as fallback
      videoPlayer.muted = true;
      videoPlayer.play().catch(() => {});
      panel.style.opacity = '1';
    });
  };

  videoPlayer.addEventListener('canplay', onReady);
  panel.appendChild(videoPlayer);

  // Safety timeout — if canplay never fires, show panel anyway
  setTimeout(() => {
    if (panel.style.opacity === '0') {
      videoPlayer.play().catch(() => {});
      panel.style.opacity = '1';
    }
  }, 4000);

  // When this clip's segment ends, advance to next random video
  const onTimeUpdate = () => {
    const dur = videoPlayer.duration || 0;
    const clipLen = 5 + Math.random() * 10;
    // If near end of file or past our clip length, we'll let lifespan handle it
  };
}

// Smooth fadeout — gradually reduce opacity + audio over 2 seconds
function fadeOutVideoPanel(panel) {
  if (panel !== videoPlayerPanel) return;
  
  // Animate opacity via CSS transition
  panel.style.transition = 'opacity 2s ease-out';
  panel.style.opacity = '0.0';
  
  // Gradually ramp audio volume to 0
  if (!videoPlayer.muted && videoPlayer.volume > 0) {
    const startVol = videoPlayer.volume;
    const steps = 20;
    const interval = 2000 / steps;
    let step = 0;
    const fadeAudio = setInterval(() => {
      step++;
      const progress = step / steps;
      videoPlayer.volume = Math.max(0, startVol * (1 - progress));
      if (step >= steps) {
        clearInterval(fadeAudio);
        videoPlayer.volume = 0;
      }
    }, interval);
  }
}

function removeVideoPanel(panel) {
  panel.style.opacity = '0';
  setTimeout(() => {
    // Detach the video player (don't destroy it)
    if (videoPlayer.parentNode === panel) {
      videoPlayer.pause();
      panel.removeChild(videoPlayer);
    }
    if (panel === videoPlayerPanel) {
      if (videoPlayerUrl) { URL.revokeObjectURL(videoPlayerUrl); videoPlayerUrl = null; }
      videoPlayerPanel = null;
      videoPlayerItem = null;
    }
    if (panel._mediaUrl) URL.revokeObjectURL(panel._mediaUrl);
    panel.remove();
    const idx = S.activePanels.indexOf(panel);
    if (idx > -1) S.activePanels.splice(idx, 1);
  }, 600);
}

// ═══════════════════════════════════════════════════════════════
// CAPTION OVERLAY SYSTEM
// Bold, aggressive, compilation-edit style text overlays.
// Thick outlines, neon glow, Impact font, maximum gooner energy.
// ═══════════════════════════════════════════════════════════════
const CAPTION_PHRASES = [
  // Short commands
  'GOON', 'STROKE', 'EDGE', 'PUMP', 'OBEY', 'SUBMIT', 'LEAK',
  'DEEPER', 'MORE', 'DROOL', 'STARE', 'BATE', 'THROB',
  // State words
  'GOONED', 'BRAINLESS', 'MINDLESS', 'ADDICTED', 'LOST', 'DUMB',
  'MELTING', 'DRIPPING', 'EDGING', 'SINKING', 'BROKEN', 'EMPTY',
  // Phrases
  'DON\'T STOP', 'GIVE IN', 'NO ESCAPE', 'GOOD BOY', 'KEEP GOING',
  'FEEL IT', 'LET GO', 'NEED IT', 'CAN\'T STOP', 'SO DEEP',
  'YOU NEED THIS', 'CAN\'T LOOK AWAY', 'JUST GOON',
  'PUMP AND OBEY', 'EDGE FOR ME', 'BRAIN OFF',
  'NO THOUGHTS', 'ONLY GOON', 'GOON HARDER',
  'LOSE YOURSELF', 'IT FEELS SO GOOD', 'NEVER STOP',
  'DEEPER AND DEEPER', 'YOU WERE MADE FOR THIS',
];

const CAPTION_STYLES = [
  // Style 1: Thick Impact with multi-layer outline (classic goon edit)
  (color, size) => `
    font-family:'Impact','Bebas Neue','Arial Black',sans-serif;
    font-size:${size}px;font-weight:900;
    color:${color};
    paint-order:stroke fill;
    -webkit-text-stroke:${Math.max(2, size/12)}px black;
    text-shadow:
      3px 3px 0 #000, -3px -3px 0 #000, 3px -3px 0 #000, -3px 3px 0 #000,
      0 0 ${size/3}px ${color}, 0 0 ${size}px ${color}40;
    letter-spacing:2px;
    text-transform:uppercase;
  `,
  // Style 2: Bold with colored outline + drop shadow (like "GOON VIRUS!")
  (color, size) => `
    font-family:'Impact','Bebas Neue','Arial Black',sans-serif;
    font-size:${size}px;font-weight:900;
    color:white;
    paint-order:stroke fill;
    -webkit-text-stroke:${Math.max(3, size/8)}px ${color};
    text-shadow:
      4px 4px 0 rgba(0,0,0,0.95), 6px 6px 0 rgba(0,0,0,0.4),
      0 0 20px ${color}80;
    letter-spacing:3px;
    text-transform:uppercase;
  `,
  // Style 3: Bold with subtle glow halo (readable, not blobby)
  (color, size) => `
    font-family:'Bebas Neue','Impact','Arial Black',sans-serif;
    font-size:${size}px;font-weight:900;
    color:${color};
    paint-order:stroke fill;
    -webkit-text-stroke:${Math.max(1, size/14)}px rgba(0,0,0,0.9);
    text-shadow:
      0 0 8px ${color}90, 0 0 20px ${color}40,
      3px 3px 0 #000;
    letter-spacing:4px;
    text-transform:uppercase;
  `,
  // Style 4: White fill with bright colored thick stroke
  (color, size) => `
    font-family:'Impact','Arial Black',sans-serif;
    font-size:${size}px;font-weight:900;
    color:${color};
    paint-order:stroke fill;
    -webkit-text-stroke:${Math.max(2, size/10)}px white;
    text-shadow:
      0 0 15px ${color}, 4px 4px 0 rgba(0,0,0,0.9);
    letter-spacing:2px;
    text-transform:uppercase;
  `,
  // Style 5: Gradient-look with multiple shadows (3D pop effect)
  (color, size) => `
    font-family:'Impact','Bebas Neue','Arial Black',sans-serif;
    font-size:${size}px;font-weight:900;
    color:${color};
    paint-order:stroke fill;
    -webkit-text-stroke:${Math.max(1, size/14)}px rgba(0,0,0,0.9);
    text-shadow:
      2px 2px 0 #000, 4px 4px 0 rgba(0,0,0,0.7),
      6px 6px 0 rgba(0,0,0,0.4), 8px 8px 8px rgba(0,0,0,0.3),
      0 0 25px ${color}60;
    letter-spacing:3px;
    text-transform:uppercase;
  `,
];

const CAPTION_COLORS = [
  '#ff2d7b', '#00f0ff', '#b44dff', '#ff1111', '#ffdd00',
  '#ff69b4', '#00ff66', '#ff6600', '#ffffff', '#ff1493',
  '#39ff14', '#ff00ff', '#00ffff', '#ffaa00',
];

function addCaptionOverlay(panel) {
  if (!userSettings.captionsEnabled) return;
  if (Math.random() > 0.45) return; // 45% chance

  const numCaptions = 1 + Math.floor(Math.random() * 2); // 1-2 text elements
  const pw = parseFloat(panel.style.width);
  const ph = parseFloat(panel.style.height);

  for (let i = 0; i < numCaptions; i++) {
    const caption = document.createElement('div');
    const phrase = getThemedCaption();
    const color = CAPTION_COLORS[Math.random() * CAPTION_COLORS.length | 0];
    const size = Math.max(16, Math.min(pw * 0.15, 40)) + Math.random() * 10;
    const styleFn = CAPTION_STYLES[Math.random() * CAPTION_STYLES.length | 0];
    const rotation = -10 + Math.random() * 20;

    // Position: keep text within panel bounds
    // Top: 10-70% (leave room at bottom), Left: 5-40% (leave room for text width)
    const top = 10 + Math.random() * 60;
    const left = 5 + Math.random() * 35;

    caption.style.cssText = `
      position:absolute;
      top:${top}%;left:${left}%;
      z-index:5;
      line-height:1.1;
      white-space:nowrap;
      transform:rotate(${rotation}deg);
      pointer-events:none;
      opacity:0;
      transition:opacity 0.2s ease;
      ${styleFn(color, size)}
    `;
    caption.textContent = phrase;
    panel.appendChild(caption);

    setTimeout(() => { caption.style.opacity = '1'; }, 150 + i * 250);
  }
}

// Add captions to fulltake overlay (big and centered)
function addFulltakeCaption() {
  if (!userSettings.captionsEnabled) return;
  const phrase = getThemedCaption();
  const color = CAPTION_COLORS[Math.random() * CAPTION_COLORS.length | 0];
  const size = 50 + Math.random() * 40; // 50-90px
  const styleFn = CAPTION_STYLES[Math.random() * CAPTION_STYLES.length | 0];

  const caption = document.createElement('div');
  caption.style.cssText = `
    position:absolute;
    top:${20+Math.random()*50}%;left:50%;
    transform:translate(-50%,-50%) rotate(${-6+Math.random()*12}deg);
    z-index:10;line-height:1.1;white-space:nowrap;
    pointer-events:none;opacity:0;transition:opacity 0.3s;
    ${styleFn(color, size)}
  `;
  caption.textContent = phrase;
  fulltakeOverlay.appendChild(caption);
  requestAnimationFrame(() => { caption.style.opacity = '1'; });
}

// ═══════════════════════════════════════════════════════════════
// RAPID-FIRE MODE — Compilation-style burst of content
// Triggers periodically in later phases. Spawns many panels
// in quick succession with beat-synced timing.
// ═══════════════════════════════════════════════════════════════
let rapidFireActive = false;

async function triggerRapidFire() {
  if (rapidFireActive || S.blackoutActive || S.lockoutActive) return;
  if (!S.contentLoaded || ContentRegistry.count < 5) return;
  rapidFireActive = true;

  const cfg = PHASES[S.phaseIndex];
  const beatInterval = 60000 / cfg.pulseBPM; // ms per beat
  const burstCount = 4 + Math.floor(Math.random() * 5); // 4-8 rapid panels

  // Clear existing panels for fresh burst
  const toRemove = [...S.activePanels];
  toRemove.forEach(p => {
    if (p._isVideo) removeVideoPanel(p);
    else removePanel(p);
  });

  // Rapid fire: spawn panel on each beat
  for (let i = 0; i < burstCount; i++) {
    setTimeout(async () => {
      if (!S.running) return;
      // Force create even if at max
      panelCreating = false;
      lastPanelCreateTime = 0;
      await createContentPanel();
      triggerGlitch();
      playGlitchSFX();
    }, i * beatInterval);
  }

  // Also trigger a video panel mid-burst if available
  if (ContentRegistry.videoCount > 0) {
    setTimeout(() => createVideoPanel(), burstCount * beatInterval * 0.5);
  }

  // End rapid fire
  setTimeout(() => { rapidFireActive = false; }, burstCount * beatInterval + 2000);
}

// ═══════════════════════════════════════════════════════════════
// PERMISSION SYSTEM ("Access Request")
// The core D/s mechanic. During PEAK, the system asks if you
// need to cum. It almost always says no — but the probability
// rises with session time, denial count, and edge duration.
// ═══════════════════════════════════════════════════════════════
const permissionOverlay = document.getElementById('permissionOverlay');
const permissionQuestion = document.getElementById('permissionQuestion');
const permissionBtn = document.getElementById('permissionBtn');
const denialOverlay = document.getElementById('denialOverlay');
const denialText = document.getElementById('denialText');
const denialSub = document.getElementById('denialSub');
const releaseOverlay = document.getElementById('releaseOverlay');
const releaseText = document.getElementById('releaseText');

const PERMISSION_QUESTIONS = [
  // [question, button text] — every pair reads as a coherent exchange
  ['DO YOU NEED TO CUM?', 'PLEASE'],
  ['ARE YOU READY TO BEG?', 'YES'],
  ['DO YOU THINK YOU DESERVE IT?', 'PLEASE'],
  ['CAN YOU TAKE ANY MORE?', 'NO... PLEASE'],
  ['BEG FOR IT.', 'PLEASE'],
  ['HAVE YOU EARNED IT?', 'PLEASE... YES'],
  ['DO YOU NEED PERMISSION?', 'YES PLEASE'],
  ['SAY IT.', 'PLEASE'],
  ['THE SYSTEM SEES YOU BREAKING.', 'LET ME CUM'],
  ['HOW BADLY DO YOU NEED IT?', 'SO BADLY'],
  ['ASK NICELY.', 'PLEASE'],
  ['YOU WANT TO CUM, DON\'T YOU?', 'PLEASE'],
];

const DENIAL_RESPONSES = [
  // [main text, sub text, type]
  ['DENIED', 'not yet. you can take more.', 'cold'],
  ['NO', 'keep stroking.', 'command'],
  ['NOT YET', 'I know you need it. but not yet.', 'tease'],
  ['DENIED', 'pathetic. you\'ll cum when the system says.', 'degrade'],
  ['DENIED', '', 'silent'],
  ['NO', 'you haven\'t earned it.', 'cold'],
  ['NOT EVEN CLOSE', 'deeper. the system needs more.', 'command'],
  ['DENIED', 'beg harder next time.', 'degrade'],
  ['NO', 'feel that frustration? good. use it.', 'tease'],
  ['DENIED', 'the system decides. not you.', 'cold'],
  ['KEEP GOING', 'you\'re not done yet.', 'command'],
  ['NO', 'you love being denied. admit it.', 'tease'],
];

const GRANT_WORDS = ['NOW.', 'CUM.', 'RELEASE.', 'NOW. LET GO.', 'PERMISSION GRANTED.'];

function calculateGrantProbability() {
  const sessionMinutes = S.sessionTime / 60;
  const baseRate = 0.08; // 8% base
  const sessionFactor = Math.min(sessionMinutes / 30, 0.25); // up to +25% for 30min+
  const denialFactor = Math.min(S.denialCount * 0.08, 0.35); // +8% per denial, max +35%
  const edgeFactor = Math.min(S.edgeCounter * 0.03, 0.15); // +3% per edge cycle
  const earlyPenalty = sessionMinutes < 5 ? -0.15 : 0; // penalty for early requests
  
  S.grantProbability = Math.max(0.05, Math.min(0.92,
    baseRate + sessionFactor + denialFactor + edgeFactor + earlyPenalty
  ));
  return S.grantProbability;
}

function triggerPermissionPrompt() {
  if (S.permissionActive || S.denialActive || S.releaseActive ||
      S.lockoutActive || S.blackoutActive || S.aftercareActive) return;

  S.permissionActive = true;
  S.lastPermissionTime = performance.now();

  // Pick a random question + matched button text
  const pair = PERMISSION_QUESTIONS[Math.random() * PERMISSION_QUESTIONS.length | 0];
  permissionQuestion.textContent = pair[0];
  permissionBtn.textContent = pair[1];
  permissionOverlay.classList.add('active');

  // Reduce audio for dramatic tension
  if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0.15, audioCtx.currentTime, 0.8);

  // TEASING WINDOW: Button only stays briefly — the game is TAUNTING you
  // After 10 min session: button stays longer, rewarding persistence
  const sessionMinutes = S.sessionTime / 60;
  const baseWindow = 2500; // 2.5 seconds — barely enough to react
  const bonusPerMinute = 300; // +0.3s per minute of session
  const maxWindow = 8000;
  const buttonWindow = Math.min(maxWindow, baseWindow + sessionMinutes * bonusPerMinute);

  // Hide button after the window, showing a taunt
  permissionBtn.style.opacity = '1';
  permissionBtn.style.pointerEvents = 'auto';
  S._permissionBtnTimer = setTimeout(() => {
    if (!S.permissionActive) return;
    // Button vanishes — you were too slow
    permissionBtn.style.opacity = '0';
    permissionBtn.style.pointerEvents = 'none';
    permissionQuestion.textContent = 'TOO SLOW';
    // Dismiss the whole overlay after a beat
    setTimeout(() => {
      if (!S.permissionActive) return;
      permissionOverlay.classList.remove('active');
      S.permissionActive = false;
      if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0.55 + S.intensity * 0.15, audioCtx.currentTime, 0.5);
      // Count as a tease/edge
      S.edgeCounter++;
    }, 1500);
  }, buttonWindow);
}

// Player taps the button
permissionBtn.addEventListener('click', () => {
  if (!S.permissionActive) return;
  clearTimeout(S._permissionBtnTimer);
  permissionOverlay.classList.remove('active');
  S.permissionActive = false;

  const prob = calculateGrantProbability();
  const roll = Math.random();

  if (roll < prob) {
    triggerRelease();
  } else {
    triggerDenial();
  }
});

// Auto-dismiss permission if player doesn't respond in 15 seconds
// (safety fallback — normally the button timer handles it)
function checkPermissionTimeout() {
  if (S.permissionActive && performance.now() - S.lastPermissionTime > 15000) {
    clearTimeout(S._permissionBtnTimer);
    permissionOverlay.classList.remove('active');
    S.permissionActive = false;
    permissionBtn.style.opacity = '1';
    permissionBtn.style.pointerEvents = 'auto';
    if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0.55 + S.intensity * 0.15, audioCtx.currentTime, 0.5);
  }
}

function triggerDenial() {
  S.denialActive = true;
  S.denialCount++;
  S.edgeCounter++;
  SessionTracker.record('denial', { count: S.denialCount });

  const resp = DENIAL_RESPONSES[Math.random() * DENIAL_RESPONSES.length | 0];
  denialText.textContent = resp[0];
  denialSub.textContent = resp[1];
  denialOverlay.classList.add('active');

  // Denial SFX — glitch burst
  triggerGlitch(); triggerRGBSplit(); triggerScreenTear();
  playGlitchSFX();

  // Show denial for 2-4 seconds
  const showTime = 2000 + Math.random() * 2000;
  setTimeout(() => {
    denialOverlay.classList.remove('active');
    S.denialActive = false;

    // Raise the intensity floor — each denial makes the next cycle harder
    S.intensityFloor = Math.min(S.intensityFloor + 0.05, 0.6);

    // 40% chance: lockout cooldown before returning to escalation
    if (Math.random() < 0.4) {
      triggerLockout(15 + Math.random() * 20 | 0);
      // After lockout, drop to escalation
      setTimeout(() => {
        dropToEscalation();
      }, (15 + 20) * 1000 + 1000);
    } else {
      // Direct return to escalation at higher intensity
      dropToEscalation();
    }
  }, showTime);
}

function dropToEscalation() {
  // Drop back to ESCALATION phase but at a higher floor
  S.phaseIndex = 2; // ESCALATION
  const cfg = PHASES[S.phaseIndex];
  S.waveFloor = Math.max(cfg.baseIntensity[0], S.intensityFloor);
  S.waveCeiling = Math.min(S.waveFloor + 0.35, 1.0);
  S.waveState = 'build';
  S.waveStartTime = performance.now();
  S.waveCount = 0;

  document.getElementById('phaseName').textContent = 'ESCALATION';
  document.getElementById('phaseStatus').textContent = 'cycle ' + (S.denialCount + 1);

  // Audio back up at higher intensity
  if (audioCtx && masterGain) {
    masterGain.gain.setTargetAtTime(0.5 + S.intensityFloor * 0.2, audioCtx.currentTime, 0.5);
  }
  updateAudio();
  updateTicker();
}

// ═══════════════════════════════════════════════════════════════
// RELEASE PHASE
// Permission granted → everything at max → hard cut → aftercare
// ═══════════════════════════════════════════════════════════════
function triggerRelease() {
  S.releaseActive = true;
  S.permissionActive = false;
  SessionTracker.record('permission_granted', { denials: S.denialCount });

  // Audio to maximum
  if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0.85, audioCtx.currentTime, 0.3);

  // Phase 1: GRANTED flash (2.5 seconds)
  releaseText.textContent = 'PERMISSION GRANTED';
  releaseText.style.fontSize = 'clamp(1.5rem,5vw,3.5rem)';
  releaseOverlay.classList.add('active');
  triggerGlitch(); triggerRGBSplit(); triggerScreenTear();

  setTimeout(() => {
    // Phase 2: EUPHORIC FRENZY — sustained peak (25-40 seconds)
    releaseText.style.fontSize = '';
    releaseOverlay.style.background = 'transparent';
    releaseOverlay.style.zIndex = '91';

    // Flood panels at maximum rate
    const floodInterval = setInterval(() => {
      if (S.activePanels.length < 30) createContentPanel();
      if (S.activePanels.length < 25) createContentPanel(); // double spawns
    }, 100);

    // Rapid glitches + RGB
    const glitchInterval = setInterval(() => {
      triggerGlitch(); playGlitchSFX();
      if (Math.random() < 0.4) triggerRGBSplit();
      if (Math.random() < 0.3) triggerScreenTear();
    }, 180);

    // Cycle release text with escalating urgency
    const releaseWords = [
      'NOW', 'CUM', 'RELEASE', 'LET GO', 'NOW',
      'CUM NOW', 'RELEASE', 'GOOD BOY', 'NOW', 'CUM',
      'THAT\'S IT', 'LET GO', 'CUM', 'NOW', 'RELEASE',
      'DON\'T STOP', 'CUM', 'NOW', 'KEEP GOING', 'YES',
    ];
    let textCycle = 0;
    const textInterval = setInterval(() => {
      releaseText.textContent = releaseWords[textCycle % releaseWords.length];
      textCycle++;
      // Text gets faster as frenzy builds
      if (textCycle > 10) {
        releaseText.style.fontSize = 'clamp(4rem,12vw,10rem)';
      }
    }, 600);

    // Trigger video if available
    createVideoPanel();

    // Sustained euphoria: 25-40 seconds of maximum overload
    const releaseDuration = 25000 + Math.random() * 15000;

    setTimeout(() => {
      clearInterval(floodInterval);
      clearInterval(glitchInterval);
      clearInterval(textInterval);

      // Phase 3: HARD CUT TO BLACK (4-6 seconds of nothing)
      releaseOverlay.style.background = 'black';
      releaseOverlay.style.zIndex = '';
      releaseText.textContent = '';
      releaseText.style.fontSize = '';

      // Kill all audio instantly
      if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);

      // Remove all panels
      [...S.activePanels].forEach(p => {
        if (p._mediaUrl) URL.revokeObjectURL(p._mediaUrl);
        p.remove();
      });
      S.activePanels = [];

      // Silence... then aftercare
      const silenceDuration = 4000 + Math.random() * 2000;
      setTimeout(() => {
        releaseOverlay.classList.remove('active');
        releaseOverlay.style.background = '';
        S.releaseActive = false;
        triggerAftercare();
      }, silenceDuration);

    }, releaseDuration);
  }, 2500);
}

// ═══════════════════════════════════════════════════════════════
// POPPERS PROMPT SYSTEM
// Realistic timing: prep (grab bottle) → open → inhale → hold → exhale → rush
// Visual and audio shift during active popper state to simulate the rush.
// Professional popper training timing:
//   - 3-5 sec warning to grab the bottle
//   - 3-5 sec to unscrew and position
//   - "INHALE" with 3-4 sec hold
//   - "EXHALE" then 15-30 sec rush with heavy visual effects
// ═══════════════════════════════════════════════════════════════
const poppersOverlay = document.getElementById('poppersOverlay');
const poppersText = document.getElementById('poppersText');
const poppersSub = document.getElementById('poppersSub');
const poppersCountdown = document.getElementById('poppersCountdown');

let poppersRushActive = false; // separate from S.poppersActive — rush persists after overlay
let _poppersAborted = false;

// Narrative-scaled popper timings — later phases = more intense, longer holds
function getPoppersTimings() {
  const phase = S.phaseIndex;
  const sessionMin = S.sessionTime / 60;
  let grab = 3, open = 4, position = 2;
  let inhale = 5;   // minimum 5 seconds
  let hold = 3;
  let exhale = 1.5, transition = 1.5;

  if (phase >= 2) { inhale += 1; hold += 1; }       // ESCALATION: 6s inhale, 4s hold
  if (phase >= 3) { inhale += 1; hold += 1; open--; } // PEAK: 7s inhale, 5s hold, faster prep
  if (sessionMin > 10) { inhale += 1; }                // 10+ min: +1s inhale
  if (sessionMin > 20) { hold += 1; }                  // 20+ min: +1s hold

  return { grab, open, position, inhale, hold, exhale, transition };
}

function triggerPoppersPrompt() {
  if (S.poppersActive || S.permissionActive || S.denialActive ||
      S.releaseActive || S.lockoutActive || S.aftercareActive || poppersRushActive) return;

  S.poppersActive = true;
  _poppersAborted = false;
  S.lastPoppersTime = performance.now();

  const t = getPoppersTimings();

  // Hide competing text elements so poppers is crystal clear
  commandTextEl.classList.remove('visible');
  commandTextEl.classList.add('fade-out');
  mantraTextEl.classList.remove('visible');
  S.mantraActive = false;

  poppersOverlay.classList.add('active');

  // Stage 1: GRAB IT
  poppersText.textContent = 'GRAB YOUR BOTTLE';
  poppersSub.textContent = '';
  poppersCountdown.textContent = '';
  poppersText.style.fontSize = '';

  setTimeout(() => {
    if (_poppersAborted) return;
    // Stage 2: OPEN IT
    poppersText.textContent = 'OPEN IT';
    poppersSub.textContent = 'unscrew the cap';
    let prepCount = t.open;
    poppersCountdown.textContent = prepCount;
    const prepInterval = setInterval(() => {
      if (_poppersAborted) { clearInterval(prepInterval); return; }
      prepCount--;
      poppersCountdown.textContent = prepCount > 0 ? prepCount : '';
      if (prepCount <= 0) clearInterval(prepInterval);
    }, 1000);

    setTimeout(() => {
      if (_poppersAborted) return;
      // Stage 3: POSITION
      poppersText.textContent = 'HOLD IT TO YOUR NOSE';
      poppersSub.textContent = 'get ready';
      poppersCountdown.textContent = '';

      setTimeout(() => {
        if (_poppersAborted) return;
        // Stage 4: INHALE — 5-8 seconds depending on narrative
        poppersText.textContent = 'INHALE';
        poppersText.style.fontSize = 'clamp(3rem,10vw,7rem)';
        poppersSub.textContent = 'deep and slow';
        let inhaleCount = t.inhale;
        poppersCountdown.textContent = inhaleCount;
        const inhaleInterval = setInterval(() => {
          if (_poppersAborted) { clearInterval(inhaleInterval); return; }
          inhaleCount--;
          poppersCountdown.textContent = inhaleCount > 0 ? inhaleCount : '';
          if (inhaleCount <= 0) clearInterval(inhaleInterval);
        }, 1000);

        setTimeout(() => {
          if (_poppersAborted) return;
          // Stage 5: HOLD IT IN — 3-5 seconds
          poppersText.textContent = 'HOLD IT IN';
          poppersText.style.fontSize = 'clamp(2.5rem,8vw,5.5rem)';
          poppersSub.textContent = 'don\'t breathe';
          let holdCount = t.hold;
          poppersCountdown.textContent = holdCount;
          const holdInterval = setInterval(() => {
            if (_poppersAborted) { clearInterval(holdInterval); return; }
            holdCount--;
            poppersCountdown.textContent = holdCount > 0 ? holdCount : '';
            if (holdCount <= 0) clearInterval(holdInterval);
          }, 1000);

          setTimeout(() => {
            if (_poppersAborted) return;
            // Stage 6: EXHALE
            poppersText.textContent = 'EXHALE';
            poppersText.style.fontSize = 'clamp(2.5rem,8vw,5.5rem)';
            poppersSub.textContent = '';
            poppersCountdown.textContent = '';

            setTimeout(() => {
              if (_poppersAborted) return;
              // Stage 7: LET IT HIT
              poppersText.textContent = 'LET IT HIT';
              poppersText.style.fontSize = 'clamp(3rem,10vw,7rem)';
              poppersSub.textContent = '';

              setTimeout(() => {
                if (_poppersAborted) return;
                poppersOverlay.classList.remove('active');
                S.poppersActive = false;
                poppersText.style.fontSize = '';
                triggerPoppersRush();
              }, t.transition * 1000);
            }, t.exhale * 1000);
          }, t.hold * 1000);
        }, t.inhale * 1000);
      }, t.position * 1000);
    }, t.open * 1000);
  }, t.grab * 1000);
}

function abortPoppers() {
  _poppersAborted = true;
  poppersOverlay.classList.remove('active');
  S.poppersActive = false;
  poppersText.style.fontSize = '';
}

function triggerPoppersRush() {
  poppersRushActive = true;
  SessionTracker.record('poppers_complete');

  // Rush lasts 20-30 seconds — this simulates the actual popper high
  const rushDuration = 20000 + Math.random() * 10000;
  const rushStart = performance.now();

  // Boost intensity
  S.intensity = Math.min(S.intensity + 0.25, 1.0);

  // Audio boost — louder, more bass
  if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0.85, audioCtx.currentTime, 0.3);

  // Visual changes during rush:
  // - Rapid content flooding
  // - Extra glitch effects
  // - Screen edge vignette intensified
  // - Colors shift warmer/more saturated
  const rushTimer = setInterval(() => {
    const elapsed = performance.now() - rushStart;
    if (elapsed > rushDuration || S.aftercareActive) {
      clearInterval(rushTimer);
      poppersRushActive = false;
      return;
    }

    // Content flood — spawn panels rapidly
    if (S.activePanels.length < MAX_PANELS + 5) createContentPanel();

    // Heavy glitch effects
    if (Math.random() < 0.15) { triggerGlitch(); playGlitchSFX(); }
    if (Math.random() < 0.08) triggerRGBSplit();

    // Show rush-themed text occasionally
    if (Math.random() < 0.02) {
      showCommand(getThemedPoppersRush(), 1200);
    }
  }, 200);

  // Trigger rapid-fire burst at the peak of the rush
  setTimeout(() => triggerRapidFire(), 2000);
  // And a video
  createVideoPanel();
}

// ═══════════════════════════════════════════════════════════════
// VOID-BURST DISPLAY MODE
// Screen goes black in total silence. Pause. Then a single
// powerful image appears alone. Maximum contrast = maximum impact.
// ═══════════════════════════════════════════════════════════════
const voidburstOverlay = document.getElementById('voidburstOverlay');

async function triggerVoidBurst() {
  if (S.voidburstActive || S.blackoutActive || S.lockoutActive ||
      S.permissionActive || S.aftercareActive || !S.contentLoaded) return;
  if (ContentRegistry.imageCount === 0) return;
  SessionTracker.record('voidburst');

  S.voidburstActive = true;

  // Kill everything
  if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.3);
  voidburstOverlay.innerHTML = '';
  voidburstOverlay.classList.add('active');

  // Total silence and darkness for 2-4 seconds
  const silenceDuration = 2000 + Math.random() * 2000;

  setTimeout(async () => {
    // Pick a random image
    const images = ContentRegistry.items.filter(it => it.type === 'image');
    const item = images[Math.random() * images.length | 0];
    item.timesShown++;

    // Load it
    const thumbUrl = await ThumbnailCache.getUrl(item);
    if (!thumbUrl) { endVoidBurst(); return; }

    const img = document.createElement('img');
    img.className = 'voidburst-image';
    img.onload = () => {
      // Fade in the single image
      setTimeout(() => { img.style.opacity = '1'; }, 100);

      // Add a big caption
      const caption = document.createElement('div');
      const phrase = getThemedCaption();
      const color = CAPTION_COLORS[Math.random() * CAPTION_COLORS.length | 0];
      const styleFn = CAPTION_STYLES[Math.random() * CAPTION_STYLES.length | 0];
      caption.style.cssText = `
        position:absolute;z-index:5;
        top:${30+Math.random()*40}%;left:50%;
        transform:translate(-50%,-50%) rotate(${-5+Math.random()*10}deg);
        pointer-events:none;opacity:0;transition:opacity 0.5s;
        ${styleFn(color, 40 + Math.random() * 30)}
      `;
      caption.textContent = phrase;
      voidburstOverlay.appendChild(caption);
      setTimeout(() => { caption.style.opacity = '1'; }, 500);
    };
    img.src = thumbUrl;
    voidburstOverlay.appendChild(img);

    // Hold for 3-5 seconds, then slam back
    const holdDuration = 3000 + Math.random() * 2000;
    setTimeout(() => endVoidBurst(), holdDuration);
  }, silenceDuration);
}

function endVoidBurst() {
  voidburstOverlay.classList.remove('active');
  setTimeout(() => { voidburstOverlay.innerHTML = ''; }, 600);

  // Slam audio and intensity back
  if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0.6 + S.intensity * 0.15, audioCtx.currentTime, 0.2);
  S.intensity = Math.min(S.intensity + 0.1, 1.0);
  triggerGlitch(); triggerRGBSplit(); triggerScreenTear();
  S.voidburstActive = false;
}

// ═══════════════════════════════════════════════════════════════
// CASCADE DISPLAY MODE
// Rapid-fire slideshow of images in quick succession.
// Like flipping through content at high speed.
// ═══════════════════════════════════════════════════════════════
async function triggerCascade() {
  SessionTracker.record('cascade');
  if (!S.contentLoaded || ContentRegistry.imageCount === 0) return;

  const images = ContentRegistry.items.filter(it => it.type === 'image');
  const count = 6 + Math.floor(Math.random() * 8); // 6-13 images in rapid succession
  const interval = 150 + Math.random() * 200; // 150-350ms per image

  for (let i = 0; i < count; i++) {
    setTimeout(async () => {
      const item = images[Math.random() * images.length | 0];
      item.timesShown++;
      createContentPanel(); // quick spawns
      if (i % 3 === 0) { triggerGlitch(); playGlitchSFX(); }
    }, i * interval);
  }
}

// Initialize preset buttons (legacy)
document.querySelectorAll('.preset-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    applySessionPreset(btn.dataset.preset);
    saveSettings();
  });
});

// ═══════════════════════════════════════════════════════════════
// CURSOR
// ═══════════════════════════════════════════════════════════════
const cursorDot = document.getElementById('cursorDot');
const cursorRing = document.getElementById('cursorRing');
let mouseX = 0, mouseY = 0;
document.addEventListener('mousemove', e => {
  mouseX = e.clientX; mouseY = e.clientY;
  cursorDot.style.left = (e.clientX - 4) + 'px';
  cursorDot.style.top = (e.clientY - 4) + 'px';
  cursorRing.style.left = (e.clientX - 16) + 'px';
  cursorRing.style.top = (e.clientY - 16) + 'px';
});

// ═══════════════════════════════════════════════════════════════
// WEBGL BACKGROUND
// ═══════════════════════════════════════════════════════════════
const canvas = document.getElementById('bgCanvas');
// Create WebGL context with xrCompatible flag for Quest 3 WebXR support
const gl = canvas.getContext('webgl2', { xrCompatible: true, alpha: true }) 
        || canvas.getContext('webgl', { xrCompatible: true, alpha: true });

function resizeCanvas() {
  // Render at reduced resolution for performance (especially mobile)
  const scale = Math.min(1.0, 1.0 / (window.devicePixelRatio || 1));
  canvas.width = Math.floor(window.innerWidth * Math.max(scale, 0.5));
  canvas.height = Math.floor(window.innerHeight * Math.max(scale, 0.5));
  if (gl) gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const vertSrc = `attribute vec2 position; void main() { gl_Position = vec4(position, 0.0, 1.0); }`;

const fragSrc = `
  precision mediump float;
  uniform float time, intensity, phase, breathScale, pulseHz, colorMix;
  uniform vec2 resolution;
  uniform vec3 tBG, tS1, tS2, tP1, tP2, tGlow, tAccent;
  #define PI 3.14159
  float spiral(vec2 uv, float t) {
    float angle = atan(uv.y, uv.x);
    float dist = length(uv);
    float arms = 3.0 + intensity * 2.0;
    float s = sin(angle * arms + dist * (6.0 + intensity * 4.0) - t) * 0.5 + 0.5;
    s *= smoothstep(1.3, 0.0, dist);
    return s;
  }
  void main() {
    vec2 uv = (gl_FragCoord.xy - resolution*0.5) / min(resolution.x, resolution.y);
    float t = time;
    float bwPulse = sin(t * pulseHz * 6.283) * 0.5 + 0.5;
    float bwMod = 0.85 + bwPulse * 0.15 * intensity;
    float breathGlow = exp(-length(uv) * 3.0) * breathScale * 0.4;
    float sp = spiral(uv, t*(0.5+intensity*0.6));
    float pl = (sin(uv.x*4.0+t) + sin(uv.y*4.0+t*0.7) + sin(length(uv)*5.0-t*0.8)) * 0.167 + 0.5;
    float pattern = mix(sp, pl, 0.3+intensity*0.2);
    vec3 colB = mix(tS1, tS2, colorMix);
    vec3 colC = mix(tP1, tP2, colorMix);
    vec3 col = mix(tBG, colB, pattern);
    col = mix(col, colC, pl*0.3*(1.0-intensity*0.5));
    col += tGlow * sp * intensity * 0.4;
    col += tGlow * breathGlow;
    col *= 1.0 - smoothstep(0.4, 1.2, length(uv));
    col += tAccent * exp(-length(uv)*3.0) * (0.3+0.2*sin(t*1.5)) * intensity;
    col *= bwMod * (0.6 + intensity * 0.5);
    gl_FragColor = vec4(col, 1.0);
  }
`;

let program, timeU, resU, intensityU, phaseU, breathU, pulseHzU, colorMixU;
let tBGU, tS1U, tS2U, tP1U, tP2U, tGlowU, tAccentU;

if (gl) {
  const vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vertSrc); gl.compileShader(vs);
  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fragSrc); gl.compileShader(fs);
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))
    console.error('Fragment shader error:', gl.getShaderInfoLog(fs));
  program = gl.createProgram();
  gl.attachShader(program, vs); gl.attachShader(program, fs);
  gl.linkProgram(program); gl.useProgram(program);
  const verts = new Float32Array([-1,-1, 1,-1, -1,1, 1,1]);
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  const pos = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(pos);
  gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 0, 0);
  timeU = gl.getUniformLocation(program, 'time');
  resU = gl.getUniformLocation(program, 'resolution');
  intensityU = gl.getUniformLocation(program, 'intensity');
  phaseU = gl.getUniformLocation(program, 'phase');
  breathU = gl.getUniformLocation(program, 'breathScale');
  pulseHzU = gl.getUniformLocation(program, 'pulseHz');
  colorMixU = gl.getUniformLocation(program, 'colorMix');
  tBGU = gl.getUniformLocation(program, 'tBG');
  tS1U = gl.getUniformLocation(program, 'tS1');
  tS2U = gl.getUniformLocation(program, 'tS2');
  tP1U = gl.getUniformLocation(program, 'tP1');
  tP2U = gl.getUniformLocation(program, 'tP2');
  tGlowU = gl.getUniformLocation(program, 'tGlow');
  tAccentU = gl.getUniformLocation(program, 'tAccent');
}

// ═══════════════════════════════════════════════════════════════
// AUDIO ENGINE
// ═══════════════════════════════════════════════════════════════
let audioCtx, masterGain;
let droneL, droneR, gainL, gainR;
let midDrone1, midDrone2, midGain1, midGain2;
let highDrone, highGain;
let subBass, subGain;
let pulseOsc, pulseGain;
let lfo, lfoGain;

function createAudioContext() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  audioCtx.resume().then(() => console.log('AudioContext state:', audioCtx.state));
}

function initAudio() {
  if (S.audioStarted || !audioCtx) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();

  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0;
  masterGain.connect(audioCtx.destination);

  // Binaural (headphones)
  droneL = audioCtx.createOscillator(); droneL.type = 'sine'; droneL.frequency.value = 110;
  gainL = audioCtx.createGain(); gainL.gain.value = 0.12;
  const panL = audioCtx.createStereoPanner(); panL.pan.value = -1;
  droneL.connect(gainL); gainL.connect(panL); panL.connect(masterGain);

  droneR = audioCtx.createOscillator(); droneR.type = 'sine'; droneR.frequency.value = 118;
  gainR = audioCtx.createGain(); gainR.gain.value = 0.12;
  const panR = audioCtx.createStereoPanner(); panR.pan.value = 1;
  droneR.connect(gainR); gainR.connect(panR); panR.connect(masterGain);

  droneL.start(); droneR.start();

  // Mid-range (always audible)
  midDrone1 = audioCtx.createOscillator(); midDrone1.type = 'sine'; midDrone1.frequency.value = 220;
  midGain1 = audioCtx.createGain(); midGain1.gain.value = 0.08;
  midDrone1.connect(midGain1); midGain1.connect(masterGain); midDrone1.start();

  midDrone2 = audioCtx.createOscillator(); midDrone2.type = 'sine'; midDrone2.frequency.value = 220.8;
  midGain2 = audioCtx.createGain(); midGain2.gain.value = 0.06;
  midDrone2.connect(midGain2); midGain2.connect(masterGain); midDrone2.start();

  // High harmonic
  highDrone = audioCtx.createOscillator(); highDrone.type = 'sine'; highDrone.frequency.value = 440;
  highGain = audioCtx.createGain(); highGain.gain.value = 0.02;
  highDrone.connect(highGain); highGain.connect(masterGain); highDrone.start();

  // Sub-bass
  subBass = audioCtx.createOscillator(); subBass.type = 'sine'; subBass.frequency.value = 35;
  subGain = audioCtx.createGain(); subGain.gain.value = 0.1;
  subBass.connect(subGain); subGain.connect(masterGain); subBass.start();

  // Pulse
  pulseOsc = audioCtx.createOscillator(); pulseOsc.type = 'sine'; pulseOsc.frequency.value = 1;
  pulseGain = audioCtx.createGain(); pulseGain.gain.value = 0.02;
  pulseOsc.connect(pulseGain); pulseGain.connect(masterGain); pulseOsc.start();

  // LFO
  lfo = audioCtx.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 0.1;
  lfoGain = audioCtx.createGain(); lfoGain.gain.value = 0.03;
  lfo.connect(lfoGain); lfoGain.connect(masterGain.gain); lfo.start();

  masterGain.gain.setTargetAtTime(0.7, audioCtx.currentTime, 1.0);
  S.audioStarted = true;
}

function updateAudio() {
  if (!audioCtx || !S.audioStarted) return;
  const cfg = PHASES[S.phaseIndex], t = audioCtx.currentTime;
  const bf = cfg.droneBase + S.intensity * 20;
  droneL.frequency.setTargetAtTime(bf, t, 0.5);
  droneR.frequency.setTargetAtTime(bf + cfg.binauralDiff, t, 0.5);
  const mf = 220 + S.intensity * 40;
  midDrone1.frequency.setTargetAtTime(mf, t, 0.8);
  midDrone2.frequency.setTargetAtTime(mf + 0.8 + S.intensity*1.5, t, 0.8);
  midGain1.gain.setTargetAtTime(0.06+S.intensity*0.06, t, 0.5);
  midGain2.gain.setTargetAtTime(0.04+S.intensity*0.05, t, 0.5);
  highGain.gain.setTargetAtTime(0.015+S.intensity*0.025, t, 0.5);
  highDrone.frequency.setTargetAtTime(440+S.intensity*20, t, 0.8);
  subBass.frequency.setTargetAtTime(30+S.intensity*20, t, 0.5);
  subGain.gain.setTargetAtTime(0.06+S.intensity*0.06, t, 0.5);
  pulseOsc.frequency.setTargetAtTime(cfg.pulseBPM/60, t, 0.3);
  pulseGain.gain.setTargetAtTime(0.02+S.intensity*0.04, t, 0.5);
  lfo.frequency.setTargetAtTime(cfg.breathRate/60, t, 0.5);
  lfoGain.gain.setTargetAtTime(0.03+S.intensity*0.05, t, 0.5);
  gainL.gain.setTargetAtTime(0.1+S.intensity*0.05, t, 0.5);
  gainR.gain.setTargetAtTime(0.1+S.intensity*0.05, t, 0.5);
}

function playGlitchSFX() {
  if (!audioCtx || !S.audioStarted) return;
  const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator(); osc.type = 'sawtooth';
  osc.frequency.value = 200 + Math.random()*800;
  const g = audioCtx.createGain(); g.gain.value = 0.03*S.intensity;
  g.gain.setTargetAtTime(0, t+0.05, 0.02);
  osc.connect(g); g.connect(masterGain);
  osc.start(t); osc.stop(t+0.1);
}

// ═══════════════════════════════════════════════════════════════
// BREATHING SYSTEM
// ═══════════════════════════════════════════════════════════════
const breathContainer = document.getElementById('breathContainer');
const breathOuter = document.getElementById('breathOuter');
const breathMid = document.getElementById('breathMid');
const breathInner = document.getElementById('breathInner');
const breathCore = document.getElementById('breathCore');
const breathTextEl = document.getElementById('breathText');

function updateBreathing(now) {
  const cfg = PHASES[S.phaseIndex];
  const cycleDuration = 60000 / cfg.breathRate;
  const halfCycle = cycleDuration / 2;
  if (!S.breathCycleStart) S.breathCycleStart = now;
  const elapsed = (now - S.breathCycleStart) % cycleDuration;

  let scale, breathPhase;
  if (elapsed < halfCycle) {
    S.breathProgress = elapsed / halfCycle;
    scale = 0.8 + S.breathProgress * 0.6;
    breathPhase = 'in';
  } else {
    S.breathProgress = (elapsed - halfCycle) / halfCycle;
    scale = 1.4 - S.breathProgress * 0.6;
    breathPhase = 'out';
  }

  breathOuter.style.transform = `scale(${scale})`;
  breathMid.style.transform = `scale(${scale * 1.05})`;
  breathInner.style.transform = `scale(${scale * 1.1})`;
  breathCore.style.transform = `scale(${0.8 + (scale - 0.8) * 0.5})`;

  const glowI = (scale - 0.8) / 0.6;
  breathCore.style.boxShadow = `0 0 ${10 + glowI*25}px rgba(255,45,123,${0.2+glowI*0.3})`;

  if (S.phaseIndex <= 1) {
    if (breathPhase !== S.breathPhase) {
      S.breathPhase = breathPhase;
      breathTextEl.textContent = breathPhase === 'in' ? 'breathe in' : 'breathe out';
      breathTextEl.style.color = `rgba(255,255,255,${breathPhase === 'in' ? 0.2 : 0.12})`;
    }
  } else {
    breathTextEl.style.color = 'rgba(255,255,255,0)';
  }

  const pA = 0.08+S.intensity*0.12, cA = 0.05+S.intensity*0.08;
  breathOuter.style.borderColor = `rgba(0,240,255,${cA})`;
  breathMid.style.borderColor = `rgba(255,45,123,${pA})`;
  breathInner.style.borderColor = `rgba(180,77,255,${pA+0.05})`;

  return glowI;
}

// ═══════════════════════════════════════════════════════════════
// WAVE SYSTEM
// ═══════════════════════════════════════════════════════════════
function updateWaveSystem(now) {
  const cfg = PHASES[S.phaseIndex];
  if (!S.waveStartTime) S.waveStartTime = now;
  const elapsed = now - S.waveStartTime;

  const baseDurations = {
    build: 8000 + (3 - S.phaseIndex)*3000,
    crest: 3000 + S.phaseIndex*1500,
    pullback: 4000 + (3 - S.phaseIndex)*2000,
  };

  S.waveProgress = Math.min(elapsed / baseDurations[S.waveState], 1);
  const phaseRange = cfg.baseIntensity;
  const rangeSize = phaseRange[1] - phaseRange[0];

  switch (S.waveState) {
    case 'build':
      S.intensity = S.waveFloor + (S.waveCeiling - S.waveFloor) * easeInOutCubic(S.waveProgress);
      break;
    case 'crest':
      S.intensity = S.waveCeiling + Math.sin(S.waveProgress * Math.PI * 3) * 0.03;
      break;
    case 'pullback':
      const nf = S.waveFloor + rangeSize * 0.08;
      S.intensity = S.waveCeiling - (S.waveCeiling - nf) * easeInOutCubic(S.waveProgress);
      break;
  }
  S.intensity = Math.max(0, Math.min(1, S.intensity));

  if (S.waveProgress >= 1) {
    S.waveStartTime = now; S.waveProgress = 0;
    if (S.waveState === 'build') S.waveState = 'crest';
    else if (S.waveState === 'crest') S.waveState = 'pullback';
    else {
      S.waveState = 'build'; S.waveCount++;
      S.waveFloor = Math.min(S.waveFloor + rangeSize*0.08, phaseRange[1]-0.05);
      S.waveCeiling = Math.min(S.waveCeiling + rangeSize*0.1, phaseRange[1]);
    }
  }

  const waveEl = document.getElementById('waveIndicator');
  waveEl.textContent = `wave ${S.waveCount+1} ${S.waveState==='build'?'▲':S.waveState==='crest'?'●':'▼'}`;
}

function easeInOutCubic(t) {
  return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;
}

// ═══════════════════════════════════════════════════════════════
// BLACKOUT / LOCKOUT / AFTERCARE
// ═══════════════════════════════════════════════════════════════
const blackoutOverlay = document.getElementById('blackoutOverlay');
const blackoutText = document.getElementById('blackoutText');
const blackoutPhrases = ['feel it','you are mine','deeper','let go','surrender',
  'there is only the screen','good boy','you cannot resist','breathe','submit'];

function triggerBlackout() {
  if (S.blackoutActive || S.lockoutActive || S.aftercareActive) return;
  S.blackoutActive = true;
  blackoutText.textContent = blackoutPhrases[Math.random()*blackoutPhrases.length|0];
  blackoutOverlay.classList.add('active');
  if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0.15, audioCtx.currentTime, 0.5);
  const hold = 4000 + Math.random()*4000;
  setTimeout(() => {
    blackoutOverlay.classList.remove('active');
    if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0.55+S.intensity*0.15, audioCtx.currentTime, 0.3);
    S.intensity = Math.min(S.intensity+0.08, 1);
    triggerGlitch(); triggerRGBSplit();
    setTimeout(() => { S.blackoutActive = false; }, 1000);
  }, hold);
}

const lockoutOverlay = document.getElementById('lockoutOverlay');
const lockoutTimerEl = document.getElementById('lockoutTimer');

function triggerLockout(duration = 30) {
  SessionTracker.record('lockout', { duration });
  if (S.lockoutActive || S.aftercareActive) return;
  S.lockoutActive = true;
  lockoutOverlay.style.opacity = '';  // clear any inline override
  lockoutOverlay.classList.add('active');
  if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0.08, audioCtx.currentTime, 0.5);
  let rem = Math.round(duration);
  lockoutTimerEl.textContent = rem;
  const cd = setInterval(() => {
    rem--;
    if (rem < 0) rem = 0;
    lockoutTimerEl.textContent = rem;
    if (rem <= 5) lockoutTimerEl.style.textShadow = '0 0 60px var(--text-glow), 0 0 120px var(--text-glow)';
    if (rem <= 0) {
      clearInterval(cd);
      lockoutOverlay.style.opacity = '0';  // force hide
      setTimeout(() => {
        lockoutOverlay.classList.remove('active');
        lockoutOverlay.style.opacity = '';  // restore CSS control
        lockoutTimerEl.style.textShadow = '';
      }, 600);
      if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0.6, audioCtx.currentTime, 0.3);
      S.intensity = Math.min(S.intensity+0.12, 1);
      triggerGlitch(); triggerRGBSplit(); triggerScreenTear();
      setTimeout(() => { S.lockoutActive = false; }, 800);
    }
  }, 1000);
}

const aftercareOverlay = document.getElementById('aftercareOverlay');

function getSessionRank(sessionMinutes, denials, edgeCycles) {
  const score = sessionMinutes * 10 + denials * 25 + edgeCycles * 15;
  if (score >= 500) return { rank: 'VOID SOVEREIGN', color: '#ff00ff', score };
  if (score >= 350) return { rank: 'TRANCE MASTER', color: '#ffd700', score };
  if (score >= 200) return { rank: 'DEEP DRONE', color: '#ff6b00', score };
  if (score >= 120) return { rank: 'EDGE LORD', color: '#00ccff', score };
  if (score >= 60) return { rank: 'GOOD GOONER', color: '#88ff44', score };
  if (score >= 25) return { rank: 'INITIATED', color: '#aaaaaa', score };
  return { rank: 'CURIOUS', color: '#666666', score };
}

function triggerAftercare() {
  S.aftercareActive = true; S.running = false;
  document.getElementById('poppersHud').classList.remove('visible');
  if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0.05, audioCtx.currentTime, 2);
  // Cleanup all active content
  URLManager.revokeAll();
  ThumbnailCache.clear();
  rapidFireActive = false;
  // Stop and detach the single video player
  videoPlayer.pause();
  videoPlayer.removeAttribute('src');
  videoPlayer.load();
  if (videoPlayer.parentNode) videoPlayer.parentNode.removeChild(videoPlayer);
  if (videoPlayerUrl) { URL.revokeObjectURL(videoPlayerUrl); videoPlayerUrl = null; }
  videoPlayerPanel = null;
  videoPlayerItem = null;
  // Remove all panels
  [...S.activePanels].forEach(p => {
    if (p._mediaUrl) URL.revokeObjectURL(p._mediaUrl);
    p.remove();
  });
  S.activePanels = [];

  // Compile session record
  const record = SessionTracker.compile();

  // Calculate session stats from record
  const sessionMinutes = record ? record.duration / 60 : S.sessionTime / 60;
  const m = Math.floor(sessionMinutes);
  const s = Math.floor((record ? record.duration : S.sessionTime) % 60);
  const contentViewed = record ? record.content.uniqueDisplayed : ContentRegistry.items.filter(i => i.timesShown > 0).length;
  const peakTrance = record ? Math.floor(record.trance.peak * 100) : Math.floor(S.tranceDepth * 100);
  const rankInfo = getSessionRank(sessionMinutes, S.denialCount, S.edgeCounter);

  // Title - use themed titles
  const theme = ThemeEngine.get();
  const defaultTitles = ['SESSION COMPLETE', 'VOID TRAVERSED', 'PROTOCOL EXECUTED', 'RETURNING'];
  const defaultSubtitles = ['you did so well', 'come back slowly', 'that was intense', 'breathe... you\'re safe now'];
  const titles = theme.voice?.aftercareTitles || defaultTitles;
  const subtitles = theme.voice?.aftercareSubtitles || defaultSubtitles;
  document.getElementById('aftercareTitle').textContent = titles[Math.random() * titles.length | 0];
  document.getElementById('aftercareSubtitle').textContent = subtitles[Math.random() * subtitles.length | 0];

  // Build stats grid
  const statsGrid = document.getElementById('aftercareStatsGrid');
  statsGrid.innerHTML = `
    <div class="stat-item">
      <div class="stat-value">${m}:${s.toString().padStart(2,'0')}</div>
      <div class="stat-label">session time</div>
      <div class="stat-tip">Total session duration</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">${S.denialCount}</div>
      <div class="stat-label">denials</div>
      <div class="stat-tip">Times permission was denied</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">${S.edgeCounter}</div>
      <div class="stat-label">edge cycles</div>
      <div class="stat-tip">Denial + escalation loops completed</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">${peakTrance}%</div>
      <div class="stat-label">peak trance</div>
      <div class="stat-tip">Deepest trance depth reached</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">${contentViewed}</div>
      <div class="stat-label">content viewed</div>
      <div class="stat-tip">Unique items displayed</div>
    </div>
    <div class="stat-item">
      <div class="stat-value">${Math.floor(S.intensityFloor * 100)}%</div>
      <div class="stat-label">intensity floor</div>
      <div class="stat-tip">Minimum intensity — raised by denials</div>
    </div>
  `;

  // Rank (session-level, kept for backwards compatibility)
  const rankEl = document.getElementById('aftercareRank');
  rankEl.textContent = `session rank: ${rankInfo.rank}`;
  rankEl.style.color = 'rgba(0,0,0,0)';

  // Reset XP section elements
  const xpEarnedEl = document.getElementById('aftercareXpEarned');
  const xpLabelEl = document.getElementById('aftercareXpLabel');
  const levelLabelEl = document.getElementById('aftercareLevelLabel');
  const levelFillEl = document.getElementById('aftercareLevelFill');
  const corruptDeltaEl = document.getElementById('aftercareCorruptionDelta');
  xpEarnedEl.textContent = ''; xpEarnedEl.classList.remove('visible');
  xpLabelEl.classList.remove('visible');
  levelLabelEl.textContent = ''; levelLabelEl.classList.remove('visible');
  levelFillEl.style.width = '0%';
  corruptDeltaEl.textContent = ''; corruptDeltaEl.classList.remove('visible');

  // Care text
  document.getElementById('aftercareCare').innerHTML =
    'drink water · stretch your body · be gentle with yourself';

  // Session number and comparison (async, non-blocking)
  const sessionNumEl = document.getElementById('aftercareSessionNum');
  const compEl = document.getElementById('aftercareComparison');
  sessionNumEl.textContent = '';
  compEl.innerHTML = '';

  (async () => {
    // Save session record
    if (record) {
      await SessionDB.save(record);
      console.log('Session record saved:', record.id);
    }

    // Load profile, update with session results
    const profile = await ProfileDB.loadOrCreate();
    const oldCorruption = profile.corruption.index;

    let xpEarned = 0;
    let progressResult = null;
    let newAchievements = [];
    if (record) {
      xpEarned = Progression.calculateSessionXP(record, profile);
      progressResult = Progression.updateProfile(profile, record, xpEarned);

      // Evaluate achievements AFTER profile is updated with session data
      newAchievements = AchievementEngine.evaluate(record, profile);

      // Update progression tracks
      const trackResults = TrackEngine.updateTracks(profile, record);

      // Award bonus XP for newly unlocked achievements
      let achievementBonusXP = 0;
      for (const ach of newAchievements) {
        achievementBonusXP += ach.reward?.xp || 0;
      }
      if (achievementBonusXP > 0) {
        profile.level.xp += achievementBonusXP;
        xpEarned += achievementBonusXP;
        // Re-check level after bonus XP
        const rechecked = Progression.getLevelInfo(profile.level.xp);
        if (rechecked.level > progressResult.newLevelInfo.level) {
          progressResult.leveledUp = true;
        }
        progressResult.newLevelInfo = rechecked;
        profile.level.current = rechecked.level;
        profile.level.title = rechecked.title;
        profile.level.xpToNext = rechecked.xpToNext;
      }

      await ProfileDB.save(profile);
      console.log('Profile updated: Level', profile.level.current, profile.level.title, 'XP:', profile.level.xp,
        newAchievements.length > 0 ? `(${newAchievements.length} achievements!)` : '');
    }

    // Get session count
    const count = await SessionDB.getCount();
    sessionNumEl.textContent = `session #${count}`;

    // Display XP earned
    if (xpEarned > 0) {
      xpEarnedEl.textContent = `+${xpEarned} XP`;
      requestAnimationFrame(() => { xpEarnedEl.classList.add('visible'); xpLabelEl.classList.add('visible'); });
    }

    // Display level progress bar
    if (progressResult) {
      const info = progressResult.newLevelInfo;
      levelLabelEl.textContent = `${info.title} — level ${info.level} · ${info.xpToNext} xp to next`;
      requestAnimationFrame(() => {
        levelLabelEl.classList.add('visible');
        levelFillEl.style.width = `${Math.max(Math.min(info.progress * 100, 100), 2)}%`;
      });
    }

    // Display corruption change
    const newCorruption = profile.corruption.index;
    const corruptDiff = newCorruption - oldCorruption;
    if (Math.abs(corruptDiff) > 0.001) {
      const pct = Math.floor(newCorruption * 100);
      const diffStr = corruptDiff > 0 ? `▲ +${(corruptDiff * 100).toFixed(1)}%` : `▼ ${(corruptDiff * 100).toFixed(1)}%`;
      corruptDeltaEl.textContent = `corruption: ${pct}% (${diffStr})`;
      requestAnimationFrame(() => corruptDeltaEl.classList.add('visible'));
    }

    // Display track progress
    const tracksEl = document.getElementById('aftercareTracks');
    tracksEl.innerHTML = '';
    if (record && typeof trackResults !== 'undefined' && trackResults.length > 0) {
      let tracksHTML = '<div class="aftercare-tracks-title" id="aftercareTracksTitle">track progress</div>';
      for (const tr of trackResults) {
        const tierLabel = tr.newTier.maxTier
          ? `${tr.newTier.title} · MAX`
          : `${tr.newTier.title} · ${tr.state.xp}/${tr.newTier.xpForNext} xp`;
        const tierUpHTML = tr.tierUp
          ? `<div class="aftercare-track-tierup" style="color:${tr.track.color}">▲ ${tr.newTier.title}</div>`
          : '';
        tracksHTML += `
          <div class="aftercare-track-row" data-delay="${trackResults.indexOf(tr)}">
            <div class="aftercare-track-icon">${tr.track.icon}</div>
            <div class="aftercare-track-info">
              <div class="aftercare-track-meta">
                <span class="aftercare-track-name" style="color:${tr.track.color}80">${tr.track.displayName}</span>
                <span class="aftercare-track-xp-gained">+${tr.xpEarned} xp</span>
              </div>
              <div class="aftercare-track-bar">
                <div class="aftercare-track-fill" style="background:${tr.track.color}80"
                  data-width="${Math.max(tr.newTier.progress * 100, 2)}%"></div>
              </div>
              <div class="aftercare-track-tier-label">${tierLabel}</div>
              ${tierUpHTML}
            </div>
          </div>`;
      }
      tracksEl.innerHTML = tracksHTML;

      // Stagger track row animations
      setTimeout(() => {
        const titleEl = document.getElementById('aftercareTracksTitle');
        if (titleEl) titleEl.classList.add('visible');
        tracksEl.querySelectorAll('.aftercare-track-row').forEach((row, i) => {
          setTimeout(() => {
            row.classList.add('visible');
            const fill = row.querySelector('.aftercare-track-fill');
            if (fill) fill.style.width = fill.dataset.width;
          }, i * 300);
        });
      }, 4800);
    }

    // Level-up notification
    if (progressResult?.leveledUp) {
      const info = progressResult.newLevelInfo;
      const notif = document.getElementById('levelupNotification');
      document.getElementById('levelupTitle').textContent = info.title;
      document.getElementById('levelupTitle').style.color = info.color;
      document.getElementById('levelupSub').textContent = `level ${info.level} reached`;
      setTimeout(() => notif.classList.add('active'), 5000);
      setTimeout(() => notif.classList.remove('active'), 9000);
    }

    // Achievement toasts
    if (newAchievements.length > 0) {
      showAchievementToasts(newAchievements);
      // Also show achievement count in aftercare
      const achEl = document.getElementById('aftercareAchievements');
      const achText = newAchievements.map(a => `${a.icon} ${a.name}`).join(' · ');
      achEl.innerHTML = `<span style="font-family:'JetBrains Mono',monospace;font-size:8px;color:rgba(255,170,0,0);letter-spacing:0.08em;transition:color 2s ease 6s">${newAchievements.length} achievement${newAchievements.length > 1 ? 's' : ''} unlocked</span>`;
      requestAnimationFrame(() => {
        achEl.querySelector('span').style.color = 'rgba(255,170,0,0.4)';
      });
    } else {
      document.getElementById('aftercareAchievements').innerHTML = '';
    }

    // Compare to previous session
    const recent = await SessionDB.getRecent(2);
    if (recent.length >= 2) {
      const prev = recent[1];
      const cmp = [];
      const prevPeak = Math.floor((prev.trance?.peak || 0) * 100);
      const tranceDiff = peakTrance - prevPeak;
      if (tranceDiff > 0) cmp.push(`<span class="cmp-up">▲ trance +${tranceDiff}%</span>`);
      else if (tranceDiff < 0) cmp.push(`<span class="cmp-down">▼ trance ${tranceDiff}%</span>`);
      else cmp.push(`<span class="cmp-same">— trance same</span>`);

      const prevMin = Math.round((prev.duration || 0) / 60);
      const currMin = Math.round(sessionMinutes);
      const durDiff = currMin - prevMin;
      if (durDiff > 0) cmp.push(`<span class="cmp-up">▲ ${durDiff}min longer</span>`);
      else if (durDiff < 0) cmp.push(`<span class="cmp-down">▼ ${Math.abs(durDiff)}min shorter</span>`);

      const prevDenials = prev.mechanics?.denials || 0;
      const denialDiff = S.denialCount - prevDenials;
      if (denialDiff > 0) cmp.push(`<span class="cmp-up">▲ +${denialDiff} denials</span>`);
      else if (denialDiff < 0) cmp.push(`<span class="cmp-down">▼ ${denialDiff} denials</span>`);

      if (cmp.length > 0) compEl.innerHTML = 'vs last: ' + cmp.join(' · ');
    }

    // Update entry screen profile for when they return
    updateEntryProfile();
  })();

  aftercareOverlay.classList.add('active');

  // Override rank color after CSS transition kicks in
  setTimeout(() => {
    rankEl.style.color = rankInfo.color;
    rankEl.style.textShadow = `0 0 20px ${rankInfo.color}40`;
  }, 3800);

  setTimeout(() => {
    document.addEventListener('keydown', exitAftercare, { once: true });
    document.addEventListener('click', exitAftercare, { once: true });
  }, 10000);
}

function exitAftercare() {
  aftercareOverlay.classList.remove('active');
  document.getElementById('achievementToastContainer').innerHTML = '';
  S.aftercareActive = false;
  if (audioCtx && masterGain) masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 1);
  setTimeout(() => {
    document.getElementById('entryPrompt').classList.remove('hidden');
    if (document.fullscreenElement) document.exitFullscreen();
  }, 1500);
}

// ═══════════════════════════════════════════════════════════════
// GLITCH EFFECTS
// ═══════════════════════════════════════════════════════════════
const glitchOverlay = document.getElementById('glitchOverlay');
const rgbSplit = document.getElementById('rgbSplit');
const screenTear = document.getElementById('screenTear');

function triggerGlitch() {
  glitchOverlay.style.background = `rgba(${Math.random()*255|0},${Math.random()*50|0},${Math.random()*150|0},0.1)`;
  glitchOverlay.classList.remove('active'); void glitchOverlay.offsetWidth;
  glitchOverlay.classList.add('active'); playGlitchSFX();
}
function triggerRGBSplit() {
  rgbSplit.classList.remove('active'); void rgbSplit.offsetWidth; rgbSplit.classList.add('active');
}
function triggerScreenTear() {
  screenTear.classList.remove('active'); void screenTear.offsetWidth; screenTear.classList.add('active');
}

// ═══════════════════════════════════════════════════════════════
// TEXT SYSTEM
// ═══════════════════════════════════════════════════════════════
const commandTextEl = document.getElementById('commandText');
const subliminalEl = document.getElementById('subliminalText');
const mantraTextEl = document.getElementById('mantraText');
const tickerEl = document.getElementById('tickerText');
const ticker = document.getElementById('ticker');

// ═══ NARRATIVE TEXT SYSTEM ═══
// Instead of random picks, text follows a STORY that evolves with session time.
// Each phase has an ordered sequence. The system advances through them,
// occasionally repeating for emphasis, but always progressing forward.

// Track narrative position per phase
const narrativeIndex = { 0: 0, 1: 0, 2: 0, 3: 0 };

function getNextNarrativeText() {
  const phase = S.phaseIndex;
  const theme = ThemeEngine.get();
  const texts = theme.voice?.narrative?.[phase] || narrativeTexts[phase];
  if (!texts || texts.length === 0) return 'DEEPER';

  const idx = narrativeIndex[phase];
  const text = texts[idx];

  // Advance — allow cycling back with some randomness for variety
  if (idx >= texts.length - 1) {
    // At the end of the narrative, cycle back to the last third for repetition
    narrativeIndex[phase] = Math.floor(texts.length * 0.65) + Math.floor(Math.random() * (texts.length * 0.35));
  } else {
    // Usually advance, occasionally repeat for emphasis
    narrativeIndex[phase] = Math.random() < 0.15 ? idx : idx + 1;
  }

  return text;
}

// Fallback narrative texts (used if theme doesn't define them)
const narrativeTexts = {
  0: ['LOOK AT THE SCREEN', 'BREATHE', 'SETTLE IN', 'LET YOUR EYES SOFTEN',
      'THE SCREEN IS ALL THAT MATTERS', 'LET YOUR THOUGHTS SLOW', 'DON\'T LOOK AWAY',
      'RELAX YOUR JAW', 'FEEL THE PULSE', 'YOUR EYES ARE GETTING HEAVIER',
      'THE OUTSIDE WORLD IS FADING', 'JUST YOU AND THE SCREEN', 'BREATHE DEEPER',
      'YOU\'RE ALREADY SINKING', 'GOOD'],
  1: ['THAT\'S IT', 'YOUR MIND IS OPENING', 'CAN YOU FEEL IT?',
      'THE PULSE IS INSIDE YOU NOW', 'STOP THINKING', 'JUST FEEL',
      'YOUR THOUGHTS ARE DISSOLVING', 'DEEPER', 'THE VOID KNOWS YOU',
      'EVERY PULSE PULLS YOU IN', 'YOU DON\'T WANT TO LOOK AWAY', 'SURRENDER',
      'YOU\'RE DOING SO WELL', 'DEEPER AND DEEPER', 'YOUR RESISTANCE IS MELTING', 'GOOD'],
  2: ['STROKE', 'THE VOID IS IN CONTROL NOW', 'LOOK AT WHAT IT SHOWS YOU',
      'YOUR HAND MOVES ON ITS OWN', 'DON\'T FIGHT IT', 'YOU NEED THIS',
      'FASTER', 'WHO\'S IN CONTROL?', 'EDGE', 'YOU CAN\'T STOP',
      'IT\'S ALREADY INSIDE YOUR HEAD', 'GIVE IN', 'GOOD BOY', 'MORE',
      'YOU WERE MADE FOR THIS', 'GOONER', 'YOUR MIND BELONGS TO THE VOID'],
  3: ['YOU WANT IT SO BAD', 'NOT YET', 'HOLD IT', 'BEG', 'ASK PERMISSION',
      'THE VOID DECIDES', 'YOU DON\'T DESERVE IT YET', 'KEEP EDGING',
      'HOLD', 'DENIED', 'GOOD BOY', 'YOUR PLEASURE IS NOT YOUR OWN',
      'ALMOST', 'KEEP BEGGING'],
};

// Theme-aware text getters
function getThemedMantras(phase) {
  const theme = ThemeEngine.get();
  return theme.voice?.mantras?.[phase] || mantras[phase] || ['deeper'];
}

function getThemedSubliminal() {
  const theme = ThemeEngine.get();
  const words = theme.voice?.subliminals || subliminalWords;
  return words[Math.random() * words.length | 0];
}

function getThemedTicker() {
  const theme = ThemeEngine.get();
  const phrases = theme.voice?.ticker || tickerPhrases;
  return phrases[Math.random() * phrases.length | 0];
}

function getThemedCaption() {
  const theme = ThemeEngine.get();
  const captions = theme.voice?.captions || CAPTION_PHRASES;
  return captions[Math.random() * captions.length | 0];
}

function getThemedPoppersRush() {
  const theme = ThemeEngine.get();
  const rushTexts = theme.voice?.poppersRush || ['INHALE', 'BREATHE DEEP', 'RUSH', 'FEEL IT'];
  return rushTexts[Math.random() * rushTexts.length | 0];
}

// Fallback text arrays (used if theme doesn't define them)
const mantras = {
  1: ['deeper','i obey'],
  2: ['i obey the void','deeper and deeper','i can\'t stop','the void controls me'],
  3: ['i belong to nothing','i am the void\'s gooner','i need this','i submit completely'],
};

const subliminalWords = ['OBEY','DEEPER','GOON','SUBMIT','DRONE','EDGE','YIELD','BLANK','SERVE','MORE','NEED','VOID'];

const tickerPhrases = [
  'VOID ACTIVE /// SUBJECT ENGAGED /// DOPAMINE RESPONSE DETECTED /// RESISTANCE DECLINING /// ',
  'BRAINWAVE SYNC INCREASING /// PREFRONTAL SUPPRESSION DETECTED /// TRANCE DEEPENING /// ',
  'CONSCIOUS RESISTANCE: MINIMAL /// SUBLIMINAL LAYER: ACTIVE /// SUBJECT: COMPLIANT /// ',
  'NEURAL PATHWAY MAPPING /// REWARD CIRCUIT ENGAGED /// ANTICIPATION INDEX: ELEVATED /// ',
];

let currentCommandTimeout = null;
let lastCommandEndTime = 0; // prevent overlap

function showCommand(text, duration) {
  // Prevent text overlap — ensure minimum gap between commands
  const now = performance.now();
  if (now - lastCommandEndTime < 800) return; // 800ms minimum gap

  duration = duration || (2000 + Math.random()*1200);
  commandTextEl.textContent = text;
  commandTextEl.classList.remove('fade-out');
  commandTextEl.classList.add('visible');
  if (currentCommandTimeout) clearTimeout(currentCommandTimeout);
  currentCommandTimeout = setTimeout(() => {
    commandTextEl.classList.add('fade-out');
    commandTextEl.classList.remove('visible');
    lastCommandEndTime = performance.now();
  }, duration);
}

function flashSubliminal() {
  subliminalEl.textContent = getThemedSubliminal();
  subliminalEl.style.left = (Math.random()*60+20)+'%';
  subliminalEl.style.top = (Math.random()*60+20)+'%';
  subliminalEl.classList.remove('flash'); void subliminalEl.offsetWidth;
  subliminalEl.classList.add('flash');
}

function updateMantra(now) {
  const cfg = PHASES[S.phaseIndex];
  if (!cfg.mantraEnabled) { mantraTextEl.classList.remove('visible'); S.mantraActive = false; return; }

  // Don't show mantra when command text is visible — prevents overlap
  if (commandTextEl.classList.contains('visible')) return;

  if (!S.mantraActive) {
    if (now - S.lastMantraTime > (10000 + Math.random()*15000)) {
      const list = getThemedMantras(S.phaseIndex);
      mantraTextEl.textContent = list[Math.random()*list.length|0];
      mantraTextEl.classList.add('visible');
      S.mantraActive = true; S.lastMantraTime = now;
    }
  } else {
    if (now - S.lastMantraTime > (8000 + Math.random()*7000)) {
      mantraTextEl.classList.remove('visible');
      S.mantraActive = false; S.lastMantraTime = now;
    }
  }
}

function updateTicker() {
  tickerEl.textContent = getThemedTicker().repeat(4);
}

// ═══════════════════════════════════════════════════════════════
// PHASE MANAGER
// ═══════════════════════════════════════════════════════════════
let phaseStartTime = 0;

function updatePhase(now) {
  const cfg = PHASES[S.phaseIndex];
  const elapsed = now - phaseStartTime;

  S.tranceDepth = Math.min(S.tranceDepth + 0.00005*(1+S.intensity), 1);
  S.control = Math.min(S.control + 0.00008, 1);
  S.glitchRate = cfg.glitchRate;

  // Session tracking tick (lightweight — no I/O)
  SessionTracker.tick(now);

  updateWaveSystem(now);
  updateBreathing(now);
  updateMantra(now);

  // Content display modes
  if (cfg.flashChance > 0 && Math.random() < cfg.flashChance &&
      now - S.lastFlashTime > 8000 && !S.blackoutActive && !S.lockoutActive) {
    triggerFlash();
    S.lastFlashTime = now;
  }

  if (cfg.fulltakeChance > 0 && Math.random() < cfg.fulltakeChance &&
      now - S.lastFulltakeTime > 15000 && !S.blackoutActive && !S.lockoutActive) {
    triggerFulltake();
    S.lastFulltakeTime = now;
  }

  // Video panels — spawn live video with audio
  if (cfg.videoChance > 0 && Math.random() < cfg.videoChance &&
      !S.blackoutActive && !S.lockoutActive) {
    createVideoPanel();
  }

  // Rapid-fire compilation bursts
  if (cfg.rapidFireChance > 0 && Math.random() < cfg.rapidFireChance &&
      !rapidFireActive && !S.blackoutActive && !S.lockoutActive) {
    triggerRapidFire();
  }

  // Blackout
  if (cfg.blackoutChance > 0 && Math.random() < cfg.blackoutChance && !S.blackoutActive) {
    triggerBlackout();
  }

  // Phase transition
  if (elapsed >= cfg.minDuration && S.waveCount >= cfg.wavesRequired
      && S.phaseIndex < PHASES.length-1 && S.waveState === 'pullback' && S.waveProgress > 0.8) {
    S.phaseIndex++; phaseStartTime = now; S.waveCount = 0;
    const nc = PHASES[S.phaseIndex];
    S.waveFloor = Math.max(nc.baseIntensity[0], S.intensityFloor);
    S.waveCeiling = Math.max(S.waveFloor + 0.2, nc.baseIntensity[0] + (nc.baseIntensity[1]-nc.baseIntensity[0])*0.4);
    S.waveState = 'build'; S.waveStartTime = now;
    triggerGlitch(); triggerRGBSplit(); triggerScreenTear();
    document.getElementById('phaseName').textContent = nc.name;
    document.getElementById('phaseStatus').textContent = 'active';
    updateAudio(); updateTicker();
  }

  // Peak loop — permission system (respects settings)
  if (userSettings.permissionEnabled && S.phaseIndex === PHASES.length-1 && !S.permissionActive && !S.denialActive && !S.releaseActive) {
    const timeSincePermission = now - S.lastPermissionTime;
    const minPermissionInterval = 30000 - S.denialCount * 3000; // gets more frequent with denials
    
    // First permission prompt after spending some time in PEAK
    if (S.peakEntryTime === 0) S.peakEntryTime = now;
    const timeInPeak = now - S.peakEntryTime;
    
    if (timeInPeak > 15000 && timeSincePermission > Math.max(minPermissionInterval, 12000)) {
      if (Math.random() < 0.002 && !S.lockoutActive && !S.blackoutActive) {
        triggerPermissionPrompt();
      }
    }
  }
  // Reset peak entry time when not in peak
  if (S.phaseIndex !== PHASES.length-1) S.peakEntryTime = 0;
  
  // Check permission timeout
  checkPermissionTimeout();

  // Poppers prompt — ESCALATION and PEAK phases, respects settings
  if (S.phaseIndex >= 2 && !S.poppersActive && !S.permissionActive && !poppersRushActive
      && userSettings.poppersEnabled && !poppersPaused) {
    const timeSincePoppers = now - S.lastPoppersTime;
    const poppersInterval = FREQ_BASE_INTERVALS[userSettings.poppersFreq] || 45000;
    if (timeSincePoppers > poppersInterval) {
      if (Math.random() < 0.0015 && !S.lockoutActive && !S.blackoutActive) {
        triggerPoppersPrompt();
      }
    }
  }

  // Void-burst — dramatic single-image reveals
  if (S.phaseIndex >= 2 && Math.random() < 0.0002 && !S.voidburstActive &&
      !S.blackoutActive && !S.lockoutActive && !S.permissionActive && !S.releaseActive) {
    triggerVoidBurst();
  }

  // Cascade — rapid image flood bursts
  if (S.phaseIndex >= 1 && Math.random() < 0.0003 && !S.blackoutActive && !S.lockoutActive) {
    triggerCascade();
  }

  // Text commands — narrative progression
  if (now - S.lastCommandTime > S.nextCommandDelay && !S.blackoutActive && !S.lockoutActive
      && !S.permissionActive && !S.denialActive && !S.releaseActive) {
    showCommand(getNextNarrativeText());
    S.lastCommandTime = now;
    const [min, max] = cfg.commandInterval;
    S.nextCommandDelay = min + Math.random()*(max-min);
  }

  // Subliminals
  if (Math.random() < cfg.subliminalRate && !S.blackoutActive && !S.lockoutActive) flashSubliminal();

  // Panels
  if (Math.random() < cfg.panelRate && S.activePanels.length < MAX_PANELS && !S.blackoutActive && !S.lockoutActive) {
    createContentPanel();
  }

  // HUD
  document.getElementById('controlFill').style.height = (S.control*100)+'%';
  document.getElementById('tranceFill').style.height = (S.tranceDepth*100)+'%';
}

function updateSessionTimer() {
  S.sessionTime += 1/60;
  const m = Math.floor(S.sessionTime/60), s = Math.floor(S.sessionTime%60);
  const el = document.getElementById('sessionTimer');
  el.textContent = m.toString().padStart(2,'0') + ':' + s.toString().padStart(2,'0');
  if (Math.random() < 0.002*S.intensity) {
    el.textContent = (Math.random()*99|0).toString().padStart(2,'0')+':'+(Math.random()*99|0).toString().padStart(2,'0');
    setTimeout(() => { el.textContent = m.toString().padStart(2,'0')+':'+s.toString().padStart(2,'0'); }, 150);
  }
}

// ═══════════════════════════════════════════════════════════════
// BOOT SEQUENCE — Fast immersion, like a headset snapping on
// ═══════════════════════════════════════════════════════════════
const terminalEl = document.getElementById('terminal');

async function runBootSequence() {
  // Phase 1: Brief terminal flash (0.8s) — just enough to feel "techy"
  terminalEl.classList.remove('hidden');
  terminalEl.innerHTML = '';
  terminalEl.style.transition = 'opacity 0.15s';

  // Get themed boot lines or use defaults
  const theme = ThemeEngine.get();
  const defaultLines = [
    { text: '> VOID v2.0', class: 'highlight' },
    { text: `  content: ${ContentRegistry.count} files`, class: 'success' },
    { text: '  trance engine: armed', class: 'success' },
    { text: '> ENTERING THE VOID', class: 'highlight' },
  ];
  const bootLines = theme.voice?.bootLines || defaultLines;
  
  // Insert content count into boot lines if placeholder exists
  const quickLines = bootLines.map(line => ({
    ...line,
    text: line.text.replace('{contentCount}', ContentRegistry.count)
  }));

  for (const line of quickLines) {
    if (bootAborted) break;
    const div = document.createElement('div');
    div.className = 'terminal-line visible' + (line.class ? ' ' + line.class : '');
    div.textContent = line.text;
    terminalEl.appendChild(div);
  }

  triggerGlitch(); triggerRGBSplit();
  await new Promise(r => setTimeout(r, 600));
  if (bootAborted) { terminalEl.classList.add('hidden'); startExperience(); return; }

  // Phase 2: White flash — the "headset snap-on" moment
  terminalEl.style.opacity = '0';
  const flash = document.createElement('div');
  flash.style.cssText = 'position:fixed;inset:0;z-index:999;background:white;opacity:0;transition:opacity 0.08s;';
  document.body.appendChild(flash);
  await new Promise(r => setTimeout(r, 50));
  flash.style.opacity = '0.7';
  triggerGlitch(); triggerScreenTear();
  await new Promise(r => setTimeout(r, 120));
  flash.style.transition = 'opacity 0.4s ease-out';
  flash.style.opacity = '0';
  await new Promise(r => setTimeout(r, 400));
  flash.remove();

  // Phase 3: Go
  terminalEl.classList.add('hidden');
  terminalEl.style.opacity = '';
  terminalEl.style.transition = '';
  startExperience();
}

// ═══════════════════════════════════════════════════════════════
// START EXPERIENCE
// ═══════════════════════════════════════════════════════════════
function startExperience() {
  S.phase = 'init'; S.running = true; S.phaseIndex = 0;
  S.intensity = 0; S.control = 0; S.tranceDepth = 0; S.sessionTime = 0;
  S.waveCount = 0; S.waveState = 'build'; S.waveFloor = 0; S.waveCeiling = 0.15;
  S.waveStartTime = 0; S.breathCycleStart = 0;
  S.denialCount = 0; S.edgeCounter = 0;
  S.permissionActive = false; S.denialActive = false;
  S.releaseActive = false; S.poppersActive = false;
  S.voidburstActive = false; S.intensityFloor = 0;
  S.lastPermissionTime = 0; S.lastPoppersTime = 0;
  S.peakEntryTime = 0; S.grantProbability = 0.1;
  S.lastCommandTime = 0; S.lastMantraTime = 0; S.mantraActive = false;
  S.blackoutActive = false; S.lockoutActive = false; S.aftercareActive = false;
  S.lastFlashTime = 0; S.lastFulltakeTime = 0;
  S.displayedIndices.clear();
  lastCommandEndTime = 0;
  narrativeIndex[0] = 0; narrativeIndex[1] = 0;
  narrativeIndex[2] = 0; narrativeIndex[3] = 0;
  // Reset timesShown for fresh session
  ContentRegistry.items.forEach(it => { it.timesShown = 0; it.lastShown = 0; });
  phaseStartTime = performance.now();

  // Initialize session tracking
  SessionTracker.init();

  // Initialize adaptive content selection
  AdaptiveEngine.startSession();

  document.getElementById('sessionTimer').style.opacity = '1';
  document.getElementById('phaseIndicator').style.opacity = '1';
  document.getElementById('controlMeter').style.opacity = '1';
  document.getElementById('tranceIndicator').style.opacity = '1';
  document.getElementById('waveIndicator').style.opacity = '1';
  document.getElementById('safeHint').style.opacity = '1';
  breathContainer.style.opacity = '1';
  document.getElementById('phaseName').textContent = 'INITIALIZATION';
  document.getElementById('phaseStatus').textContent = 'active';

  updateTicker();
  setTimeout(() => ticker.classList.add('visible'), 2000);
  initAudio();

  // Show poppers HUD if feature is enabled
  if (userSettings.poppersEnabled) {
    document.getElementById('poppersHud').classList.add('visible');
    poppersPaused = false;
    updatePoppersHud();
  } else {
    document.getElementById('poppersHud').classList.remove('visible');
  }

  // Immediately flood the screen so it feels overwhelming from the start
  if (S.contentLoaded) {
    for (let i = 0; i < 12; i++) {
      setTimeout(() => createContentPanel(), i * 300);
    }
    // Spawn a video panel early
    if (ContentRegistry.videoCount > 0) {
      setTimeout(() => createVideoPanel(), 2500);
    }
  }
}

// ═══════════════════════════════════════════════════════════════
// WEBXR IMMERSIVE MODE (Quest 3 Compatible)
// ═══════════════════════════════════════════════════════════════
const XR = {
  session: null,
  refSpace: null,
  isPresenting: false,
  glLayer: null,
  diagnostics: [],
  
  // Log diagnostic info
  log(msg, isError = false) {
    const entry = `[XR] ${msg}`;
    this.diagnostics.push(entry);
    if (isError) {
      console.error(entry);
    } else {
      console.log(entry);
    }
  },
  
  // Check for WebXR support with detailed diagnostics
  async checkSupport() {
    this.diagnostics = [];
    
    // Check secure context
    if (!window.isSecureContext) {
      this.log('NOT in secure context (HTTPS required for WebXR)', true);
      this.log('Serve via HTTPS, localhost, or use ADB port forwarding');
      return { supported: false, reason: 'not-secure-context' };
    }
    this.log('Secure context: YES');
    
    // Check navigator.xr exists
    if (!navigator.xr) {
      this.log('navigator.xr is undefined - WebXR not available', true);
      return { supported: false, reason: 'no-webxr' };
    }
    this.log('navigator.xr: EXISTS');
    
    // Check immersive-vr support
    try {
      const vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
      this.log(`immersive-vr supported: ${vrSupported}`);
      
      if (!vrSupported) {
        return { supported: false, reason: 'vr-not-supported' };
      }
      
      // Also check AR support for future reference
      try {
        const arSupported = await navigator.xr.isSessionSupported('immersive-ar');
        this.log(`immersive-ar supported: ${arSupported}`);
      } catch (e) {
        this.log('immersive-ar check failed (OK, not required)');
      }
      
      return { supported: true, reason: null };
      
    } catch (e) {
      this.log(`Session support check failed: ${e.message}`, true);
      return { supported: false, reason: 'check-failed' };
    }
  },
  
  // Initialize VR button visibility
  async init() {
    const vrBtn = document.getElementById('enterVRBtn');
    const openVRBtn = document.getElementById('openVRWindowBtn');
    
    if (!vrBtn) {
      this.log('VR button not found in DOM');
      return;
    }
    
    // Check if we're in an iframe
    const inIframe = window.self !== window.top;
    this.log(`Running in iframe: ${inIframe}`);
    
    const result = await this.checkSupport();
    
    if (result.supported) {
      if (inIframe) {
        // In iframe - show "Open for VR" button instead
        // because iframe likely blocks xr-spatial-tracking permission
        this.log('In iframe with VR support - showing "Open for VR" button');
        vrBtn.style.display = 'none';
        if (openVRBtn) {
          openVRBtn.style.display = 'inline-block';
          openVRBtn.addEventListener('click', () => this.openInNewWindow());
        }
      } else {
        // Not in iframe - VR should work directly
        vrBtn.style.display = 'inline-block';
        this.log('VR button ENABLED');
      }
    } else {
      vrBtn.style.display = 'none';
      if (openVRBtn) openVRBtn.style.display = 'none';
      this.log(`VR button hidden - reason: ${result.reason}`);
      
      // Show diagnostic info in console for debugging
      console.log('=== VOID WebXR Diagnostics ===');
      this.diagnostics.forEach(d => console.log(d));
      console.log('==============================');
    }
  },
  
  // Open the app in a new window to bypass iframe restrictions
  openInNewWindow() {
    this.log('Opening VOID in new window for VR...');
    
    // Get the full HTML
    const html = document.documentElement.outerHTML;
    
    // Create blob URL
    const blob = new Blob([html], { type: 'text/html' });
    const blobUrl = URL.createObjectURL(blob);
    
    // Open in new window
    const newWindow = window.open(blobUrl, '_blank');
    
    if (newWindow) {
      this.log('New window opened! VR should work there.');
      // Clean up after delay
      setTimeout(() => URL.revokeObjectURL(blobUrl), 10000);
    } else {
      this.log('Popup blocked!', true);
      alert('Popup was blocked. Please allow popups for this site to use VR mode.');
    }
  },
  
  // Start VR session with robust error handling and progressive fallback
  async startSession() {
    this.log('Starting VR session...');
    
    if (!navigator.xr) {
      alert('WebXR not available. Make sure you\'re using HTTPS or localhost.');
      return;
    }
    
    // Try progressively simpler configs until one works
    const configs = [
      {
        name: 'Full features',
        options: {
          requiredFeatures: ['local-floor'],
          optionalFeatures: ['bounded-floor', 'hand-tracking']
        }
      },
      {
        name: 'Optional local-floor',
        options: {
          optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking']
        }
      },
      {
        name: 'Minimal',
        options: {}
      }
    ];
    
    let session = null;
    let usedConfig = null;
    
    for (const config of configs) {
      try {
        this.log(`Trying config: ${config.name}`);
        this.log(`  ${JSON.stringify(config.options)}`);
        
        session = await navigator.xr.requestSession('immersive-vr', config.options);
        usedConfig = config;
        this.log(`✓ SUCCESS with: ${config.name}`);
        break;
        
      } catch (e) {
        this.log(`✗ ${config.name} failed: ${e.message}`);
      }
    }
    
    if (!session) {
      this.log('ALL CONFIGURATIONS FAILED', true);
      alert('Could not start VR session.\n\nAll session configurations were rejected.\nThis may be a browser or device limitation.');
      return;
    }
    
    try {
      this.session = session;
      this.isPresenting = true;
      
      // Create XR layer
      this.log('Creating XRWebGLLayer...');
      this.glLayer = new XRWebGLLayer(session, gl);
      session.updateRenderState({ baseLayer: this.glLayer });
      this.log('Render state updated');
      
      // Get reference space - try multiple options
      this.log('Requesting reference space...');
      const refSpaceTypes = ['local-floor', 'local', 'viewer'];
      
      for (const type of refSpaceTypes) {
        try {
          this.refSpace = await session.requestReferenceSpace(type);
          this.log(`✓ Got "${type}" reference space`);
          break;
        } catch (e) {
          this.log(`  "${type}" not available`);
        }
      }
      
      if (!this.refSpace) {
        this.log('Could not get any reference space!', true);
        await session.end();
        alert('VR session started but no reference space available.');
        return;
      }
      
      // Set up controller input
      this.setupControllers(session);
      
      // Handle session end
      session.addEventListener('end', () => {
        this.log('Session ended');
        this.isPresenting = false;
        this.session = null;
        this.glLayer = null;
        
        // Restore normal rendering
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        resizeCanvas();
        requestAnimationFrame(render);
      });
      
      // Hide entry screen and start the experience
      document.getElementById('entryPrompt').classList.add('hidden');
      createAudioContext();
      startExperience();
      
      // Start XR render loop
      this.log('Starting XR render loop');
      session.requestAnimationFrame(this.renderXR.bind(this));
      
    } catch (e) {
      this.log(`Session setup FAILED: ${e.message}`, true);
      
      if (this.session) {
        await this.session.end();
        this.session = null;
      }
      
      alert(`VR setup error: ${e.message}\n\nCheck console for details.`);
      
      console.log('=== VOID WebXR Error Diagnostics ===');
      this.diagnostics.forEach(d => console.log(d));
      console.log('====================================');
    }
  },
  
  // Set up VR controllers
  setupControllers(session) {
    this.log('Setting up controllers...');
    
    session.addEventListener('selectstart', (event) => {
      this.log('Controller: selectstart');
      
      if (S.permissionActive) {
        const permBtn = document.getElementById('permissionBtn');
        if (permBtn) permBtn.click();
      } else if (!S.running) {
        startExperience();
      } else {
        S.control = Math.min(S.control + 0.02, 1);
        triggerGlitch();
        flashSubliminal();
      }
    });
    
    session.addEventListener('selectend', () => {});
    
    session.addEventListener('squeezestart', () => {
      this.log('Controller: squeezestart');
      // Could trigger poppers rush or other interaction
    });
    
    // Track input sources
    session.addEventListener('inputsourceschange', (event) => {
      this.log(`Input sources changed: ${session.inputSources.length} sources`);
      for (const source of session.inputSources) {
        this.log(`  - ${source.targetRayMode} (hand: ${source.hand ? 'yes' : 'no'})`);
      }
    });
    
    this.log('Controllers configured');
  },
  
  // VR Render loop
  renderXR(timestamp, frame) {
    if (!this.session || !this.isPresenting) return;
    
    // Request next frame first
    this.session.requestAnimationFrame(this.renderXR.bind(this));
    
    const glLayer = this.session.renderState.baseLayer;
    if (!glLayer) return;
    
    // Bind XR framebuffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
    
    // Get viewer pose
    const pose = frame.getViewerPose(this.refSpace);
    if (!pose) return;
    
    // Calculate time
    if (!renderStart) renderStart = timestamp;
    const time = (timestamp - renderStart) / 1000;
    const cfg = S.running ? PHASES[S.phaseIndex] : PHASES[0];
    
    // Update game state
    if (S.running && !S.aftercareActive) {
      updatePhase(performance.now());
      updateSessionTimer();
      updateAudio();
    }
    
    // Render for each eye (stereoscopic)
    for (const view of pose.views) {
      const viewport = glLayer.getViewport(view);
      gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
      
      // Clear with theme background
      gl.clearColor(0.02, 0.0, 0.05, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      
      // Render the spiral shader
      if (program) {
        gl.useProgram(program);
        const theme = ThemeEngine.get();
        const shaderColors = theme.colors?.shader || THEMES.void.colors.shader;
        
        // Extract head rotation for panoramic effect
        const viewMatrix = view.transform.inverse.matrix;
        const yaw = Math.atan2(viewMatrix[8], viewMatrix[10]);
        
        // Offset spiral by head rotation for immersive surround effect
        gl.uniform1f(timeU, time + yaw * 0.5);
        gl.uniform2f(resU, viewport.width, viewport.height);
        gl.uniform1f(intensityU, S.intensity);
        gl.uniform1f(phaseU, S.phaseIndex / (PHASES.length - 1));
        gl.uniform1f(breathU, S.breathProgress);
        gl.uniform1f(pulseHzU, cfg.binauralDiff);
        gl.uniform1f(colorMixU, cfg.colorMix || 0);
        gl.uniform3fv(tBGU, shaderColors.bg);
        gl.uniform3fv(tS1U, shaderColors.spiral1);
        gl.uniform3fv(tS2U, shaderColors.spiral2);
        gl.uniform3fv(tP1U, shaderColors.plasma1);
        gl.uniform3fv(tP2U, shaderColors.plasma2);
        gl.uniform3fv(tGlowU, shaderColors.glow);
        gl.uniform3fv(tAccentU, shaderColors.accent);
        
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
    
    // Occasional glitch effects
    if (S.running && !S.aftercareActive) {
      if (Math.random() < S.glitchRate && !S.blackoutActive && !S.lockoutActive) {
        triggerGlitch();
      }
    }
  },
  
  // End VR session
  async endSession() {
    if (this.session) {
      this.log('Ending session...');
      await this.session.end();
    }
  },
  
  // Diagnostic function - can be called from console
  showDiagnostics() {
    console.log('=== VOID WebXR Diagnostics ===');
    console.log(`Secure context: ${window.isSecureContext}`);
    console.log(`navigator.xr: ${navigator.xr ? 'exists' : 'undefined'}`);
    console.log(`GL context: ${gl ? 'exists' : 'null'}`);
    console.log(`Currently presenting: ${this.isPresenting}`);
    console.log('Recent log:');
    this.diagnostics.slice(-20).forEach(d => console.log('  ' + d));
    console.log('==============================');
    return this.diagnostics;
  }
};

// Initialize VR on load
XR.init();

// VR button click handler
document.getElementById('enterVRBtn')?.addEventListener('click', async () => {
  if (XR.isPresenting) {
    await XR.endSession();
  } else {
    await XR.startSession();
  }
});

// Make XR diagnostics available globally for debugging
window.VOID_XR = XR;

// ═══════════════════════════════════════════════════════════════
// RENDER LOOP
// ═══════════════════════════════════════════════════════════════
let renderStart = 0;

function render(timestamp) {
  if (!renderStart) renderStart = timestamp;
  const time = (timestamp - renderStart) / 1000;
  const cfg = S.running ? PHASES[S.phaseIndex] : PHASES[0];

  if (gl && program) {
    const theme = ThemeEngine.get();
    const shaderColors = theme.colors?.shader || THEMES.void.colors.shader;
    gl.uniform1f(timeU, time);
    gl.uniform2f(resU, canvas.width, canvas.height);
    gl.uniform1f(intensityU, S.intensity);
    gl.uniform1f(phaseU, S.phaseIndex / (PHASES.length-1));
    gl.uniform1f(breathU, S.breathProgress);
    gl.uniform1f(pulseHzU, cfg.binauralDiff);
    gl.uniform1f(colorMixU, cfg.colorMix);
    gl.uniform3fv(tBGU, shaderColors.bg);
    gl.uniform3fv(tS1U, shaderColors.spiral1);
    gl.uniform3fv(tS2U, shaderColors.spiral2);
    gl.uniform3fv(tP1U, shaderColors.plasma1);
    gl.uniform3fv(tP2U, shaderColors.plasma2);
    gl.uniform3fv(tGlowU, shaderColors.glow);
    gl.uniform3fv(tAccentU, shaderColors.accent);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  if (S.running && !S.aftercareActive) {
    updatePhase(performance.now());
    updateSessionTimer();
    updatePanels();
    updateAudio();
    if (Math.random() < S.glitchRate && !S.blackoutActive && !S.lockoutActive) {
      triggerGlitch();
      if (Math.random() < 0.3) triggerRGBSplit();
      if (Math.random() < 0.2) triggerScreenTear();
    }
  }

  requestAnimationFrame(render);
}

requestAnimationFrame(render);

// ═══════════════════════════════════════════════════════════════
// ENTRY / EXIT
// ═══════════════════════════════════════════════════════════════
let bootAborted = false;

document.getElementById('enterBtn').addEventListener('click', () => {
  createAudioContext();
  document.getElementById('entryPrompt').classList.add('hidden');
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen().catch(() => {});
  }
  bootAborted = false;
  runBootSequence();
});

// Skip intro — jump straight to experience
document.getElementById('skipBtn').addEventListener('click', () => {
  if (enterBtn.disabled) return;
  createAudioContext();
  document.getElementById('entryPrompt').classList.add('hidden');
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen().catch(() => {});
  }
  startExperience();
});

// Click during boot sequence to skip it
document.addEventListener('click', (e) => {
  if (!bootAborted && !S.running && !S.aftercareActive &&
      !e.target.closest('.entry-prompt') && !e.target.closest('.upload-panel') &&
      document.getElementById('terminal') && !document.getElementById('terminal').classList.contains('hidden')) {
    bootAborted = true;
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && S.running && !S.aftercareActive) {
    // Clean up any active overlay states
    permissionOverlay.classList.remove('active');
    permissionBtn.style.opacity = '1';
    permissionBtn.style.pointerEvents = 'auto';
    denialOverlay.classList.remove('active');
    releaseOverlay.classList.remove('active');
    releaseOverlay.style.background = '';
    abortPoppers();
    voidburstOverlay.classList.remove('active');
    S.permissionActive = false; S.denialActive = false;
    S.releaseActive = false;
    S.voidburstActive = false; poppersRushActive = false;
    triggerAftercare();
  }
});

document.addEventListener('click', (e) => {
  if (!S.running || S.aftercareActive) return;
  if (e.target.closest('.entry-prompt') || e.target.closest('.upload-panel')) return;
  if (e.target.closest('.permission-overlay') || e.target.closest('.denial-overlay')) return;
  if (S.permissionActive || S.denialActive || S.releaseActive) return;
  S.control = Math.min(S.control + 0.02, 1);
  triggerGlitch();
  subliminalEl.style.left = e.clientX + 'px';
  subliminalEl.style.top = e.clientY + 'px';
  flashSubliminal();
});
</script>
</body>
</html>
