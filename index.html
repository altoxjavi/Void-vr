<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VOID VR - A-Frame</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.9);
      color: #fff;
      font-family: system-ui, sans-serif;
      z-index: 1000;
    }
    #overlay.hidden { display: none; }
    h1 { 
      font-size: 48px; 
      color: #ff2d7b;
      text-shadow: 0 0 30px rgba(255,45,123,0.5);
      margin-bottom: 20px;
    }
    .subtitle {
      color: rgba(255,255,255,0.6);
      margin-bottom: 40px;
    }
    button {
      background: linear-gradient(180deg, rgba(255,45,123,0.3) 0%, rgba(255,45,123,0.1) 100%);
      border: 1px solid rgba(255,45,123,0.5);
      color: #fff;
      padding: 20px 60px;
      font-size: 24px;
      cursor: pointer;
      margin: 10px;
      transition: all 0.3s;
    }
    button:hover {
      background: linear-gradient(180deg, rgba(255,45,123,0.5) 0%, rgba(255,45,123,0.2) 100%);
      box-shadow: 0 0 30px rgba(255,45,123,0.4);
    }
    #status {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: rgba(255,255,255,0.5);
      font-family: monospace;
      font-size: 12px;
      z-index: 1001;
    }
  </style>
</head>
<body>

<div id="overlay">
  <h1>VOID</h1>
  <p class="subtitle">Immersive Trance Experience</p>
  <button id="enterVR">Enter VR</button>
  <button id="enter2D">Start 2D Mode</button>
</div>

<div id="status">Initializing...</div>

<!-- A-Frame Scene -->
<a-scene 
  id="scene"
  vr-mode-ui="enabled: false"
  webxr="requiredFeatures: local-floor; optionalFeatures: bounded-floor, hand-tracking"
  renderer="antialias: true; colorManagement: true;"
  background="color: #0a0010"
>
  <!-- Custom spiral shader on a sphere surrounding the viewer -->
  <a-entity id="voidSphere" void-shader></a-entity>
  
  <!-- Camera at center -->
  <a-entity id="rig" position="0 1.6 0">
    <a-camera id="camera" look-controls="enabled: false"></a-camera>
  </a-entity>
</a-scene>

<script>
// ═══════════════════════════════════════════════════════════════
// VOID SHADER COMPONENT FOR A-FRAME
// ═══════════════════════════════════════════════════════════════

AFRAME.registerComponent('void-shader', {
  schema: {
    intensity: { type: 'number', default: 0.3 },
    phase: { type: 'number', default: 0 },
    breathScale: { type: 'number', default: 1.0 },
    pulseHz: { type: 'number', default: 8 }
  },
  
  init: function() {
    // Create a large inverted sphere (we're inside it)
    const geometry = new THREE.SphereGeometry(50, 64, 64);
    // Flip normals so we see inside
    geometry.scale(-1, 1, 1);
    
    // Create custom shader material
    this.material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        intensity: { value: this.data.intensity },
        phase: { value: this.data.phase },
        breathScale: { value: this.data.breathScale },
        pulseHz: { value: this.data.pulseHz },
        // Theme colors (VOID purple/pink)
        tBG: { value: new THREE.Vector3(0.02, 0.0, 0.04) },
        tS1: { value: new THREE.Vector3(0.6, 0.1, 0.4) },
        tS2: { value: new THREE.Vector3(0.2, 0.0, 0.5) },
        tP1: { value: new THREE.Vector3(0.8, 0.2, 0.5) },
        tP2: { value: new THREE.Vector3(0.3, 0.0, 0.6) },
        tGlow: { value: new THREE.Vector3(1.0, 0.3, 0.6) },
        tAccent: { value: new THREE.Vector3(0.0, 0.8, 1.0) }
      },
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vPosition;
        void main() {
          vUv = uv;
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform float intensity;
        uniform float phase;
        uniform float breathScale;
        uniform float pulseHz;
        uniform vec3 tBG, tS1, tS2, tP1, tP2, tGlow, tAccent;
        
        varying vec2 vUv;
        varying vec3 vPosition;
        
        #define PI 3.14159265359
        
        // Convert spherical UVs to centered coordinates
        vec2 getCoords() {
          // Use spherical coordinates for seamless wrapping
          float theta = vUv.x * 2.0 * PI; // 0 to 2PI
          float phi = (vUv.y - 0.5) * PI;  // -PI/2 to PI/2
          
          // Create centered UV based on view angle
          vec2 uv = vec2(
            cos(phi) * sin(theta),
            sin(phi)
          );
          return uv;
        }
        
        void main() {
          vec2 uv = getCoords();
          float t = time;
          
          // Breathing modulation
          float breathMod = 1.0 + (breathScale - 1.0) * 0.3 * sin(t * 0.15 * PI);
          
          // Spiral pattern
          float angle = atan(uv.y, uv.x);
          float radius = length(uv);
          
          // Multi-layer spiral
          float spiral1 = sin(angle * 3.0 - t * 1.5 + radius * 8.0 * breathMod);
          float spiral2 = sin(angle * 5.0 + t * 1.2 - radius * 12.0 * breathMod);
          float spiral3 = sin(angle * 2.0 - t * 0.8 + radius * 6.0);
          
          // Plasma effect
          float plasma = sin(uv.x * 10.0 + t) * sin(uv.y * 10.0 + t * 1.3);
          plasma += sin(length(uv) * 15.0 - t * 2.0) * 0.5;
          
          // Pulse effect synced to binaural frequency
          float pulse = 0.5 + 0.5 * sin(t * pulseHz * 0.5);
          
          // Combine patterns
          float pattern = spiral1 * 0.4 + spiral2 * 0.3 + spiral3 * 0.2 + plasma * 0.3;
          pattern = pattern * 0.5 + 0.5; // Normalize to 0-1
          
          // Color mixing based on pattern and intensity
          vec3 col = tBG;
          col = mix(col, tS1, smoothstep(0.3, 0.5, pattern) * intensity);
          col = mix(col, tS2, smoothstep(0.5, 0.7, pattern) * intensity);
          col = mix(col, tP1, smoothstep(0.6, 0.8, spiral1 * 0.5 + 0.5) * intensity * 0.5);
          col = mix(col, tP2, smoothstep(0.4, 0.6, plasma * 0.5 + 0.5) * intensity * 0.3);
          
          // Central glow
          float glow = exp(-radius * 2.0) * intensity;
          col += tGlow * glow * 0.5;
          
          // Pulsing accent
          col += tAccent * pulse * 0.1 * intensity;
          
          // Vignette (darker at edges of sphere)
          float vignette = 1.0 - smoothstep(0.5, 1.5, radius);
          col *= vignette * 0.5 + 0.5;
          
          // Phase-based color shift
          col = mix(col, col.gbr, phase * 0.3);
          
          gl_FragColor = vec4(col, 1.0);
        }
      `,
      side: THREE.BackSide
    });
    
    const mesh = new THREE.Mesh(geometry, this.material);
    this.el.setObject3D('mesh', mesh);
    
    this.startTime = performance.now();
    
    // State
    this.intensity = 0.3;
    this.phase = 0;
    this.phaseTime = 0;
    this.running = false;
    
    console.log('[VOID] Shader component initialized');
  },
  
  tick: function(time, delta) {
    if (!this.material) return;
    
    const elapsed = (performance.now() - this.startTime) / 1000;
    this.material.uniforms.time.value = elapsed;
    
    if (this.running) {
      // Gradually increase intensity
      this.intensity = Math.min(this.intensity + delta * 0.00005, 1.0);
      this.material.uniforms.intensity.value = this.intensity;
      
      // Phase progression
      this.phaseTime += delta;
      if (this.phaseTime > 60000) { // New phase every 60 seconds
        this.phase = Math.min(this.phase + 0.2, 1.0);
        this.material.uniforms.phase.value = this.phase;
        this.phaseTime = 0;
      }
      
      // Breathing modulation
      const breath = 1.0 + 0.2 * Math.sin(elapsed * 0.2);
      this.material.uniforms.breathScale.value = breath;
    }
  },
  
  start: function() {
    this.running = true;
    this.startTime = performance.now();
    console.log('[VOID] Experience started');
  },
  
  stop: function() {
    this.running = false;
    console.log('[VOID] Experience stopped');
  }
});

// ═══════════════════════════════════════════════════════════════
// AUDIO ENGINE
// ═══════════════════════════════════════════════════════════════
let audioCtx, masterGain;
let droneL, droneR, gainL, gainR;

function initAudio() {
  if (audioCtx) return;
  
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0;
  masterGain.connect(audioCtx.destination);
  
  // Binaural drones (left: 110Hz, right: 118Hz = 8Hz difference)
  droneL = audioCtx.createOscillator();
  droneL.type = 'sine';
  droneL.frequency.value = 110;
  gainL = audioCtx.createGain();
  gainL.gain.value = 0.15;
  const panL = audioCtx.createStereoPanner();
  panL.pan.value = -1;
  droneL.connect(gainL);
  gainL.connect(panL);
  panL.connect(masterGain);
  
  droneR = audioCtx.createOscillator();
  droneR.type = 'sine';
  droneR.frequency.value = 118;
  gainR = audioCtx.createGain();
  gainR.gain.value = 0.15;
  const panR = audioCtx.createStereoPanner();
  panR.pan.value = 1;
  droneR.connect(gainR);
  gainR.connect(panR);
  panR.connect(masterGain);
  
  droneL.start();
  droneR.start();
  
  // Fade in
  masterGain.gain.setTargetAtTime(0.5, audioCtx.currentTime, 2);
  
  console.log('[VOID] Audio initialized');
}

function stopAudio() {
  if (masterGain) {
    masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 1);
  }
}

// ═══════════════════════════════════════════════════════════════
// INITIALIZATION
// ═══════════════════════════════════════════════════════════════

const scene = document.getElementById('scene');
const overlay = document.getElementById('overlay');
const status = document.getElementById('status');
const enterVRBtn = document.getElementById('enterVR');
const enter2DBtn = document.getElementById('enter2D');

// Check WebXR support
async function checkVR() {
  if (navigator.xr) {
    try {
      const supported = await navigator.xr.isSessionSupported('immersive-vr');
      if (supported) {
        status.textContent = 'VR Ready';
        enterVRBtn.style.display = 'inline-block';
      } else {
        status.textContent = 'VR not supported on this device';
        enterVRBtn.style.display = 'none';
      }
    } catch (e) {
      status.textContent = 'VR check failed: ' + e.message;
      enterVRBtn.style.display = 'none';
    }
  } else {
    status.textContent = 'WebXR not available (need HTTPS)';
    enterVRBtn.style.display = 'none';
  }
}

// Start experience
function startExperience() {
  const voidShader = document.getElementById('voidSphere').components['void-shader'];
  if (voidShader) {
    voidShader.start();
  }
  initAudio();
  overlay.classList.add('hidden');
}

// Enter VR
enterVRBtn.addEventListener('click', async () => {
  startExperience();
  
  // Enter VR mode
  try {
    await scene.enterVR();
    status.textContent = 'In VR';
  } catch (e) {
    status.textContent = 'VR failed: ' + e.message;
    console.error('VR error:', e);
  }
});

// 2D Mode
enter2DBtn.addEventListener('click', () => {
  startExperience();
  status.textContent = '2D Mode Active';
});

// Handle VR exit
scene.addEventListener('exit-vr', () => {
  status.textContent = 'Exited VR';
});

// Initialize
checkVR();
</script>
</body>
</html>
